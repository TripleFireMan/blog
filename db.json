{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/IMG_0004.jpg","path":"images/IMG_0004.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.DS_Store","hash":"7ed6cbbb86398931d4646714904cffaf3bb0316d","modified":1482982151000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1482161160000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1482161160000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1482161160000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1482161160000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1482161160000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1482161160000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1482161160000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1482161160000},{"_id":"themes/next/_config.yml","hash":"17f202d0b1c5293e4c2141eab6971d37437bfe2b","modified":1482981996000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1482161160000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1482161160000},{"_id":"source/.DS_Store","hash":"654aa1e55b5074dd78ec810ef532773037e78810","modified":1482984000000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1482161160000},{"_id":"source/_posts/[译] ios并发编程指南.md","hash":"a01bc988cdfc71060a86c812322c7875cdb36028","modified":1482984418000},{"_id":"source/_posts/《CoreData》系列（一）.md","hash":"4ff7a10612a90a396dd12ecf34a96c5f7e639d24","modified":1482977909000},{"_id":"source/_posts/《CoreData》系列（二）.md","hash":"d9f291cb1b6f742dfa14553e91cd1a4baf17d95e","modified":1482977909000},{"_id":"source/_posts/如何使用subline-text2-作为markdown的编辑工具.md","hash":"a7f894f3fa2b4704784551de14badf914913ec62","modified":1482983321000},{"_id":"source/_posts/点点滴滴：HTTPS和HTTP的区别.md","hash":"8c4f2def6c8ce07bc03d9c16ae71437dd9c27a3a","modified":1482983315000},{"_id":"source/_posts/点点滴滴：NSLog一点说道.md","hash":"ede1e31f5874378708b67e2b66d0eb4925170acf","modified":1482977909000},{"_id":"source/_posts/点点滴滴：NSScanner的用法小结.md","hash":"1ec67f97d07689071e885e71bb2b67302044110f","modified":1482977909000},{"_id":"source/_posts/点点滴滴：一个容易被忽视的数组和字典的方法.md","hash":"3836bf1a040eef8f2f6eb81cb016658276b36bfe","modified":1482977909000},{"_id":"source/_posts/点点滴滴：关于va-list.md","hash":"7299e7759b80760c3b479bd83926cd4f096bc72f","modified":1482977909000},{"_id":"source/_posts/.DS_Store","hash":"75116b4754af5297735ed5b03a0d3bf5d8564882","modified":1482984329000},{"_id":"source/categories/.DS_Store","hash":"86e3f3c98cf04ff31bfc95a89c34e1e9786b6e25","modified":1482981176000},{"_id":"source/categories/index.md","hash":"f3a00ddeea5943dabbfac4ed285a9ccdb4d93084","modified":1482981393000},{"_id":"source/images/.DS_Store","hash":"4aee66b23e63468439d075dc986a38f86c6f2672","modified":1482982146000},{"_id":"source/tags/.DS_Store","hash":"f5f86481c10ea723ad91ef8d026ae3b97af25bdb","modified":1482980350000},{"_id":"source/tags/index.md","hash":"eaf610067dd2bda0f0f3cdd3af08f07a87a93957","modified":1482981386000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1482161160000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1482161160000},{"_id":"themes/next/languages/.DS_Store","hash":"b1364c6441076d392da8a061e726221c54c99510","modified":1482978771000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1482161160000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1482161160000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1482161160000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1482161160000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1482161160000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1482161160000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1482161160000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1482161160000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1482161160000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1482161160000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1482161160000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1482161160000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1482161160000},{"_id":"themes/next/layout/.DS_Store","hash":"fa5ad7a1059a65e50621a520beee49364a7762fa","modified":1482978285000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1482161160000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1482161160000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1482161160000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1482161160000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1482161160000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1482161160000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1482161160000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1482161160000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1482161160000},{"_id":"themes/next/source/.DS_Store","hash":"5171ff83a78736e85df9a242132d03bbb3fcfe66","modified":1482982154000},{"_id":"themes/next/test/.DS_Store","hash":"15a3067f5b98fd59fea005f45fd98a46492c101c","modified":1482981497000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1482161160000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1482161160000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1482161160000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1482161160000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1482161160000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1482161160000},{"_id":"themes/next/layout/_macro/post.swig","hash":"39a8efd961ea2c5758ca4231d3cc4108c1856930","modified":1482161160000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1482161160000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1482161160000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1482161160000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4eb278f7b1b7dfe1088c2b411778cc6129df82bb","modified":1482161160000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1482161160000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1482161160000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1482161160000},{"_id":"themes/next/layout/_partials/header.swig","hash":"5696ee15fc21eb3a6416902afcf1df454497c552","modified":1482161160000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1482161160000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1482161160000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1482161160000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1482161160000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1482161160000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1482161160000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1482161160000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1482161160000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1482161160000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1482161160000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1482161160000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1482161160000},{"_id":"themes/next/source/images/.DS_Store","hash":"7a534464bf375d67231d2bf356e527dff8ef4087","modified":1482982581000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1482161160000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482161160000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482161160000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482161160000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482161160000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482161160000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482161160000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482161160000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482161160000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482161160000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1482161160000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1482161160000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1482161160000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482161160000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1482161160000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1482161160000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1482161160000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1482161160000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1482161160000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1482161160000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1482161160000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1482161160000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1482161160000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1482161160000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1482161160000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1482161160000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"417e16a0fbdcb1b87987787bd7f9fa17eefc2d2b","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1482161160000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1482161160000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1482161160000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1482161160000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1482161160000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"bef514826ebf9eb6e99bb2b0d72285106658a1ec","modified":1482161160000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f0d6aa424f434e82ea507f740eeff110f996269","modified":1482161160000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1482161160000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1482161160000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1482161160000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1482161160000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1482161160000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1482161160000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1482161160000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1482161160000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1482161160000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1482161160000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1482161160000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1482161160000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1482161160000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1482161160000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1482161160000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1482161160000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1482161160000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1482161160000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1482161160000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1482161160000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1482161160000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1482161160000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1482161160000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1482161160000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1482161160000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1482161160000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1482161160000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1482161160000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1482161160000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1482161160000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1482161160000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1482161160000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7e899c4c0aa1312666f2534a4700667d1bfd88da","modified":1482161160000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1482161160000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1482161160000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1482161160000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1482161160000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1482161160000},{"_id":"themes/next/source/images/avatar.gif","hash":"d928df3e3d789d308e443adf3f9214a56f22df45","modified":1482982558000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1482161160000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1482161160000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1482161160000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482161160000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1482161160000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1482161160000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1482161160000},{"_id":"source/images/IMG_0004.jpg","hash":"e1aa1ede6e73f36aa234239af96d51831d4495ba","modified":1482977909000},{"_id":"public/categories/index.html","hash":"6e16e1110928ba9bbfbe900989a8b33fe73f27d5","modified":1482985019198},{"_id":"public/tags/index.html","hash":"4732416c91c2037835917e780350c6130fb91207","modified":1482985019198},{"_id":"public/archives/2016/08/index.html","hash":"b827fda9da79fb713bf0a80598998238fc1efc0e","modified":1482985019199},{"_id":"public/archives/2016/12/index.html","hash":"db52e0c6c0bdd30a57b7b54380a82fe04642f281","modified":1482985019199},{"_id":"public/tags/coredata学习/index.html","hash":"91ea4093c5ce6c15a83aa6a79bcab913a5ba1c1d","modified":1482985019199},{"_id":"public/tags/点点滴滴/index.html","hash":"99bf3756b7986eb2f616c262789403d1a956a545","modified":1482985019199},{"_id":"public/tags/翻译/index.html","hash":"3aafc7174f3297ba84c6bb02f8a23e0dc5363a81","modified":1482985019199},{"_id":"public/2016/12/29/如何使用subline-text2-作为markdown的编辑工具/index.html","hash":"489a1d34f27dba2e6305725d708e3b840fbba0a0","modified":1482985019199},{"_id":"public/2016/08/27/[译] ios并发编程指南/index.html","hash":"b321c8bae6bea0a7368d8a99100d5e8a12d229d6","modified":1482985019199},{"_id":"public/2016/08/27/点点滴滴：HTTPS和HTTP的区别/index.html","hash":"0ccc489311e9e49277acf2d5b3da3b3112f74d69","modified":1482985019199},{"_id":"public/2016/08/27/点点滴滴：一个容易被忽视的数组和字典的方法/index.html","hash":"99c1a470e2d0bed3d66234bb532438e721c40c93","modified":1482985019199},{"_id":"public/2016/08/27/点点滴滴：NSLog一点说道/index.html","hash":"d52455b957178abe5aae7bdc9b82c49bf9be311b","modified":1482985019199},{"_id":"public/2016/08/27/点点滴滴：关于va-list/index.html","hash":"6adfc990de7d2553db9bb642ea2f56c74ff71dcc","modified":1482985019199},{"_id":"public/2016/08/27/点点滴滴：NSScanner的用法小结/index.html","hash":"30260fa8e5519876432cf9998812bc3c02e3f3b5","modified":1482985019199},{"_id":"public/2016/08/27/《CoreData》系列（二）/index.html","hash":"d33effbb0408e4a4dc057472abde899fcb8ce0bc","modified":1482985019199},{"_id":"public/2016/08/27/《CoreData》系列（一）/index.html","hash":"bc31788c91afc7feb7dc7a41206c029a3d3857af","modified":1482985019199},{"_id":"public/archives/index.html","hash":"76c5a80c59f5f6a740148e83ca091a7222cea3f2","modified":1482985019199},{"_id":"public/archives/2016/index.html","hash":"0bc4b6aad2133bb64fb4da1f4895ea0c8fb3ed39","modified":1482985019200},{"_id":"public/index.html","hash":"61b90cc8964b7570f59227e758d02fd1b06ccbb9","modified":1482985019200},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1482984280765},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482984280765},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482984280765},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482984280765},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482984280765},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482984280765},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482984280765},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482984280766},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482984280766},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482984280766},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1482984280766},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1482984280766},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1482984280766},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1482984280766},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1482984280766},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482984280766},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482984280766},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482984280766},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482984280766},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482984280766},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482984280766},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1482984280766},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482984280766},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1482984281310},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1482984281323},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1482984281327},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1482984281327},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1482984281333},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1482984281333},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1482984281334},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1482984281334},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1482984281334},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1482984281334},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1482984281334},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1482984281334},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1482984281334},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1482984281334},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1482984281334},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1482984281334},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1482984281334},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1482984281334},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1482984281334},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1482984281334},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1482984281334},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1482984281334},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1482984281334},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1482984281334},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1482984281334},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1482984281334},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1482984281334},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1482984281334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482984281334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1482984281334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1482984281334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482984281334},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1482984281334},{"_id":"public/css/main.css","hash":"15c331fb8e2f630fc48e6c3860faa4694840aec3","modified":1482984281334},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1482984281334},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1482984281335},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482984281335},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1482984281335},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1482984281335},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1482984281335},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1482984281335},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1482984281335},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1482984281335},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1482984281335},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1482984281335},{"_id":"public/images/avatar.gif","hash":"d928df3e3d789d308e443adf3f9214a56f22df45","modified":1482984281339},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1482984281339},{"_id":"public/images/IMG_0004.jpg","hash":"e1aa1ede6e73f36aa234239af96d51831d4495ba","modified":1482984281354}],"Category":[],"Data":[],"Page":[{"title":"分类","date":"2016-12-29T03:05:19.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-12-29 11:05:19\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-12-29T03:16:33.000Z","path":"categories/index.html","layout":"page","_id":"cix9ujtkq000o492wmtrq7l2b","content":"","excerpt":"","more":""},{"title":"标签","date":"2016-12-29T02:58:47.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-12-29 10:58:47\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-12-29T03:16:26.000Z","path":"tags/index.html","layout":"page","_id":"cix9ujtku000p492w6d0yf8ia","content":"","excerpt":"","more":""}],"Post":[{"title":"《CoreData》系列（一）","date":"2016-08-27T08:47:45.000Z","comments":1,"_content":"\n\n\n## 《题外篇》\n\n<!---more-->\n\n学习这个东西贵在日积月累，而且事情往往说起来容易，做起来难，我是一个资深dota玩家，从dota1到dota2，从大学到工作，从2008年到2015年。一直看2009的视频，经常吐槽09视频更新速度慢，但是细细想想，09能保持优酷更新401（最近查看）期视频。又有多少人能做的到。\n故而最近下了一个决定，每周五务必更新一篇技术博客，就看看自己能坚持多久。\n\n## 《正文》\n\n[1 概述](#1)\n本系列研究讨论的是iOS开发中的一种数据持久化技术－coredata。coredata、sqlite、fmdb的优缺点不是我要讨论的重点\n\n这个系列的blog主要会研究讨论以下几点\n\t1.快速搭建coredata环境，主要是连接数据库、创建数据库托管对象模型（NSManagerObject）、如何保存数据、查询数据？\n\t2.coredata升级以及数据迁移的三种方式。\n\t3.coredata与viewcontroller的结合，通过NSFetchedResultController使用coredata数据。\n\t4.导入默认数据和前后台context。\n\t5.关系\n\n[2 环境搭建](#1)\n\n[2.1 导入《CoreData》的framework](#2)\n默认读者知道如何创建一个空白的项目，建立好空白项目之后，搜索coredata按图2-1操作，点击添加完成framework的引入。\n![图 2-1](http://ock9zbzms.bkt.clouddn.com/20151030175726289.jpg)\n\n[2.2 创建Model](#2)\n完成上述第一步，意味着我们已经可以使用CoreData提供的接口API了，接下来就是如何使用的事儿了。创建一个CoreData文件夹，专门用来放CoreData引擎，创建好文件夹后，右键点击选择newfile，然后按照图2-2所示创建数据库模型文件，并将其命名为Model,然后点击Model,添加Entity（表\\Class）,添加Attribute（字段\\属性），到这一部，基本上就把Model，创建出来了。并且里面有了数据模型结构，接下来的问题就是，连接数据库，根据模型创建托管对象了\n![图 2-2](http://ock9zbzms.bkt.clouddn.com/20151030180051371.jpg)\n\n[2.3 代码连接数据库](#2)\n好啦，前面只是开胃菜，真正的大餐马上就要来了，在吃大餐前，有一些名称需要说明下\n\n1.NSManagedObjectContext - 托管对象上下文，用来干嘛的呢？望文生意，用来管理托管对象的，负责从数据库中获取对象、保存对象、删除对象等等操作。\n2.NSManagedObjectModel - 对象模型， 根据我们上面创建的数据模型，创建出托管对象模型，（类似于加工厂的概念，能够用来生产对象的模子）\n3.NSPersistentStoreCoordinator - 持久化存储协调器，包含数据库的名称、存储数据类型（Sqlite、Xml、内存）、位置等信息\n4.NSPersistentStore - 持久化存储区\n\n另外再附一张图来说明这几者的依赖关系\n![](http://ock9zbzms.bkt.clouddn.com/20151030232125923.png)\n\n由于CoreData管理数据的过程较为通用，个人觉的还是封装成一个管理对象较好，方便以后代码复用，这里创建一个CoreDataHelper的类，专门用来管理数据对象，该类的头文件如下\n\n```objc\n#import <Foundation/Foundation.h>  \n#import <CoreData/CoreData.h>  \n@interface CoreDataHelper : NSObject  \n@property (nonatomic, strong) NSManagedObjectContext       *context;//托管对象上下文  \n@property (nonatomic, strong) NSManagedObjectModel         *model;//托管对象模型  \n@property (nonatomic, strong) NSPersistentStoreCoordinator *coordinate;//持久化存储协调器  \n@property (nonatomic, strong) NSPersistentStore            *store;//持久化存储区  \n- (id)init;             //初始化  \n- (void)loadStore;      //加载cordite  \n- (void)setupCoreData;  //设置cordite相关信息  \n- (void)saveContext;    //保存context  \n```\nCoreDataHelp的实现文件如下\n\n```objc\n#import \"CoreDataHelper.h\"  \nstatic NSString *storeFileName = @\"demo.sqlite\";    //测试数据库  \n  \n@implementation CoreDataHelper  \n  \n#pragma mark - PATHS  \n  \n- (NSString *)applicationDocumentDirectory  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  \n    return [paths lastObject];  \n}  \n  \n- (NSURL *)applicationStoreDirectory  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    NSURL *url = [[NSURL fileURLWithPath:[self applicationDocumentDirectory]] URLByAppendingPathComponent:@\"stores\"];  \n    if (![[NSFileManager defaultManager]fileExistsAtPath:[url path]]) {  \n        NSError *error = nil;  \n        BOOL success   = [[NSFileManager defaultManager]createDirectoryAtURL:url  \n                                               withIntermediateDirectories:YES  \n                                                                attributes:nil  \n                                                                     error:&error];  \n        if (success) {  \n            if (debug) {  \n                NSLog(@\"success create directory!\");  \n            }  \n        }else{  \n            NSLog(@\"failed create directory!\");  \n        }  \n    }  \n      \n    return url;  \n}  \n  \n- (NSURL *)storeUrl  \n{  \n    NSURL *storeUrl = [[self applicationStoreDirectory]URLByAppendingPathComponent:storeFileName];  \n    NSLog(@\"storeurl = %@\",storeUrl);  \n    return storeUrl;  \n}  \n  \n#pragma mark - SETUP  \n- (id)init  \n{  \n    if (self) {  \n        _model      = [NSManagedObjectModel mergedModelFromBundles:nil];  \n        _coordinate = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:_model];  \n        _context    = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType];  \n        [_context setMergePolicy:NSMergeByPropertyObjectTrumpMergePolicy];  \n        [_context setPersistentStoreCoordinator:_coordinate];  \n          \n        _importContext = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSPrivateQueueConcurrencyType];  \n          \n        [_importContext performBlock:^{  \n            [_importContext setPersistentStoreCoordinator:_coordinate];  \n            [_importContext setMergePolicy:NSMergeByPropertyObjectTrumpMergePolicy];  \n            [_importContext setUndoManager:nil];  \n        }];  \n    }  \n    return self;  \n}  \n  \n- (void)loadStore  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ ,'%@'\",[self class], NSStringFromSelector(_cmd));  \n    }  \n      \n    if (_store) {  \n        return;  \n    }  \n  \n    NSError *error;  \n          \n        //NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  \n        //NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  \n        NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                                 NSInferMappingModelAutomaticallyOption:@(YES),  \n                                 NSSQLitePragmasOption:@{@\"journal_mode\":@\"DELETE\"}};  \n          \n        _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                           configuration:nil  \n                                                     URL:[self storeUrl]  \n                                                 options:option  \n                                                   error:&error];  \n        if (!_store) {  \n            if (debug) {  \n                NSLog(@\"failed load store,error = %@\",error);  \n                abort();  \n            }  \n        }  \n        else/**/{  \n            NSLog(@\"successfully add store : %@\",_store);  \n        }  \n}  \n  \n- (void)setupCoreData  \n{  \n    [self loadStore];  \n}  \n  \n- (void)saveContext  \n{  \n    if ([_context hasChanges]) {  \n        NSError *error = nil;  \n        if ([_context save:&error]) {  \n            NSLog(@\"context save successfully\");  \n        }else{  \n            NSLog(@\"failed save %@\",error);  \n        }  \n    }else{  \n        NSLog(@\"skipped context save , there is no changes\");  \n    }  \n}  \n  \n@end  \n```\n[2.4 最后附上查询和保存数据库的代码](#2)\n在AppDelegate.m文件里写一个方法，用来初始化CoreData数据库\n\n```objc\n- (CoreDataHelper *)cdh  \n{  \n    if (!_cdh) {  \n        static dispatch_once_t onceToken;  \n        dispatch_once(&onceToken, ^{  \n            _cdh = [CoreDataHelper new];  \n              \n        });  \n        [_cdh setupCoreData];  \n    }  \n    return _cdh;  \n}  \n```\n\n下面是插入数据，查询、保存数据的方法\n```objc\n- (void)demo  \n{  \n    Item *bananer = [NSEntityDescription insertNewObjectForEntityForName:@\"Item\" inManagedObjectContext:[[self cdh] context]];  \n    bananer.unit = kg;  \n    bananer.name = @\"bananer\";  \n      \n    Item *oranger = [NSEntityDescription insertNewObjectForEntityForName:@\"Item\" inManagedObjectContext:[[self cdh] context]];  \n    oranger.unit = kg;  \n    oranger.name = @\"Oranger\";  \n      \n    NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@\"Item\"];  \n    NSArray *result = [[[self cdh]context] executeFetchRequest:request error:nil];  \n    for (Item *item in result) {  \n        if (debug) {  \n            NSLog(@\"item.name = %@\",item.name);  \n        }  \n    }  \n    [[self cdh]saveContext];  \n} \n```\n[2.5 小结](#2)\n经过这么一番下来，终于将CoreData技术应用到我们的项目中了，我们现在能做到，把数据插入到数据库、也能从数据库中读取出数据来，也能保存数据。但是要注意这才是刚刚开始，接下来还有更多的coredata问题等着我们，比方说下节要介绍的数据迁移问题。\n","source":"_posts/《CoreData》系列（一）.md","raw":"---\ntitle: 《CoreData》系列（一）\ndate: 2016-08-27 16:47:45\ntags: coredata学习\ncomments: true\n---\n\n\n\n## 《题外篇》\n\n<!---more-->\n\n学习这个东西贵在日积月累，而且事情往往说起来容易，做起来难，我是一个资深dota玩家，从dota1到dota2，从大学到工作，从2008年到2015年。一直看2009的视频，经常吐槽09视频更新速度慢，但是细细想想，09能保持优酷更新401（最近查看）期视频。又有多少人能做的到。\n故而最近下了一个决定，每周五务必更新一篇技术博客，就看看自己能坚持多久。\n\n## 《正文》\n\n[1 概述](#1)\n本系列研究讨论的是iOS开发中的一种数据持久化技术－coredata。coredata、sqlite、fmdb的优缺点不是我要讨论的重点\n\n这个系列的blog主要会研究讨论以下几点\n\t1.快速搭建coredata环境，主要是连接数据库、创建数据库托管对象模型（NSManagerObject）、如何保存数据、查询数据？\n\t2.coredata升级以及数据迁移的三种方式。\n\t3.coredata与viewcontroller的结合，通过NSFetchedResultController使用coredata数据。\n\t4.导入默认数据和前后台context。\n\t5.关系\n\n[2 环境搭建](#1)\n\n[2.1 导入《CoreData》的framework](#2)\n默认读者知道如何创建一个空白的项目，建立好空白项目之后，搜索coredata按图2-1操作，点击添加完成framework的引入。\n![图 2-1](http://ock9zbzms.bkt.clouddn.com/20151030175726289.jpg)\n\n[2.2 创建Model](#2)\n完成上述第一步，意味着我们已经可以使用CoreData提供的接口API了，接下来就是如何使用的事儿了。创建一个CoreData文件夹，专门用来放CoreData引擎，创建好文件夹后，右键点击选择newfile，然后按照图2-2所示创建数据库模型文件，并将其命名为Model,然后点击Model,添加Entity（表\\Class）,添加Attribute（字段\\属性），到这一部，基本上就把Model，创建出来了。并且里面有了数据模型结构，接下来的问题就是，连接数据库，根据模型创建托管对象了\n![图 2-2](http://ock9zbzms.bkt.clouddn.com/20151030180051371.jpg)\n\n[2.3 代码连接数据库](#2)\n好啦，前面只是开胃菜，真正的大餐马上就要来了，在吃大餐前，有一些名称需要说明下\n\n1.NSManagedObjectContext - 托管对象上下文，用来干嘛的呢？望文生意，用来管理托管对象的，负责从数据库中获取对象、保存对象、删除对象等等操作。\n2.NSManagedObjectModel - 对象模型， 根据我们上面创建的数据模型，创建出托管对象模型，（类似于加工厂的概念，能够用来生产对象的模子）\n3.NSPersistentStoreCoordinator - 持久化存储协调器，包含数据库的名称、存储数据类型（Sqlite、Xml、内存）、位置等信息\n4.NSPersistentStore - 持久化存储区\n\n另外再附一张图来说明这几者的依赖关系\n![](http://ock9zbzms.bkt.clouddn.com/20151030232125923.png)\n\n由于CoreData管理数据的过程较为通用，个人觉的还是封装成一个管理对象较好，方便以后代码复用，这里创建一个CoreDataHelper的类，专门用来管理数据对象，该类的头文件如下\n\n```objc\n#import <Foundation/Foundation.h>  \n#import <CoreData/CoreData.h>  \n@interface CoreDataHelper : NSObject  \n@property (nonatomic, strong) NSManagedObjectContext       *context;//托管对象上下文  \n@property (nonatomic, strong) NSManagedObjectModel         *model;//托管对象模型  \n@property (nonatomic, strong) NSPersistentStoreCoordinator *coordinate;//持久化存储协调器  \n@property (nonatomic, strong) NSPersistentStore            *store;//持久化存储区  \n- (id)init;             //初始化  \n- (void)loadStore;      //加载cordite  \n- (void)setupCoreData;  //设置cordite相关信息  \n- (void)saveContext;    //保存context  \n```\nCoreDataHelp的实现文件如下\n\n```objc\n#import \"CoreDataHelper.h\"  \nstatic NSString *storeFileName = @\"demo.sqlite\";    //测试数据库  \n  \n@implementation CoreDataHelper  \n  \n#pragma mark - PATHS  \n  \n- (NSString *)applicationDocumentDirectory  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  \n    return [paths lastObject];  \n}  \n  \n- (NSURL *)applicationStoreDirectory  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    NSURL *url = [[NSURL fileURLWithPath:[self applicationDocumentDirectory]] URLByAppendingPathComponent:@\"stores\"];  \n    if (![[NSFileManager defaultManager]fileExistsAtPath:[url path]]) {  \n        NSError *error = nil;  \n        BOOL success   = [[NSFileManager defaultManager]createDirectoryAtURL:url  \n                                               withIntermediateDirectories:YES  \n                                                                attributes:nil  \n                                                                     error:&error];  \n        if (success) {  \n            if (debug) {  \n                NSLog(@\"success create directory!\");  \n            }  \n        }else{  \n            NSLog(@\"failed create directory!\");  \n        }  \n    }  \n      \n    return url;  \n}  \n  \n- (NSURL *)storeUrl  \n{  \n    NSURL *storeUrl = [[self applicationStoreDirectory]URLByAppendingPathComponent:storeFileName];  \n    NSLog(@\"storeurl = %@\",storeUrl);  \n    return storeUrl;  \n}  \n  \n#pragma mark - SETUP  \n- (id)init  \n{  \n    if (self) {  \n        _model      = [NSManagedObjectModel mergedModelFromBundles:nil];  \n        _coordinate = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:_model];  \n        _context    = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType];  \n        [_context setMergePolicy:NSMergeByPropertyObjectTrumpMergePolicy];  \n        [_context setPersistentStoreCoordinator:_coordinate];  \n          \n        _importContext = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSPrivateQueueConcurrencyType];  \n          \n        [_importContext performBlock:^{  \n            [_importContext setPersistentStoreCoordinator:_coordinate];  \n            [_importContext setMergePolicy:NSMergeByPropertyObjectTrumpMergePolicy];  \n            [_importContext setUndoManager:nil];  \n        }];  \n    }  \n    return self;  \n}  \n  \n- (void)loadStore  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ ,'%@'\",[self class], NSStringFromSelector(_cmd));  \n    }  \n      \n    if (_store) {  \n        return;  \n    }  \n  \n    NSError *error;  \n          \n        //NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  \n        //NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  \n        NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                                 NSInferMappingModelAutomaticallyOption:@(YES),  \n                                 NSSQLitePragmasOption:@{@\"journal_mode\":@\"DELETE\"}};  \n          \n        _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                           configuration:nil  \n                                                     URL:[self storeUrl]  \n                                                 options:option  \n                                                   error:&error];  \n        if (!_store) {  \n            if (debug) {  \n                NSLog(@\"failed load store,error = %@\",error);  \n                abort();  \n            }  \n        }  \n        else/**/{  \n            NSLog(@\"successfully add store : %@\",_store);  \n        }  \n}  \n  \n- (void)setupCoreData  \n{  \n    [self loadStore];  \n}  \n  \n- (void)saveContext  \n{  \n    if ([_context hasChanges]) {  \n        NSError *error = nil;  \n        if ([_context save:&error]) {  \n            NSLog(@\"context save successfully\");  \n        }else{  \n            NSLog(@\"failed save %@\",error);  \n        }  \n    }else{  \n        NSLog(@\"skipped context save , there is no changes\");  \n    }  \n}  \n  \n@end  \n```\n[2.4 最后附上查询和保存数据库的代码](#2)\n在AppDelegate.m文件里写一个方法，用来初始化CoreData数据库\n\n```objc\n- (CoreDataHelper *)cdh  \n{  \n    if (!_cdh) {  \n        static dispatch_once_t onceToken;  \n        dispatch_once(&onceToken, ^{  \n            _cdh = [CoreDataHelper new];  \n              \n        });  \n        [_cdh setupCoreData];  \n    }  \n    return _cdh;  \n}  \n```\n\n下面是插入数据，查询、保存数据的方法\n```objc\n- (void)demo  \n{  \n    Item *bananer = [NSEntityDescription insertNewObjectForEntityForName:@\"Item\" inManagedObjectContext:[[self cdh] context]];  \n    bananer.unit = kg;  \n    bananer.name = @\"bananer\";  \n      \n    Item *oranger = [NSEntityDescription insertNewObjectForEntityForName:@\"Item\" inManagedObjectContext:[[self cdh] context]];  \n    oranger.unit = kg;  \n    oranger.name = @\"Oranger\";  \n      \n    NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@\"Item\"];  \n    NSArray *result = [[[self cdh]context] executeFetchRequest:request error:nil];  \n    for (Item *item in result) {  \n        if (debug) {  \n            NSLog(@\"item.name = %@\",item.name);  \n        }  \n    }  \n    [[self cdh]saveContext];  \n} \n```\n[2.5 小结](#2)\n经过这么一番下来，终于将CoreData技术应用到我们的项目中了，我们现在能做到，把数据插入到数据库、也能从数据库中读取出数据来，也能保存数据。但是要注意这才是刚刚开始，接下来还有更多的coredata问题等着我们，比方说下节要介绍的数据迁移问题。\n","slug":"《CoreData》系列（一）","published":1,"updated":"2016-12-29T02:18:29.000Z","layout":"post","photos":[],"link":"","_id":"cix9ujtfl0000492wg1drvkjb","content":"<h2 id=\"《题外篇》\"><a href=\"#《题外篇》\" class=\"headerlink\" title=\"《题外篇》\"></a>《题外篇》</h2><a id=\"more\"></a>\n<p>学习这个东西贵在日积月累，而且事情往往说起来容易，做起来难，我是一个资深dota玩家，从dota1到dota2，从大学到工作，从2008年到2015年。一直看2009的视频，经常吐槽09视频更新速度慢，但是细细想想，09能保持优酷更新401（最近查看）期视频。又有多少人能做的到。<br>故而最近下了一个决定，每周五务必更新一篇技术博客，就看看自己能坚持多久。</p>\n<h2 id=\"《正文》\"><a href=\"#《正文》\" class=\"headerlink\" title=\"《正文》\"></a>《正文》</h2><p><a href=\"#1\">1 概述</a><br>本系列研究讨论的是iOS开发中的一种数据持久化技术－coredata。coredata、sqlite、fmdb的优缺点不是我要讨论的重点</p>\n<p>这个系列的blog主要会研究讨论以下几点<br>    1.快速搭建coredata环境，主要是连接数据库、创建数据库托管对象模型（NSManagerObject）、如何保存数据、查询数据？<br>    2.coredata升级以及数据迁移的三种方式。<br>    3.coredata与viewcontroller的结合，通过NSFetchedResultController使用coredata数据。<br>    4.导入默认数据和前后台context。<br>    5.关系</p>\n<p><a href=\"#1\">2 环境搭建</a></p>\n<p><a href=\"#2\">2.1 导入《CoreData》的framework</a><br>默认读者知道如何创建一个空白的项目，建立好空白项目之后，搜索coredata按图2-1操作，点击添加完成framework的引入。<br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151030175726289.jpg\" alt=\"图 2-1\"></p>\n<p><a href=\"#2\">2.2 创建Model</a><br>完成上述第一步，意味着我们已经可以使用CoreData提供的接口API了，接下来就是如何使用的事儿了。创建一个CoreData文件夹，专门用来放CoreData引擎，创建好文件夹后，右键点击选择newfile，然后按照图2-2所示创建数据库模型文件，并将其命名为Model,然后点击Model,添加Entity（表\\Class）,添加Attribute（字段\\属性），到这一部，基本上就把Model，创建出来了。并且里面有了数据模型结构，接下来的问题就是，连接数据库，根据模型创建托管对象了<br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151030180051371.jpg\" alt=\"图 2-2\"></p>\n<p><a href=\"#2\">2.3 代码连接数据库</a><br>好啦，前面只是开胃菜，真正的大餐马上就要来了，在吃大餐前，有一些名称需要说明下</p>\n<p>1.NSManagedObjectContext - 托管对象上下文，用来干嘛的呢？望文生意，用来管理托管对象的，负责从数据库中获取对象、保存对象、删除对象等等操作。<br>2.NSManagedObjectModel - 对象模型， 根据我们上面创建的数据模型，创建出托管对象模型，（类似于加工厂的概念，能够用来生产对象的模子）<br>3.NSPersistentStoreCoordinator - 持久化存储协调器，包含数据库的名称、存储数据类型（Sqlite、Xml、内存）、位置等信息<br>4.NSPersistentStore - 持久化存储区</p>\n<p>另外再附一张图来说明这几者的依赖关系<br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151030232125923.png\" alt=\"\"></p>\n<p>由于CoreData管理数据的过程较为通用，个人觉的还是封装成一个管理对象较好，方便以后代码复用，这里创建一个CoreDataHelper的类，专门用来管理数据对象，该类的头文件如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span>  </span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CoreData/CoreData.h&gt;</span>  </span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CoreDataHelper</span> : <span class=\"title\">NSObject</span>  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSManagedObjectContext</span>       *context;<span class=\"comment\">//托管对象上下文  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSManagedObjectModel</span>         *model;<span class=\"comment\">//托管对象模型  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSPersistentStoreCoordinator</span> *coordinate;<span class=\"comment\">//持久化存储协调器  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSPersistentStore</span>            *store;<span class=\"comment\">//持久化存储区  </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init;             <span class=\"comment\">//初始化  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)loadStore;      <span class=\"comment\">//加载cordite  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupCoreData;  <span class=\"comment\">//设置cordite相关信息  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)saveContext;    <span class=\"comment\">//保存context</span></div></pre></td></tr></table></figure>\n<p>CoreDataHelp的实现文件如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CoreDataHelper.h\"</span>  </span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *storeFileName = <span class=\"string\">@\"demo.sqlite\"</span>;    <span class=\"comment\">//测试数据库  </span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CoreDataHelper</span>  </span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#pragma mark - PATHS  </span></div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)applicationDocumentDirectory  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *paths = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>);  </div><div class=\"line\">    <span class=\"keyword\">return</span> [paths lastObject];  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"built_in\">NSURL</span> *)applicationStoreDirectory  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSURL</span> fileURLWithPath:[<span class=\"keyword\">self</span> applicationDocumentDirectory]] URLByAppendingPathComponent:<span class=\"string\">@\"stores\"</span>];  </div><div class=\"line\">    <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager]fileExistsAtPath:[url path]]) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> success   = [[<span class=\"built_in\">NSFileManager</span> defaultManager]createDirectoryAtURL:url  </div><div class=\"line\">                                               withIntermediateDirectories:<span class=\"literal\">YES</span>  </div><div class=\"line\">                                                                attributes:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                                     error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"success create directory!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed create directory!\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> url;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"built_in\">NSURL</span> *)storeUrl  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *storeUrl = [[<span class=\"keyword\">self</span> applicationStoreDirectory]URLByAppendingPathComponent:storeFileName];  </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"storeurl = %@\"</span>,storeUrl);  </div><div class=\"line\">    <span class=\"keyword\">return</span> storeUrl;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#pragma mark - SETUP  </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;  </div><div class=\"line\">        _model      = [<span class=\"built_in\">NSManagedObjectModel</span> mergedModelFromBundles:<span class=\"literal\">nil</span>];  </div><div class=\"line\">        _coordinate = [[<span class=\"built_in\">NSPersistentStoreCoordinator</span> alloc]initWithManagedObjectModel:_model];  </div><div class=\"line\">        _context    = [[<span class=\"built_in\">NSManagedObjectContext</span> alloc]initWithConcurrencyType:<span class=\"built_in\">NSMainQueueConcurrencyType</span>];  </div><div class=\"line\">        [_context setMergePolicy:<span class=\"built_in\">NSMergeByPropertyObjectTrumpMergePolicy</span>];  </div><div class=\"line\">        [_context setPersistentStoreCoordinator:_coordinate];  </div><div class=\"line\">          </div><div class=\"line\">        _importContext = [[<span class=\"built_in\">NSManagedObjectContext</span> alloc]initWithConcurrencyType:<span class=\"built_in\">NSPrivateQueueConcurrencyType</span>];  </div><div class=\"line\">          </div><div class=\"line\">        [_importContext performBlock:^&#123;  </div><div class=\"line\">            [_importContext setPersistentStoreCoordinator:_coordinate];  </div><div class=\"line\">            [_importContext setMergePolicy:<span class=\"built_in\">NSMergeByPropertyObjectTrumpMergePolicy</span>];  </div><div class=\"line\">            [_importContext setUndoManager:<span class=\"literal\">nil</span>];  </div><div class=\"line\">        &#125;];  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)loadStore  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ ,'%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">if</span> (_store) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  </span></div><div class=\"line\">        <span class=\"comment\">//NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  </span></div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *option = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSSQLitePragmasOption</span>:@&#123;<span class=\"string\">@\"journal_mode\"</span>:<span class=\"string\">@\"DELETE\"</span>&#125;&#125;;  </div><div class=\"line\">          </div><div class=\"line\">        _store = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                           configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                     URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                                 options:option  </div><div class=\"line\">                                                   error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (!_store) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed load store,error = %@\"</span>,error);  </div><div class=\"line\">                abort();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">/**/</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"successfully add store : %@\"</span>,_store);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupCoreData  </div><div class=\"line\">&#123;  </div><div class=\"line\">    [<span class=\"keyword\">self</span> loadStore];  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)saveContext  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ([_context hasChanges]) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">        <span class=\"keyword\">if</span> ([_context save:&amp;error]) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"context save successfully\"</span>);  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed save %@\"</span>,error);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"skipped context save , there is no changes\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><a href=\"#2\">2.4 最后附上查询和保存数据库的代码</a><br>在AppDelegate.m文件里写一个方法，用来初始化CoreData数据库</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (CoreDataHelper *)cdh  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (!_cdh) &#123;  </div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;  </div><div class=\"line\">        <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;  </div><div class=\"line\">            _cdh = [CoreDataHelper new];  </div><div class=\"line\">              </div><div class=\"line\">        &#125;);  </div><div class=\"line\">        [_cdh setupCoreData];  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> _cdh;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面是插入数据，查询、保存数据的方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)demo  </div><div class=\"line\">&#123;  </div><div class=\"line\">    Item *bananer = [<span class=\"built_in\">NSEntityDescription</span> insertNewObjectForEntityForName:<span class=\"string\">@\"Item\"</span> inManagedObjectContext:[[<span class=\"keyword\">self</span> cdh] context]];  </div><div class=\"line\">    bananer.unit = kg;  </div><div class=\"line\">    bananer.name = <span class=\"string\">@\"bananer\"</span>;  </div><div class=\"line\">      </div><div class=\"line\">    Item *oranger = [<span class=\"built_in\">NSEntityDescription</span> insertNewObjectForEntityForName:<span class=\"string\">@\"Item\"</span> inManagedObjectContext:[[<span class=\"keyword\">self</span> cdh] context]];  </div><div class=\"line\">    oranger.unit = kg;  </div><div class=\"line\">    oranger.name = <span class=\"string\">@\"Oranger\"</span>;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSFetchRequest</span> *request = [<span class=\"built_in\">NSFetchRequest</span> fetchRequestWithEntityName:<span class=\"string\">@\"Item\"</span>];  </div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *result = [[[<span class=\"keyword\">self</span> cdh]context] executeFetchRequest:request error:<span class=\"literal\">nil</span>];  </div><div class=\"line\">    <span class=\"keyword\">for</span> (Item *item <span class=\"keyword\">in</span> result) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"item.name = %@\"</span>,item.name);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    [[<span class=\"keyword\">self</span> cdh]saveContext];  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"#2\">2.5 小结</a><br>经过这么一番下来，终于将CoreData技术应用到我们的项目中了，我们现在能做到，把数据插入到数据库、也能从数据库中读取出数据来，也能保存数据。但是要注意这才是刚刚开始，接下来还有更多的coredata问题等着我们，比方说下节要介绍的数据迁移问题。</p>\n","excerpt":"<h2 id=\"《题外篇》\"><a href=\"#《题外篇》\" class=\"headerlink\" title=\"《题外篇》\"></a>《题外篇》</h2>","more":"<p>学习这个东西贵在日积月累，而且事情往往说起来容易，做起来难，我是一个资深dota玩家，从dota1到dota2，从大学到工作，从2008年到2015年。一直看2009的视频，经常吐槽09视频更新速度慢，但是细细想想，09能保持优酷更新401（最近查看）期视频。又有多少人能做的到。<br>故而最近下了一个决定，每周五务必更新一篇技术博客，就看看自己能坚持多久。</p>\n<h2 id=\"《正文》\"><a href=\"#《正文》\" class=\"headerlink\" title=\"《正文》\"></a>《正文》</h2><p><a href=\"#1\">1 概述</a><br>本系列研究讨论的是iOS开发中的一种数据持久化技术－coredata。coredata、sqlite、fmdb的优缺点不是我要讨论的重点</p>\n<p>这个系列的blog主要会研究讨论以下几点<br>    1.快速搭建coredata环境，主要是连接数据库、创建数据库托管对象模型（NSManagerObject）、如何保存数据、查询数据？<br>    2.coredata升级以及数据迁移的三种方式。<br>    3.coredata与viewcontroller的结合，通过NSFetchedResultController使用coredata数据。<br>    4.导入默认数据和前后台context。<br>    5.关系</p>\n<p><a href=\"#1\">2 环境搭建</a></p>\n<p><a href=\"#2\">2.1 导入《CoreData》的framework</a><br>默认读者知道如何创建一个空白的项目，建立好空白项目之后，搜索coredata按图2-1操作，点击添加完成framework的引入。<br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151030175726289.jpg\" alt=\"图 2-1\"></p>\n<p><a href=\"#2\">2.2 创建Model</a><br>完成上述第一步，意味着我们已经可以使用CoreData提供的接口API了，接下来就是如何使用的事儿了。创建一个CoreData文件夹，专门用来放CoreData引擎，创建好文件夹后，右键点击选择newfile，然后按照图2-2所示创建数据库模型文件，并将其命名为Model,然后点击Model,添加Entity（表\\Class）,添加Attribute（字段\\属性），到这一部，基本上就把Model，创建出来了。并且里面有了数据模型结构，接下来的问题就是，连接数据库，根据模型创建托管对象了<br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151030180051371.jpg\" alt=\"图 2-2\"></p>\n<p><a href=\"#2\">2.3 代码连接数据库</a><br>好啦，前面只是开胃菜，真正的大餐马上就要来了，在吃大餐前，有一些名称需要说明下</p>\n<p>1.NSManagedObjectContext - 托管对象上下文，用来干嘛的呢？望文生意，用来管理托管对象的，负责从数据库中获取对象、保存对象、删除对象等等操作。<br>2.NSManagedObjectModel - 对象模型， 根据我们上面创建的数据模型，创建出托管对象模型，（类似于加工厂的概念，能够用来生产对象的模子）<br>3.NSPersistentStoreCoordinator - 持久化存储协调器，包含数据库的名称、存储数据类型（Sqlite、Xml、内存）、位置等信息<br>4.NSPersistentStore - 持久化存储区</p>\n<p>另外再附一张图来说明这几者的依赖关系<br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151030232125923.png\" alt=\"\"></p>\n<p>由于CoreData管理数据的过程较为通用，个人觉的还是封装成一个管理对象较好，方便以后代码复用，这里创建一个CoreDataHelper的类，专门用来管理数据对象，该类的头文件如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span>  </span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CoreData/CoreData.h&gt;</span>  </span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CoreDataHelper</span> : <span class=\"title\">NSObject</span>  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSManagedObjectContext</span>       *context;<span class=\"comment\">//托管对象上下文  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSManagedObjectModel</span>         *model;<span class=\"comment\">//托管对象模型  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSPersistentStoreCoordinator</span> *coordinate;<span class=\"comment\">//持久化存储协调器  </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSPersistentStore</span>            *store;<span class=\"comment\">//持久化存储区  </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init;             <span class=\"comment\">//初始化  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)loadStore;      <span class=\"comment\">//加载cordite  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupCoreData;  <span class=\"comment\">//设置cordite相关信息  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)saveContext;    <span class=\"comment\">//保存context</span></div></pre></td></tr></table></figure>\n<p>CoreDataHelp的实现文件如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CoreDataHelper.h\"</span>  </span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *storeFileName = <span class=\"string\">@\"demo.sqlite\"</span>;    <span class=\"comment\">//测试数据库  </span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CoreDataHelper</span>  </span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#pragma mark - PATHS  </span></div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)applicationDocumentDirectory  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *paths = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>);  </div><div class=\"line\">    <span class=\"keyword\">return</span> [paths lastObject];  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"built_in\">NSURL</span> *)applicationStoreDirectory  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [[<span class=\"built_in\">NSURL</span> fileURLWithPath:[<span class=\"keyword\">self</span> applicationDocumentDirectory]] URLByAppendingPathComponent:<span class=\"string\">@\"stores\"</span>];  </div><div class=\"line\">    <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager]fileExistsAtPath:[url path]]) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> success   = [[<span class=\"built_in\">NSFileManager</span> defaultManager]createDirectoryAtURL:url  </div><div class=\"line\">                                               withIntermediateDirectories:<span class=\"literal\">YES</span>  </div><div class=\"line\">                                                                attributes:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                                     error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"success create directory!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed create directory!\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> url;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"built_in\">NSURL</span> *)storeUrl  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *storeUrl = [[<span class=\"keyword\">self</span> applicationStoreDirectory]URLByAppendingPathComponent:storeFileName];  </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"storeurl = %@\"</span>,storeUrl);  </div><div class=\"line\">    <span class=\"keyword\">return</span> storeUrl;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#pragma mark - SETUP  </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;  </div><div class=\"line\">        _model      = [<span class=\"built_in\">NSManagedObjectModel</span> mergedModelFromBundles:<span class=\"literal\">nil</span>];  </div><div class=\"line\">        _coordinate = [[<span class=\"built_in\">NSPersistentStoreCoordinator</span> alloc]initWithManagedObjectModel:_model];  </div><div class=\"line\">        _context    = [[<span class=\"built_in\">NSManagedObjectContext</span> alloc]initWithConcurrencyType:<span class=\"built_in\">NSMainQueueConcurrencyType</span>];  </div><div class=\"line\">        [_context setMergePolicy:<span class=\"built_in\">NSMergeByPropertyObjectTrumpMergePolicy</span>];  </div><div class=\"line\">        [_context setPersistentStoreCoordinator:_coordinate];  </div><div class=\"line\">          </div><div class=\"line\">        _importContext = [[<span class=\"built_in\">NSManagedObjectContext</span> alloc]initWithConcurrencyType:<span class=\"built_in\">NSPrivateQueueConcurrencyType</span>];  </div><div class=\"line\">          </div><div class=\"line\">        [_importContext performBlock:^&#123;  </div><div class=\"line\">            [_importContext setPersistentStoreCoordinator:_coordinate];  </div><div class=\"line\">            [_importContext setMergePolicy:<span class=\"built_in\">NSMergeByPropertyObjectTrumpMergePolicy</span>];  </div><div class=\"line\">            [_importContext setUndoManager:<span class=\"literal\">nil</span>];  </div><div class=\"line\">        &#125;];  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)loadStore  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ ,'%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">if</span> (_store) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  </span></div><div class=\"line\">        <span class=\"comment\">//NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  </span></div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *option = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSSQLitePragmasOption</span>:@&#123;<span class=\"string\">@\"journal_mode\"</span>:<span class=\"string\">@\"DELETE\"</span>&#125;&#125;;  </div><div class=\"line\">          </div><div class=\"line\">        _store = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                           configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                     URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                                 options:option  </div><div class=\"line\">                                                   error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (!_store) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed load store,error = %@\"</span>,error);  </div><div class=\"line\">                abort();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">/**/</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"successfully add store : %@\"</span>,_store);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)setupCoreData  </div><div class=\"line\">&#123;  </div><div class=\"line\">    [<span class=\"keyword\">self</span> loadStore];  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\">- (<span class=\"keyword\">void</span>)saveContext  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ([_context hasChanges]) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">        <span class=\"keyword\">if</span> ([_context save:&amp;error]) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"context save successfully\"</span>);  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed save %@\"</span>,error);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"skipped context save , there is no changes\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><a href=\"#2\">2.4 最后附上查询和保存数据库的代码</a><br>在AppDelegate.m文件里写一个方法，用来初始化CoreData数据库</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (CoreDataHelper *)cdh  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (!_cdh) &#123;  </div><div class=\"line\">        <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;  </div><div class=\"line\">        <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;  </div><div class=\"line\">            _cdh = [CoreDataHelper new];  </div><div class=\"line\">              </div><div class=\"line\">        &#125;);  </div><div class=\"line\">        [_cdh setupCoreData];  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> _cdh;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面是插入数据，查询、保存数据的方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)demo  </div><div class=\"line\">&#123;  </div><div class=\"line\">    Item *bananer = [<span class=\"built_in\">NSEntityDescription</span> insertNewObjectForEntityForName:<span class=\"string\">@\"Item\"</span> inManagedObjectContext:[[<span class=\"keyword\">self</span> cdh] context]];  </div><div class=\"line\">    bananer.unit = kg;  </div><div class=\"line\">    bananer.name = <span class=\"string\">@\"bananer\"</span>;  </div><div class=\"line\">      </div><div class=\"line\">    Item *oranger = [<span class=\"built_in\">NSEntityDescription</span> insertNewObjectForEntityForName:<span class=\"string\">@\"Item\"</span> inManagedObjectContext:[[<span class=\"keyword\">self</span> cdh] context]];  </div><div class=\"line\">    oranger.unit = kg;  </div><div class=\"line\">    oranger.name = <span class=\"string\">@\"Oranger\"</span>;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSFetchRequest</span> *request = [<span class=\"built_in\">NSFetchRequest</span> fetchRequestWithEntityName:<span class=\"string\">@\"Item\"</span>];  </div><div class=\"line\">    <span class=\"built_in\">NSArray</span> *result = [[[<span class=\"keyword\">self</span> cdh]context] executeFetchRequest:request error:<span class=\"literal\">nil</span>];  </div><div class=\"line\">    <span class=\"keyword\">for</span> (Item *item <span class=\"keyword\">in</span> result) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"item.name = %@\"</span>,item.name);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    [[<span class=\"keyword\">self</span> cdh]saveContext];  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"#2\">2.5 小结</a><br>经过这么一番下来，终于将CoreData技术应用到我们的项目中了，我们现在能做到，把数据插入到数据库、也能从数据库中读取出数据来，也能保存数据。但是要注意这才是刚刚开始，接下来还有更多的coredata问题等着我们，比方说下节要介绍的数据迁移问题。</p>"},{"title":"点点滴滴：HTTPS和HTTP的区别","date":"2016-08-27T13:17:04.000Z","_content":"\n从iOS9开始，苹果官方开始要求，上线的APP需要对HTTPs协议进行支持，虽然我们可以通过在项目的plist文件中设置属性的方式，暂时绕开这条限制， 但是我个人认为还是有必要了解下，苹果为什么要这么做？\n<!--more-->\n先简单科普下HTTP与HTTPS分别代表什么，以及它们的区别到底是什么？\n### [HTPPS和HTTP的概念](#1)\n\nHTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\n超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。\n\n### [HTTPS和HTTP的区别：](#1)\n\n1.HTTPS议需要到CA申请证书，一般免费证书很少，需要交费。HTTP是超文本传输协议，不需要证书\n2.端口号不同，HTTPS端口号是443，HTTP端口号是80\n3.HTTPS要进行多次的身份验证，6/7的握手以达到数据安全，性能消耗较大，也即通信之前需要先确认身份，只有身份确认才会发送信息。\n\n看完上面HTTPS和HTTP的不同之后，我们不难发现其实二者最根本的区别就是在HTTPS比HTTP多使用的SSL层，那SSL层又是什么东东呢？且看下面这张图\n![](http://ock9zbzms.bkt.clouddn.com/643.png)\n公式：HTTP+SSL/TLS+TCP = HTTPS\n\n[那么SSL、TLS又是什么鬼呢？](#2)\n简单的立即SSL就是对传输的内容通过某种算法进行加密的一种协议，那TLS又是什么呢？TLS实际上是SSL的升级版，看下下面的换算公式：\nSSL 2.0\nSSL 3.0\nTLS 1.0 (SSL 3.1)\nTLS 1.1 (SSL 3.1)\nTLS 1.2 (SSL 3.1)\n\n目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。\n\n那么身为移动端开发工程师，面对如此大势所趋，我们能做什么呢？\n方法一：要求公司的服务端进行升级，至少支持到苹果要求的TLS1.2\n方法二：在info.plist中进行配置，使APP能够访问不支持HTTPS的服务器。\n如果让你的APP能够访问任意的Host地址那么可以这样配置（这是最省事也是最不安全的）\n\n```mm\nNSAppTransportSecurity    \n    NSAllowsArbitraryLoads\n\n```","source":"_posts/点点滴滴：HTTPS和HTTP的区别.md","raw":"---\ntitle: 点点滴滴：HTTPS和HTTP的区别\ndate: 2016-08-27 21:17:04\ntags: 点点滴滴\n---\n\n从iOS9开始，苹果官方开始要求，上线的APP需要对HTTPs协议进行支持，虽然我们可以通过在项目的plist文件中设置属性的方式，暂时绕开这条限制， 但是我个人认为还是有必要了解下，苹果为什么要这么做？\n<!--more-->\n先简单科普下HTTP与HTTPS分别代表什么，以及它们的区别到底是什么？\n### [HTPPS和HTTP的概念](#1)\n\nHTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\n超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。\n\n### [HTTPS和HTTP的区别：](#1)\n\n1.HTTPS议需要到CA申请证书，一般免费证书很少，需要交费。HTTP是超文本传输协议，不需要证书\n2.端口号不同，HTTPS端口号是443，HTTP端口号是80\n3.HTTPS要进行多次的身份验证，6/7的握手以达到数据安全，性能消耗较大，也即通信之前需要先确认身份，只有身份确认才会发送信息。\n\n看完上面HTTPS和HTTP的不同之后，我们不难发现其实二者最根本的区别就是在HTTPS比HTTP多使用的SSL层，那SSL层又是什么东东呢？且看下面这张图\n![](http://ock9zbzms.bkt.clouddn.com/643.png)\n公式：HTTP+SSL/TLS+TCP = HTTPS\n\n[那么SSL、TLS又是什么鬼呢？](#2)\n简单的立即SSL就是对传输的内容通过某种算法进行加密的一种协议，那TLS又是什么呢？TLS实际上是SSL的升级版，看下下面的换算公式：\nSSL 2.0\nSSL 3.0\nTLS 1.0 (SSL 3.1)\nTLS 1.1 (SSL 3.1)\nTLS 1.2 (SSL 3.1)\n\n目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。\n\n那么身为移动端开发工程师，面对如此大势所趋，我们能做什么呢？\n方法一：要求公司的服务端进行升级，至少支持到苹果要求的TLS1.2\n方法二：在info.plist中进行配置，使APP能够访问不支持HTTPS的服务器。\n如果让你的APP能够访问任意的Host地址那么可以这样配置（这是最省事也是最不安全的）\n\n```mm\nNSAppTransportSecurity    \n    NSAllowsArbitraryLoads\n\n```","slug":"点点滴滴：HTTPS和HTTP的区别","published":1,"updated":"2016-12-29T03:48:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtfp0001492w0cmotz39","content":"<p>从iOS9开始，苹果官方开始要求，上线的APP需要对HTTPs协议进行支持，虽然我们可以通过在项目的plist文件中设置属性的方式，暂时绕开这条限制， 但是我个人认为还是有必要了解下，苹果为什么要这么做？<br><a id=\"more\"></a><br>先简单科普下HTTP与HTTPS分别代表什么，以及它们的区别到底是什么？</p>\n<h3 id=\"HTPPS和HTTP的概念\"><a href=\"#HTPPS和HTTP的概念\" class=\"headerlink\" title=\"HTPPS和HTTP的概念\"></a><a href=\"#1\">HTPPS和HTTP的概念</a></h3><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>\n<p>超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>\n<h3 id=\"HTTPS和HTTP的区别：\"><a href=\"#HTTPS和HTTP的区别：\" class=\"headerlink\" title=\"HTTPS和HTTP的区别：\"></a><a href=\"#1\">HTTPS和HTTP的区别：</a></h3><p>1.HTTPS议需要到CA申请证书，一般免费证书很少，需要交费。HTTP是超文本传输协议，不需要证书<br>2.端口号不同，HTTPS端口号是443，HTTP端口号是80<br>3.HTTPS要进行多次的身份验证，6/7的握手以达到数据安全，性能消耗较大，也即通信之前需要先确认身份，只有身份确认才会发送信息。</p>\n<p>看完上面HTTPS和HTTP的不同之后，我们不难发现其实二者最根本的区别就是在HTTPS比HTTP多使用的SSL层，那SSL层又是什么东东呢？且看下面这张图<br><img src=\"http://ock9zbzms.bkt.clouddn.com/643.png\" alt=\"\"><br>公式：HTTP+SSL/TLS+TCP = HTTPS</p>\n<p><a href=\"#2\">那么SSL、TLS又是什么鬼呢？</a><br>简单的立即SSL就是对传输的内容通过某种算法进行加密的一种协议，那TLS又是什么呢？TLS实际上是SSL的升级版，看下下面的换算公式：<br>SSL 2.0<br>SSL 3.0<br>TLS 1.0 (SSL 3.1)<br>TLS 1.1 (SSL 3.1)<br>TLS 1.2 (SSL 3.1)</p>\n<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p>\n<p>那么身为移动端开发工程师，面对如此大势所趋，我们能做什么呢？<br>方法一：要求公司的服务端进行升级，至少支持到苹果要求的TLS1.2<br>方法二：在info.plist中进行配置，使APP能够访问不支持HTTPS的服务器。<br>如果让你的APP能够访问任意的Host地址那么可以这样配置（这是最省事也是最不安全的）</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSAppTransportSecurity</span>    </div><div class=\"line\">    <span class=\"built_in\">NSAllowsArbitraryLoads</span></div></pre></td></tr></table></figure>","excerpt":"<p>从iOS9开始，苹果官方开始要求，上线的APP需要对HTTPs协议进行支持，虽然我们可以通过在项目的plist文件中设置属性的方式，暂时绕开这条限制， 但是我个人认为还是有必要了解下，苹果为什么要这么做？<br>","more":"<br>先简单科普下HTTP与HTTPS分别代表什么，以及它们的区别到底是什么？</p>\n<h3 id=\"HTPPS和HTTP的概念\"><a href=\"#HTPPS和HTTP的概念\" class=\"headerlink\" title=\"HTPPS和HTTP的概念\"></a><a href=\"#1\">HTPPS和HTTP的概念</a></h3><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>\n<p>超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>\n<h3 id=\"HTTPS和HTTP的区别：\"><a href=\"#HTTPS和HTTP的区别：\" class=\"headerlink\" title=\"HTTPS和HTTP的区别：\"></a><a href=\"#1\">HTTPS和HTTP的区别：</a></h3><p>1.HTTPS议需要到CA申请证书，一般免费证书很少，需要交费。HTTP是超文本传输协议，不需要证书<br>2.端口号不同，HTTPS端口号是443，HTTP端口号是80<br>3.HTTPS要进行多次的身份验证，6/7的握手以达到数据安全，性能消耗较大，也即通信之前需要先确认身份，只有身份确认才会发送信息。</p>\n<p>看完上面HTTPS和HTTP的不同之后，我们不难发现其实二者最根本的区别就是在HTTPS比HTTP多使用的SSL层，那SSL层又是什么东东呢？且看下面这张图<br><img src=\"http://ock9zbzms.bkt.clouddn.com/643.png\" alt=\"\"><br>公式：HTTP+SSL/TLS+TCP = HTTPS</p>\n<p><a href=\"#2\">那么SSL、TLS又是什么鬼呢？</a><br>简单的立即SSL就是对传输的内容通过某种算法进行加密的一种协议，那TLS又是什么呢？TLS实际上是SSL的升级版，看下下面的换算公式：<br>SSL 2.0<br>SSL 3.0<br>TLS 1.0 (SSL 3.1)<br>TLS 1.1 (SSL 3.1)<br>TLS 1.2 (SSL 3.1)</p>\n<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p>\n<p>那么身为移动端开发工程师，面对如此大势所趋，我们能做什么呢？<br>方法一：要求公司的服务端进行升级，至少支持到苹果要求的TLS1.2<br>方法二：在info.plist中进行配置，使APP能够访问不支持HTTPS的服务器。<br>如果让你的APP能够访问任意的Host地址那么可以这样配置（这是最省事也是最不安全的）</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSAppTransportSecurity</span>    </div><div class=\"line\">    <span class=\"built_in\">NSAllowsArbitraryLoads</span></div></pre></td></tr></table></figure>"},{"title":"点点滴滴：NSLog一点说道","date":"2016-08-27T13:03:09.000Z","_content":"\n今天的小结主要讲述在IOS开发中实现自定义的NSLog方法\n<!--more-->\n#### [1 为什么要对NSLog进行重定义？](#1)\n\n在开始这个知识点的讲解之前，首先说下，为什么要对NSLog宏进行重定义。在项目开发中，经常需要对程序进行调试。由于调试分布在项目的各种地方，当项目发布时，如果再将调试信息去掉，显示会消耗很大的人力，物力。幸好，强大的xcode给我们提供了一个非常方便的功能。在项目的Build Settings中给Apple LLVM Preprocessing中的 preprocessor macros下面的Debug添加一个调试宏DEBUG=1,记住在Release下面不要添加任何东西！添加这个东西的意思就是告诉编译器，在调试阶段，项目中进行了一个DEBUG的宏定义，但是Release阶段不定义。\n\n#### [2 如何对NSLog宏进行定义了](#1)\n\n```objc\n   #ifdef DEBUG\n   #define NSLog(args...)  ExtendNSLog(__FILE__,__LINE__,__PRETTY_FUNCTION__,args);\n   #else\n   #define NSLog(x...)\n   #endif\n```\n\n下面来对上述宏进行解释，如果定义了DEBUG宏，那么就对NSLog(args...)进行重定义，如果没有定义，将NSLog(args...)设置为空，不做任何处理，\n\n#### [3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释](#1)\n\n```objc\n void ExtendNSLog(const char *file, int lineNumber, const char *functionName, NSString *format, ...)\n{\n    // Type to hold information about variable arguments.\n    va_list ap;\n    // Initialize a variable argument list.\n    va_start (ap, format);\n    // NSLog only adds a newline to the end of the NSLog format if\n    // one is not already there.\n    // Here we are utilizing this feature of NSLog()\n    if (![format hasSuffix: @\"\\n\"])\n    {\n        format = [format stringByAppendingString: @\"\\n\\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯\\n\\n\"];\n    }\n    NSString *body = [[NSString alloc] initWithFormat:format arguments:ap];\n    // End using variable argument list.\n    va_end (ap);\n    NSString *fileName = [[NSString stringWithUTF8String:file] lastPathComponent];\n    fprintf(stderr, \"[%s LINE:%d]%s:\\n%s\",\n            [fileName UTF8String],lineNumber,\n            (functionName[0])=='-'?(&functionName[1]):functionName,\n            [body UTF8String]);\n }\n```\n\n下面来对上述代码进行解释\n1.获取参数列表类\n2.启动参数列表类和格式化字符串的关联\n3.获取格式化字符串的实际输出文本\n4.关闭参数列表类和格式化字符串的关联\n5.调用C函数fprintf(),将打印信息输出。","source":"_posts/点点滴滴：NSLog一点说道.md","raw":"---\ntitle: 点点滴滴：NSLog一点说道\ndate: 2016-08-27 21:03:09\ntags: 点点滴滴\n---\n\n今天的小结主要讲述在IOS开发中实现自定义的NSLog方法\n<!--more-->\n#### [1 为什么要对NSLog进行重定义？](#1)\n\n在开始这个知识点的讲解之前，首先说下，为什么要对NSLog宏进行重定义。在项目开发中，经常需要对程序进行调试。由于调试分布在项目的各种地方，当项目发布时，如果再将调试信息去掉，显示会消耗很大的人力，物力。幸好，强大的xcode给我们提供了一个非常方便的功能。在项目的Build Settings中给Apple LLVM Preprocessing中的 preprocessor macros下面的Debug添加一个调试宏DEBUG=1,记住在Release下面不要添加任何东西！添加这个东西的意思就是告诉编译器，在调试阶段，项目中进行了一个DEBUG的宏定义，但是Release阶段不定义。\n\n#### [2 如何对NSLog宏进行定义了](#1)\n\n```objc\n   #ifdef DEBUG\n   #define NSLog(args...)  ExtendNSLog(__FILE__,__LINE__,__PRETTY_FUNCTION__,args);\n   #else\n   #define NSLog(x...)\n   #endif\n```\n\n下面来对上述宏进行解释，如果定义了DEBUG宏，那么就对NSLog(args...)进行重定义，如果没有定义，将NSLog(args...)设置为空，不做任何处理，\n\n#### [3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释](#1)\n\n```objc\n void ExtendNSLog(const char *file, int lineNumber, const char *functionName, NSString *format, ...)\n{\n    // Type to hold information about variable arguments.\n    va_list ap;\n    // Initialize a variable argument list.\n    va_start (ap, format);\n    // NSLog only adds a newline to the end of the NSLog format if\n    // one is not already there.\n    // Here we are utilizing this feature of NSLog()\n    if (![format hasSuffix: @\"\\n\"])\n    {\n        format = [format stringByAppendingString: @\"\\n\\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯\\n\\n\"];\n    }\n    NSString *body = [[NSString alloc] initWithFormat:format arguments:ap];\n    // End using variable argument list.\n    va_end (ap);\n    NSString *fileName = [[NSString stringWithUTF8String:file] lastPathComponent];\n    fprintf(stderr, \"[%s LINE:%d]%s:\\n%s\",\n            [fileName UTF8String],lineNumber,\n            (functionName[0])=='-'?(&functionName[1]):functionName,\n            [body UTF8String]);\n }\n```\n\n下面来对上述代码进行解释\n1.获取参数列表类\n2.启动参数列表类和格式化字符串的关联\n3.获取格式化字符串的实际输出文本\n4.关闭参数列表类和格式化字符串的关联\n5.调用C函数fprintf(),将打印信息输出。","slug":"点点滴滴：NSLog一点说道","published":1,"updated":"2016-12-29T02:18:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtfu0003492wwapnd9ol","content":"<p>今天的小结主要讲述在IOS开发中实现自定义的NSLog方法<br><a id=\"more\"></a></p>\n<h4 id=\"1-为什么要对NSLog进行重定义？\"><a href=\"#1-为什么要对NSLog进行重定义？\" class=\"headerlink\" title=\"1 为什么要对NSLog进行重定义？\"></a><a href=\"#1\">1 为什么要对NSLog进行重定义？</a></h4><p>在开始这个知识点的讲解之前，首先说下，为什么要对NSLog宏进行重定义。在项目开发中，经常需要对程序进行调试。由于调试分布在项目的各种地方，当项目发布时，如果再将调试信息去掉，显示会消耗很大的人力，物力。幸好，强大的xcode给我们提供了一个非常方便的功能。在项目的Build Settings中给Apple LLVM Preprocessing中的 preprocessor macros下面的Debug添加一个调试宏DEBUG=1,记住在Release下面不要添加任何东西！添加这个东西的意思就是告诉编译器，在调试阶段，项目中进行了一个DEBUG的宏定义，但是Release阶段不定义。</p>\n<h4 id=\"2-如何对NSLog宏进行定义了\"><a href=\"#2-如何对NSLog宏进行定义了\" class=\"headerlink\" title=\"2 如何对NSLog宏进行定义了\"></a><a href=\"#1\">2 如何对NSLog宏进行定义了</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#ifdef DEBUG</span></div><div class=\"line\"><span class=\"meta\">#define NSLog(args...)  ExtendNSLog(__FILE__,__LINE__,__PRETTY_FUNCTION__,args);</span></div><div class=\"line\"><span class=\"meta\">#else</span></div><div class=\"line\"><span class=\"meta\">#define NSLog(x...)</span></div><div class=\"line\"><span class=\"meta\">#endif</span></div></pre></td></tr></table></figure>\n<p>下面来对上述宏进行解释，如果定义了DEBUG宏，那么就对NSLog(args…)进行重定义，如果没有定义，将NSLog(args…)设置为空，不做任何处理，</p>\n<h4 id=\"3-如何对定义的信息进行输出，并附带-文件名，打印行数，方法名-接下来对ExtendNSLog-进行解释\"><a href=\"#3-如何对定义的信息进行输出，并附带-文件名，打印行数，方法名-接下来对ExtendNSLog-进行解释\" class=\"headerlink\" title=\"3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释\"></a><a href=\"#1\">3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">void</span> ExtendNSLog(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">int</span> lineNumber, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *functionName, <span class=\"built_in\">NSString</span> *format, ...)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Type to hold information about variable arguments.</span></div><div class=\"line\">    va_list ap;</div><div class=\"line\">    <span class=\"comment\">// Initialize a variable argument list.</span></div><div class=\"line\">    va_start (ap, format);</div><div class=\"line\">    <span class=\"comment\">// NSLog only adds a newline to the end of the NSLog format if</span></div><div class=\"line\">    <span class=\"comment\">// one is not already there.</span></div><div class=\"line\">    <span class=\"comment\">// Here we are utilizing this feature of NSLog()</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (![format hasSuffix: <span class=\"string\">@\"\\n\"</span>])</div><div class=\"line\">    &#123;</div><div class=\"line\">        format = [format stringByAppendingString: <span class=\"string\">@\"\\n\\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯\\n\\n\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *body = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:format arguments:ap];</div><div class=\"line\">    <span class=\"comment\">// End using variable argument list.</span></div><div class=\"line\">    va_end (ap);</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *fileName = [[<span class=\"built_in\">NSString</span> stringWithUTF8String:file] lastPathComponent];</div><div class=\"line\">    fprintf(stderr, <span class=\"string\">\"[%s LINE:%d]%s:\\n%s\"</span>,</div><div class=\"line\">            [fileName UTF8String],lineNumber,</div><div class=\"line\">            (functionName[<span class=\"number\">0</span>])==<span class=\"string\">'-'</span>?(&amp;functionName[<span class=\"number\">1</span>]):functionName,</div><div class=\"line\">            [body UTF8String]);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>下面来对上述代码进行解释<br>1.获取参数列表类<br>2.启动参数列表类和格式化字符串的关联<br>3.获取格式化字符串的实际输出文本<br>4.关闭参数列表类和格式化字符串的关联<br>5.调用C函数fprintf(),将打印信息输出。</p>\n","excerpt":"<p>今天的小结主要讲述在IOS开发中实现自定义的NSLog方法<br>","more":"</p>\n<h4 id=\"1-为什么要对NSLog进行重定义？\"><a href=\"#1-为什么要对NSLog进行重定义？\" class=\"headerlink\" title=\"1 为什么要对NSLog进行重定义？\"></a><a href=\"#1\">1 为什么要对NSLog进行重定义？</a></h4><p>在开始这个知识点的讲解之前，首先说下，为什么要对NSLog宏进行重定义。在项目开发中，经常需要对程序进行调试。由于调试分布在项目的各种地方，当项目发布时，如果再将调试信息去掉，显示会消耗很大的人力，物力。幸好，强大的xcode给我们提供了一个非常方便的功能。在项目的Build Settings中给Apple LLVM Preprocessing中的 preprocessor macros下面的Debug添加一个调试宏DEBUG=1,记住在Release下面不要添加任何东西！添加这个东西的意思就是告诉编译器，在调试阶段，项目中进行了一个DEBUG的宏定义，但是Release阶段不定义。</p>\n<h4 id=\"2-如何对NSLog宏进行定义了\"><a href=\"#2-如何对NSLog宏进行定义了\" class=\"headerlink\" title=\"2 如何对NSLog宏进行定义了\"></a><a href=\"#1\">2 如何对NSLog宏进行定义了</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#ifdef DEBUG</span></div><div class=\"line\"><span class=\"meta\">#define NSLog(args...)  ExtendNSLog(__FILE__,__LINE__,__PRETTY_FUNCTION__,args);</span></div><div class=\"line\"><span class=\"meta\">#else</span></div><div class=\"line\"><span class=\"meta\">#define NSLog(x...)</span></div><div class=\"line\"><span class=\"meta\">#endif</span></div></pre></td></tr></table></figure>\n<p>下面来对上述宏进行解释，如果定义了DEBUG宏，那么就对NSLog(args…)进行重定义，如果没有定义，将NSLog(args…)设置为空，不做任何处理，</p>\n<h4 id=\"3-如何对定义的信息进行输出，并附带-文件名，打印行数，方法名-接下来对ExtendNSLog-进行解释\"><a href=\"#3-如何对定义的信息进行输出，并附带-文件名，打印行数，方法名-接下来对ExtendNSLog-进行解释\" class=\"headerlink\" title=\"3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释\"></a><a href=\"#1\">3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">void</span> ExtendNSLog(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">int</span> lineNumber, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *functionName, <span class=\"built_in\">NSString</span> *format, ...)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Type to hold information about variable arguments.</span></div><div class=\"line\">    va_list ap;</div><div class=\"line\">    <span class=\"comment\">// Initialize a variable argument list.</span></div><div class=\"line\">    va_start (ap, format);</div><div class=\"line\">    <span class=\"comment\">// NSLog only adds a newline to the end of the NSLog format if</span></div><div class=\"line\">    <span class=\"comment\">// one is not already there.</span></div><div class=\"line\">    <span class=\"comment\">// Here we are utilizing this feature of NSLog()</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (![format hasSuffix: <span class=\"string\">@\"\\n\"</span>])</div><div class=\"line\">    &#123;</div><div class=\"line\">        format = [format stringByAppendingString: <span class=\"string\">@\"\\n\\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯\\n\\n\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *body = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:format arguments:ap];</div><div class=\"line\">    <span class=\"comment\">// End using variable argument list.</span></div><div class=\"line\">    va_end (ap);</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *fileName = [[<span class=\"built_in\">NSString</span> stringWithUTF8String:file] lastPathComponent];</div><div class=\"line\">    fprintf(stderr, <span class=\"string\">\"[%s LINE:%d]%s:\\n%s\"</span>,</div><div class=\"line\">            [fileName UTF8String],lineNumber,</div><div class=\"line\">            (functionName[<span class=\"number\">0</span>])==<span class=\"string\">'-'</span>?(&amp;functionName[<span class=\"number\">1</span>]):functionName,</div><div class=\"line\">            [body UTF8String]);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>下面来对上述代码进行解释<br>1.获取参数列表类<br>2.启动参数列表类和格式化字符串的关联<br>3.获取格式化字符串的实际输出文本<br>4.关闭参数列表类和格式化字符串的关联<br>5.调用C函数fprintf(),将打印信息输出。</p>"},{"title":"点点滴滴：一个容易被忽视的数组和字典的方法","date":"2016-08-27T13:11:06.000Z","_content":"\n今天来讨论下平时大家熟悉的数组/字典，但是容易忽略的数组/字典的valueForKeyPath方法\n可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。\n其实这个方法非常的强大，举个例子:\n\n<!--more-->\n\n```objc\nNSArray *array = @[@\"name\", @\"w\", @\"aa\", @\"jimsa\"];\nNSLog(@\"%@\", [array valueForKeyPath:@\"uppercaseString\"]);\n```\n输出\n(\n    NAME,\n    W,\n    AA,\n    JIMSA\n)\n\n相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如\n\n```objc\n[array valueForKeyPath:@\"length\"];\n```\n返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。\n如果你觉得这个方法就这么点功能，那就错了。还是举具体的例子\n对NSNumber数组快速计算数组求和、平均数、最大值、最小值\n\n```mm\nNSArray *array = @[@1, @2, @3, @4, @10];    \nNSNumber *sum = [array valueForKeyPath:@\"@sum.self\"];   \nNSNumber *avg = [array valueForKeyPath:@\"@avg.self\"]; \nNSNumber *max = [array valueForKeyPath:@\"@max.self\"];    \nNSNumber *min = [array valueForKeyPath:@\"@min.self\"];\n```\n或者指定输出类型\n\n```mm\nNSArray *array = @[@\"name\", @\"w\", @\"aa\", @\"jimsa\", @\"aa\"];    \nNSLog(@\"%@\", [array valueForKeyPath:@\"@distinctUnionOfObjects.self\"]);\n```\n打印\n(\nname,\nw,\njimsa,\naa\n)\n\n对NSDictionary数组快速找出相应key对的值\n\n```mm\nNSArray *array = @[@{@\"name\" : @\"cookeee\",@\"code\" : @1},\n                    @{@\"name\": @\"jim\",@\"code\" : @2},\n                    @{@\"name\": @\"jim\",@\"code\" : @1},\n                    @{@\"name\": @\"jbos\",@\"code\" : @1}];\nNSLog(@\"%@\", [array valueForKeyPath:@\"name\"]);\n```\n\n直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷\n(\n    cookeee,\n    jim,\n    jim,\n    jbos\n)\n\n同样可以嵌套使用，先剔除name对应值的重复数据再取值\n\n```mm\nNSArray *array = @[@{@\"name\" : @\"cookeee\",@\"code\" : @1},\n                   @{@\"name\": @\"jim\",@\"code\" : @2},\n                   @{@\"name\": @\"jim\",@\"code\" : @1},\n                   @{@\"name\": @\"jbos\",@\"code\" : @1}];   \nNSLog(@\"%@\", [array valueForKeyPath:@\"@distinctUnionOfObjects.name\"]);\n```\n\n打印\n(\ncookeee,\njim,\njbos\n)","source":"_posts/点点滴滴：一个容易被忽视的数组和字典的方法.md","raw":"---\ntitle: 点点滴滴：一个容易被忽视的数组和字典的方法\ndate: 2016-08-27 21:11:06\ntags: 点点滴滴\n---\n\n今天来讨论下平时大家熟悉的数组/字典，但是容易忽略的数组/字典的valueForKeyPath方法\n可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。\n其实这个方法非常的强大，举个例子:\n\n<!--more-->\n\n```objc\nNSArray *array = @[@\"name\", @\"w\", @\"aa\", @\"jimsa\"];\nNSLog(@\"%@\", [array valueForKeyPath:@\"uppercaseString\"]);\n```\n输出\n(\n    NAME,\n    W,\n    AA,\n    JIMSA\n)\n\n相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如\n\n```objc\n[array valueForKeyPath:@\"length\"];\n```\n返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。\n如果你觉得这个方法就这么点功能，那就错了。还是举具体的例子\n对NSNumber数组快速计算数组求和、平均数、最大值、最小值\n\n```mm\nNSArray *array = @[@1, @2, @3, @4, @10];    \nNSNumber *sum = [array valueForKeyPath:@\"@sum.self\"];   \nNSNumber *avg = [array valueForKeyPath:@\"@avg.self\"]; \nNSNumber *max = [array valueForKeyPath:@\"@max.self\"];    \nNSNumber *min = [array valueForKeyPath:@\"@min.self\"];\n```\n或者指定输出类型\n\n```mm\nNSArray *array = @[@\"name\", @\"w\", @\"aa\", @\"jimsa\", @\"aa\"];    \nNSLog(@\"%@\", [array valueForKeyPath:@\"@distinctUnionOfObjects.self\"]);\n```\n打印\n(\nname,\nw,\njimsa,\naa\n)\n\n对NSDictionary数组快速找出相应key对的值\n\n```mm\nNSArray *array = @[@{@\"name\" : @\"cookeee\",@\"code\" : @1},\n                    @{@\"name\": @\"jim\",@\"code\" : @2},\n                    @{@\"name\": @\"jim\",@\"code\" : @1},\n                    @{@\"name\": @\"jbos\",@\"code\" : @1}];\nNSLog(@\"%@\", [array valueForKeyPath:@\"name\"]);\n```\n\n直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷\n(\n    cookeee,\n    jim,\n    jim,\n    jbos\n)\n\n同样可以嵌套使用，先剔除name对应值的重复数据再取值\n\n```mm\nNSArray *array = @[@{@\"name\" : @\"cookeee\",@\"code\" : @1},\n                   @{@\"name\": @\"jim\",@\"code\" : @2},\n                   @{@\"name\": @\"jim\",@\"code\" : @1},\n                   @{@\"name\": @\"jbos\",@\"code\" : @1}];   \nNSLog(@\"%@\", [array valueForKeyPath:@\"@distinctUnionOfObjects.name\"]);\n```\n\n打印\n(\ncookeee,\njim,\njbos\n)","slug":"点点滴滴：一个容易被忽视的数组和字典的方法","published":1,"updated":"2016-12-29T02:18:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtfu0004492wmqg3tyx2","content":"<p>今天来讨论下平时大家熟悉的数组/字典，但是容易忽略的数组/字典的valueForKeyPath方法<br>可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。<br>其实这个方法非常的强大，举个例子:</p>\n<a id=\"more\"></a>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"name\"</span>, <span class=\"string\">@\"w\"</span>, <span class=\"string\">@\"aa\"</span>, <span class=\"string\">@\"jimsa\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"uppercaseString\"</span>]);</div></pre></td></tr></table></figure>\n<p>输出<br>(<br>    NAME,<br>    W,<br>    AA,<br>    JIMSA<br>)</p>\n<p>相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[array valueForKeyPath:<span class=\"string\">@\"length\"</span>];</div></pre></td></tr></table></figure>\n<p>返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。<br>如果你觉得这个方法就这么点功能，那就错了。还是举具体的例子<br>对NSNumber数组快速计算数组求和、平均数、最大值、最小值</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>, @<span class=\"number\">4</span>, @<span class=\"number\">10</span>];    </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *sum = [array valueForKeyPath:<span class=\"string\">@\"@sum.self\"</span>];   </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *avg = [array valueForKeyPath:<span class=\"string\">@\"@avg.self\"</span>]; </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *max = [array valueForKeyPath:<span class=\"string\">@\"@max.self\"</span>];    </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *min = [array valueForKeyPath:<span class=\"string\">@\"@min.self\"</span>];</div></pre></td></tr></table></figure>\n<p>或者指定输出类型</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"name\"</span>, <span class=\"string\">@\"w\"</span>, <span class=\"string\">@\"aa\"</span>, <span class=\"string\">@\"jimsa\"</span>, <span class=\"string\">@\"aa\"</span>];    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"@distinctUnionOfObjects.self\"</span>]);</div></pre></td></tr></table></figure>\n<p>打印<br>(<br>name,<br>w,<br>jimsa,<br>aa<br>)</p>\n<p>对NSDictionary数组快速找出相应key对的值</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@&#123;<span class=\"string\">@\"name\"</span> : <span class=\"string\">@\"cookeee\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                    @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">2</span>&#125;,</div><div class=\"line\">                    @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                    @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jbos\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"name\"</span>]);</div></pre></td></tr></table></figure>\n<p>直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷<br>(<br>    cookeee,<br>    jim,<br>    jim,<br>    jbos<br>)</p>\n<p>同样可以嵌套使用，先剔除name对应值的重复数据再取值</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@&#123;<span class=\"string\">@\"name\"</span> : <span class=\"string\">@\"cookeee\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                   @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">2</span>&#125;,</div><div class=\"line\">                   @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                   @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jbos\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;];   </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"@distinctUnionOfObjects.name\"</span>]);</div></pre></td></tr></table></figure>\n<p>打印<br>(<br>cookeee,<br>jim,<br>jbos<br>)</p>\n","excerpt":"<p>今天来讨论下平时大家熟悉的数组/字典，但是容易忽略的数组/字典的valueForKeyPath方法<br>可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。<br>其实这个方法非常的强大，举个例子:</p>","more":"<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"name\"</span>, <span class=\"string\">@\"w\"</span>, <span class=\"string\">@\"aa\"</span>, <span class=\"string\">@\"jimsa\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"uppercaseString\"</span>]);</div></pre></td></tr></table></figure>\n<p>输出<br>(<br>    NAME,<br>    W,<br>    AA,<br>    JIMSA<br>)</p>\n<p>相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[array valueForKeyPath:<span class=\"string\">@\"length\"</span>];</div></pre></td></tr></table></figure>\n<p>返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。<br>如果你觉得这个方法就这么点功能，那就错了。还是举具体的例子<br>对NSNumber数组快速计算数组求和、平均数、最大值、最小值</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@<span class=\"number\">1</span>, @<span class=\"number\">2</span>, @<span class=\"number\">3</span>, @<span class=\"number\">4</span>, @<span class=\"number\">10</span>];    </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *sum = [array valueForKeyPath:<span class=\"string\">@\"@sum.self\"</span>];   </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *avg = [array valueForKeyPath:<span class=\"string\">@\"@avg.self\"</span>]; </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *max = [array valueForKeyPath:<span class=\"string\">@\"@max.self\"</span>];    </div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *min = [array valueForKeyPath:<span class=\"string\">@\"@min.self\"</span>];</div></pre></td></tr></table></figure>\n<p>或者指定输出类型</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[<span class=\"string\">@\"name\"</span>, <span class=\"string\">@\"w\"</span>, <span class=\"string\">@\"aa\"</span>, <span class=\"string\">@\"jimsa\"</span>, <span class=\"string\">@\"aa\"</span>];    </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"@distinctUnionOfObjects.self\"</span>]);</div></pre></td></tr></table></figure>\n<p>打印<br>(<br>name,<br>w,<br>jimsa,<br>aa<br>)</p>\n<p>对NSDictionary数组快速找出相应key对的值</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@&#123;<span class=\"string\">@\"name\"</span> : <span class=\"string\">@\"cookeee\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                    @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">2</span>&#125;,</div><div class=\"line\">                    @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                    @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jbos\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;];</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"name\"</span>]);</div></pre></td></tr></table></figure>\n<p>直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷<br>(<br>    cookeee,<br>    jim,<br>    jim,<br>    jbos<br>)</p>\n<p>同样可以嵌套使用，先剔除name对应值的重复数据再取值</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *array = @[@&#123;<span class=\"string\">@\"name\"</span> : <span class=\"string\">@\"cookeee\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                   @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">2</span>&#125;,</div><div class=\"line\">                   @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jim\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;,</div><div class=\"line\">                   @&#123;<span class=\"string\">@\"name\"</span>: <span class=\"string\">@\"jbos\"</span>,<span class=\"string\">@\"code\"</span> : @<span class=\"number\">1</span>&#125;];   </div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [array valueForKeyPath:<span class=\"string\">@\"@distinctUnionOfObjects.name\"</span>]);</div></pre></td></tr></table></figure>\n<p>打印<br>(<br>cookeee,<br>jim,<br>jbos<br>)</p>"},{"title":"如何使用subline-text2-作为markdown的编辑工具","date":"2016-12-29T03:37:48.000Z","_content":"\n>今年8月份的时候，在[二代](http://kaisayoung.github.io)的带领下，接触了Hexo+Github搭建\n>个人的博客空间的新姿势，在此基础上。我个人选择了sublinetext2 作为markdown的编辑工具，实测还可以，采用subline能够做到\n>\n+ *在线预览*  (通过安装[OmniMarkupPreviewer](https://github.com/timonwong/OmniMarkupPreviewer)实现)\n+ *语法高亮*  (通过安装[MarkdownEditing](https://github.com/SublimeText-Markdown/MarkdownEditing)实现)\n<!--more-->\n单纯的subline虽然也可以打开markdown文件，也可以编辑，但是效果和体验总是不太好，我今天介绍的这俩个插件能够大大提高书写效率和提升书写体验。先附俩张图体验一下最终的效果。\n\n![在线预览](http://ock9zbzms.bkt.clouddn.com/1D8AC7FE-531C-4E47-B744-F1DBDBA8C307.png)\n![图片高亮](http://ock9zbzms.bkt.clouddn.com/subline_online_view1B9EB750-1049-409B-BEBA-385DA4594819.png)\n基本可以实现，在写的过程中就可以看到最终显示在网页上是什么效果。不用等写完之后再去调整展示的界面，还是挺方便的。\n\n这里有几个点需要注意一下。\n\n1. 将OmniMarkupPreviewer，MarkdownEditing从github上clone到subline的packages下需要重启下subline。\n2. 如果是代码的话，高亮需要使\\```将代码包起来  ，形如\\```objc 这里添写需要写的代码\\```\n3. 在线预览功能，可以通过在subline右键点击preview markdown on browser，也可以通过快捷键command + Alt + O 在线预览。\n---\n好久没有写东西了，写了这么点东西居然写了改，改了写，以后还是要常写常更，争取回到每周一更的正确轨道上来。\n","source":"_posts/如何使用subline-text2-作为markdown的编辑工具.md","raw":"---\ntitle: 如何使用subline-text2-作为markdown的编辑工具\ndate: 2016-12-29 11:37:48\ntags: 点点滴滴\n---\n\n>今年8月份的时候，在[二代](http://kaisayoung.github.io)的带领下，接触了Hexo+Github搭建\n>个人的博客空间的新姿势，在此基础上。我个人选择了sublinetext2 作为markdown的编辑工具，实测还可以，采用subline能够做到\n>\n+ *在线预览*  (通过安装[OmniMarkupPreviewer](https://github.com/timonwong/OmniMarkupPreviewer)实现)\n+ *语法高亮*  (通过安装[MarkdownEditing](https://github.com/SublimeText-Markdown/MarkdownEditing)实现)\n<!--more-->\n单纯的subline虽然也可以打开markdown文件，也可以编辑，但是效果和体验总是不太好，我今天介绍的这俩个插件能够大大提高书写效率和提升书写体验。先附俩张图体验一下最终的效果。\n\n![在线预览](http://ock9zbzms.bkt.clouddn.com/1D8AC7FE-531C-4E47-B744-F1DBDBA8C307.png)\n![图片高亮](http://ock9zbzms.bkt.clouddn.com/subline_online_view1B9EB750-1049-409B-BEBA-385DA4594819.png)\n基本可以实现，在写的过程中就可以看到最终显示在网页上是什么效果。不用等写完之后再去调整展示的界面，还是挺方便的。\n\n这里有几个点需要注意一下。\n\n1. 将OmniMarkupPreviewer，MarkdownEditing从github上clone到subline的packages下需要重启下subline。\n2. 如果是代码的话，高亮需要使\\```将代码包起来  ，形如\\```objc 这里添写需要写的代码\\```\n3. 在线预览功能，可以通过在subline右键点击preview markdown on browser，也可以通过快捷键command + Alt + O 在线预览。\n---\n好久没有写东西了，写了这么点东西居然写了改，改了写，以后还是要常写常更，争取回到每周一更的正确轨道上来。\n","slug":"如何使用subline-text2-作为markdown的编辑工具","published":1,"updated":"2016-12-29T03:48:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtfz0006492wr4c1bbyb","content":"<blockquote>\n<p>今年8月份的时候，在<a href=\"http://kaisayoung.github.io\" target=\"_blank\" rel=\"external\">二代</a>的带领下，接触了Hexo+Github搭建<br>个人的博客空间的新姿势，在此基础上。我个人选择了sublinetext2 作为markdown的编辑工具，实测还可以，采用subline能够做到</p>\n<ul>\n<li><em>在线预览</em>  (通过安装<a href=\"https://github.com/timonwong/OmniMarkupPreviewer\" target=\"_blank\" rel=\"external\">OmniMarkupPreviewer</a>实现)</li>\n<li><em>语法高亮</em>  (通过安装<a href=\"https://github.com/SublimeText-Markdown/MarkdownEditing\" target=\"_blank\" rel=\"external\">MarkdownEditing</a>实现)<a id=\"more\"></a>\n单纯的subline虽然也可以打开markdown文件，也可以编辑，但是效果和体验总是不太好，我今天介绍的这俩个插件能够大大提高书写效率和提升书写体验。先附俩张图体验一下最终的效果。</li>\n</ul>\n</blockquote>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/1D8AC7FE-531C-4E47-B744-F1DBDBA8C307.png\" alt=\"在线预览\"><br><img src=\"http://ock9zbzms.bkt.clouddn.com/subline_online_view1B9EB750-1049-409B-BEBA-385DA4594819.png\" alt=\"图片高亮\"><br>基本可以实现，在写的过程中就可以看到最终显示在网页上是什么效果。不用等写完之后再去调整展示的界面，还是挺方便的。</p>\n<p>这里有几个点需要注意一下。</p>\n<ol>\n<li>将OmniMarkupPreviewer，MarkdownEditing从github上clone到subline的packages下需要重启下subline。</li>\n<li>如果是代码的话，高亮需要使```将代码包起来  ，形如```objc 这里添写需要写的代码```</li>\n<li>在线预览功能，可以通过在subline右键点击preview markdown on browser，也可以通过快捷键command + Alt + O 在线预览。</li>\n</ol>\n<hr>\n<p>好久没有写东西了，写了这么点东西居然写了改，改了写，以后还是要常写常更，争取回到每周一更的正确轨道上来。</p>\n","excerpt":"<blockquote>\n<p>今年8月份的时候，在<a href=\"http://kaisayoung.github.io\">二代</a>的带领下，接触了Hexo+Github搭建<br>个人的博客空间的新姿势，在此基础上。我个人选择了sublinetext2 作为markdown的编辑工具，实测还可以，采用subline能够做到</p>\n<ul>\n<li><em>在线预览</em>  (通过安装<a href=\"https://github.com/timonwong/OmniMarkupPreviewer\">OmniMarkupPreviewer</a>实现)</li>\n<li><em>语法高亮</em>  (通过安装<a href=\"https://github.com/SublimeText-Markdown/MarkdownEditing\">MarkdownEditing</a>实现)","more":"单纯的subline虽然也可以打开markdown文件，也可以编辑，但是效果和体验总是不太好，我今天介绍的这俩个插件能够大大提高书写效率和提升书写体验。先附俩张图体验一下最终的效果。</li>\n</ul>\n</blockquote>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/1D8AC7FE-531C-4E47-B744-F1DBDBA8C307.png\" alt=\"在线预览\"><br><img src=\"http://ock9zbzms.bkt.clouddn.com/subline_online_view1B9EB750-1049-409B-BEBA-385DA4594819.png\" alt=\"图片高亮\"><br>基本可以实现，在写的过程中就可以看到最终显示在网页上是什么效果。不用等写完之后再去调整展示的界面，还是挺方便的。</p>\n<p>这里有几个点需要注意一下。</p>\n<ol>\n<li>将OmniMarkupPreviewer，MarkdownEditing从github上clone到subline的packages下需要重启下subline。</li>\n<li>如果是代码的话，高亮需要使```将代码包起来  ，形如```objc 这里添写需要写的代码```</li>\n<li>在线预览功能，可以通过在subline右键点击preview markdown on browser，也可以通过快捷键command + Alt + O 在线预览。</li>\n</ol>\n<hr>\n<p>好久没有写东西了，写了这么点东西居然写了改，改了写，以后还是要常写常更，争取回到每周一更的正确轨道上来。</p>"},{"title":"《CoreData》系列（二）","date":"2016-08-27T11:58:16.000Z","_content":"\nCoreData数据迁移以及版本升级\n\n<!---more--->\n\n[1 概述](#1)\n\n为什么要有数据迁移？\n由于CoreData可视化的特殊性，那么当数据模型发生变化时，相应的sqlite数据库的表由于不知道model发生了变化，表结构必须相应的做出调整，否则会导致程序Crash，CoreData的解决方案是通过创建新的sqlite表，然后将旧的数据迁移到新表上得方案来处理。下面分别介绍三种数据迁移的方式，并详细说明三种迁移方式的应用场景和注意事项。\n\n1.轻量级的数据迁移方式\n2.默认的迁移方式\n3.使用迁移管理器\n\n[1.1 轻量级的数据迁移方式](#2)\n\n轻量级的数据迁移，也就是说，并不需要程序员做很多事情就可以完成数据的迁移，是由系统默认进行的数据迁移。\n那么如何进行轻量级的数据迁移呢，当model的表字段发生变化，且应用程序已经发布过版本时，此时千万不能单单修改原model来达到修改model的目的，如果这样做的话，程序会crash。正确的做法是，\n\n1.新建一个model，并将model命名为model2，并将model2设置为当前model。\n2.修改NSPersistentStoreCoordinator加载缓存区的配置。具体如下\n\n```objc\nNSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                         NSInferMappingModelAutomaticallyOption:@(YES),  \n                         };  \n  \n_store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                   configuration:nil  \n                                             URL:[self storeUrl]  \n                                         options:option  \n                                           error:&error]; \n```\n tips：使用iCloud开发程序的app，只能使用这种迁移方式。\n\n [1.2 默认的迁移方式](#2)\n\n 正常情况下，使用轻量级的数据迁移已经足够了，但是如果由于开发需要，需要将某个Entity下面的某个Attribute迁移到新的Entity下的某个Attribute，那么轻量级的迁移方式就不能够满足需求，这个时候就需要使用默认的迁移方式来进行数据迁移。这里以一个例子代码来详细阐述如何进行默认的迁移\n\n ![](http://ock9zbzms.bkt.clouddn.com/20151106182444884.jpg)\n\n  现在要将Model2里面的Measurement下面的name迁移到Account里面的下面的xyz属性下。\n1.根据model2来创建一个新model，并命名为model3，然后将model3设置为currentmodel。\n2.添加新的entity，并命名为Account，添加attribute xyz。\n3.删除model2里面的Measurement，根据model3创建NSManagerObect的子类Account。\n4.以model2为soureModel，model3为destinationModel添加一个MappingModel\n5.按照下图所示设置映射model即可\n6.最后记得将NSInferMappingModelAutomaticallyOption设置为Yes（coredata会优先读取映射model，如果没有就会自己推断），至此，默认的迁移方式就算是搞定了。\n\n![](http://ock9zbzms.bkt.clouddn.com/20151106183204704.jpg)\n![](http://ock9zbzms.bkt.clouddn.com/20151106183355504.jpg)\n\n[1.3 迁移管理器](#2)\n\n简单概述下何为迁移管理器，迁移管理器，就是不再使用系统的NSPersistentCoordinator进行数据迁移，而是使用NSMigrationManager进行数据缓存区的迁移。并配合一个数据迁移视图控制器提供优雅的迁移等待界面。等待界面如下，是不是感觉很丑呢，哈哈。那么使用迁移管理器的好处又是什么呢？可以实现更加精细化的数据操作，此外还能向用户报告迁移进度。有这俩点，还不够我们去研究下它么?Let's go!\n\n![](http://ock9zbzms.bkt.clouddn.com/coredata20151106184607971.jpg)\n\n准备工作\n\t何时启用迁移管理器，即迁移的时机？\n\t迁移工作如何进行？\n\t迁移完成如何善后？\n\n下面对上面的问题一一来做解答\n迁移的时机，迁移工作需要在载入数据库的时候进行，即上节所讲的 loadStore：的时候进行，但是呢？还需要做一些判断工作。具体代码如下\n\n```objc\n- (void)loadStore  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ ,'%@'\",[self class], NSStringFromSelector(_cmd));  \n    }  \n      \n    if (_store) {  \n        return;  \n    }  \n    \n    BOOL useMigrateManager = MigrationMode;  \n  \n    if (useMigrateManager && [self isMigrationNecessaryForStore:[self storeUrl]]) {  \n        [self performBackgroundManagedMigrationForStore:[self storeUrl]];  \n    }else{  \n        NSError *error;  \n          \n        //NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  \n        //NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  \n        NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                                 NSInferMappingModelAutomaticallyOption:@(YES),  \n                                 NSSQLitePragmasOption:@{@\"journal_mode\":@\"DELETE\"}};  \n          \n        _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                           configuration:nil  \n                                                     URL:[self storeUrl]  \n                                                 options:option  \n                                                   error:&error];  \n        if (!_store) {  \n            if (debug) {  \n                NSLog(@\"failed load store,error = %@\",error);  \n                abort();  \n            }  \n        }  \n        else/**/{  \n            NSLog(@\"successfully add store : %@\",_store);  \n        }  \n    }  \n}  \n```\n\n其中有开关，用来控制是否使用迁移管理器，以及系统是否需要进行迁移的判断。系统是否需要迁移的判断代码如下\n\n```objc\n- (BOOL)isMigrationNecessaryForStore:(NSURL *)storeUrl  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    //文件是否存在，如果不存在认为是用户设备上并没有持久化存储区，自然不需要迁移  \n    if (![[NSFileManager defaultManager]fileExistsAtPath:[self storeUrl].path isDirectory:nil]) {  \n        if (debug) {  \n            NSLog(@\"Skipped Migration, source database missing\");  \n        }  \n        return NO;  \n    }  \n      \n     NSError *error                         = nil;  \n     NSDictionary *sourceMetaData           = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType  \n                                                                                                     URL:storeUrl  \n                                                                                                      error:&error];\n    NSManagedObjectModel *destinationModel = _coordinate.managedObjectModel;  \n      \n    //比较当前对象模型是否与用户之前安装的应用持久化存储区是否兼容。如果兼容，不需要迁移  \n    if ([destinationModel isConfiguration:nil compatibleWithStoreMetadata:sourceMetaData]) {  \n        if (debug) {  \n            NSLog(@\"Skipped Migration, source database is already compatible\");  \n            return NO;  \n        }  \n    }  \n       \n    //所有情况都尝试了，发现还是需要进行数据迁移  \n    return YES;  \n} \n```\n\n迁移工作如何进行，众所周知，迁移工作是一项比较耗时间的工作，尤其是在数据库比较大的情况下，那么肯定不能放在前台进行,必须放在后台进行，前台展示加载进度，代码如下\n\n```objc\n- (void)performBackgroundManagedMigrationForStore:(NSURL *)store  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    UIStoryboard *sb                      = [UIStoryboard storyboardWithName:@\"Main\" bundle:nil];  \n    self.migrationVC                      = [sb instantiateViewControllerWithIdentifier:@\"migration\"];  \n  \n    UIApplication *app                    = [UIApplication sharedApplication];  \n    UINavigationController *navigationCtl = (UINavigationController *)[app keyWindow].rootViewController;  \n      \n    [navigationCtl presentViewController:self.migrationVC  \n                                animated:YES  \n                              completion:nil];  \n      \n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{  \n         \n        BOOL done = [self migrateStore:[self storeUrl]];  \n        if (done) {  \n            dispatch_async(dispatch_get_main_queue(), ^{  \n                NSError *error              = nil;  \n  \n                NSDictionary *configuration = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                                                NSInferMappingModelAutomaticallyOption:@(YES),  \n                                                NSSQLitePragmasOption:@{@\"journal_mode\":@\"DELETE\"}};  \n  \n                _store                      = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                                   configuration:nil  \n                                                             URL:[self storeUrl]  \n                                                         options:configuration  \n                                                           error:&error];  \n                if (_store) {  \n                    if (debug) {  \n                        NSLog(@\"success create store\");  \n                    }  \n                }else {  \n                    if (debug) {  \n                        NSLog(@\"failed, error = %@\",error);  \n                    }  \n                    abort();  \n                }  \n                  \n                [self.migrationVC dismissViewControllerAnimated:YES  \n                                                     completion:nil];  \n                  \n                self.migrationVC = nil;  \n            });  \n        }  \n          \n    });  \n}\n```\n\n接下来是，真正的迁移过程\n```objc\n- (BOOL)migrateStore:(NSURL *)store  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n      \n    NSDictionary *sourceMeta               = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType  \n                                                                                                        URL:store  \n                                                                                                      error:nil];  \n  \n    NSManagedObjectModel *sourceModel      = [NSManagedObjectModel mergedModelFromBundles:nil  \n                                                                         forStoreMetadata:sourceMeta];  \n  \n    NSManagedObjectModel *destinationModel = _model;  \n    NSMappingModel *mappingModel           = [NSMappingModel mappingModelFromBundles:nil  \n                                                                      forSourceModel:sourceModel  \n                                                                    destinationModel:destinationModel];  \n    if (mappingModel) {  \n        NSError *error                       = nil;  \n  \n        NSMigrationManager *migrationManager = [[NSMigrationManager alloc]initWithSourceModel:sourceModel  \n                                                                             destinationModel:destinationModel];  \n  \n        [migrationManager addObserver:self  \n                           forKeyPath:@\"migrationProgress\"  \n                              options:NSKeyValueObservingOptionNew  \n                              context:nil];  \n  \n        NSURL *destinationStore              = [[self applicationStoreDirectory]URLByAppendingPathComponent:@\"temp.sqlite\"];  \n        BOOL success                         = NO;  \n        success                              = [migrationManager migrateStoreFromURL:store  \n                                                    type:NSSQLiteStoreType  \n                                                 options:nil  \n                                        withMappingModel:mappingModel  \n                                        toDestinationURL:destinationStore  \n                                         destinationType:NSSQLiteStoreType  \n                                      destinationOptions:nil  \n                                                   error:&error];  \n        if (success) {  \n            if (debug) {  \n                NSLog(@\"Migration Successfully!\");  \n            }  \n            if ([self replaceStore:store withStore:destinationStore]) {  \n                [migrationManager removeObserver:self forKeyPath:@\"migrationProgress\" context:NULL];  \n                [[NSNotificationCenter defaultCenter]postNotificationName:someThingChangedNotification object:nil];  \n            }  \n        }else{  \n            if (debug) {  \n                NSLog(@\"Migration Failed\");  \n            }  \n        }  \n    }else{  \n        if (debug) {  \n            NSLog(@\"Mapping model is NULL\");  \n        }  \n    }  \n    return YES;  \n}\n```\n最后附上俩个辅助方法，用来观察迁移过程和替换数据库的\n```objc\n- (BOOL)replaceStore:(NSURL *)old withStore:(NSURL *)new  \n{  \n    BOOL success   = NO;  \n    NSError *error = nil;  \n    if ([[NSFileManager defaultManager]removeItemAtURL:old error:&error]) {  \n        error = nil;  \n        if ([[NSFileManager defaultManager]moveItemAtURL:new toURL:old error:&error]) {  \n            success = YES;  \n        }else {  \n            if (debug) {  \n                NSLog(@\"failed move new store to old\");  \n            }  \n        }  \n    }else{  \n        if (debug) {  \n            NSLog(@\"failed remove old store\");  \n        }  \n    }  \n    return success;  \n} \n```\n```objc\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(voidvoid *)context  \n{  \n    if ([keyPath isEqualToString:@\"migrationProgress\"]) {  \n        dispatch_async(dispatch_get_main_queue(), ^{  \n            float progress                         = [[change objectForKey:NSKeyValueChangeNewKey]floatValue];  \n            self.migrationVC.progressView.progress = progress;  \n  \n            int percenttage                        = progress * 100;  \n            NSString *string                       = [NSString stringWithFormat:@\"Migration Progress %i%%\",percenttage];  \n            self.migrationVC.progressLabel.text    = string;  \n        });  \n    }  \n}  \n```\n至此，三种数据迁移的方式，都已叙述完毕。\n[2 小结]（#1）\n三种迁移方式，各有各的好处，轻量级的迁移可以配套icloud实现云端存储，默认的数据迁移，支持将属性级别的数据进行任意迁移。迁移管理器，可以管理文件存储路径，并能够报告迁移进度，我们在开发过程中，应该按照自己的需求合理选择迁移方式，下一小节结合NSFetchedResultController进行数据的实际应用。","source":"_posts/《CoreData》系列（二）.md","raw":"---\ntitle: 《CoreData》系列（二）\ndate: 2016-08-27 19:58:16\ntags: coredata学习\n---\n\nCoreData数据迁移以及版本升级\n\n<!---more--->\n\n[1 概述](#1)\n\n为什么要有数据迁移？\n由于CoreData可视化的特殊性，那么当数据模型发生变化时，相应的sqlite数据库的表由于不知道model发生了变化，表结构必须相应的做出调整，否则会导致程序Crash，CoreData的解决方案是通过创建新的sqlite表，然后将旧的数据迁移到新表上得方案来处理。下面分别介绍三种数据迁移的方式，并详细说明三种迁移方式的应用场景和注意事项。\n\n1.轻量级的数据迁移方式\n2.默认的迁移方式\n3.使用迁移管理器\n\n[1.1 轻量级的数据迁移方式](#2)\n\n轻量级的数据迁移，也就是说，并不需要程序员做很多事情就可以完成数据的迁移，是由系统默认进行的数据迁移。\n那么如何进行轻量级的数据迁移呢，当model的表字段发生变化，且应用程序已经发布过版本时，此时千万不能单单修改原model来达到修改model的目的，如果这样做的话，程序会crash。正确的做法是，\n\n1.新建一个model，并将model命名为model2，并将model2设置为当前model。\n2.修改NSPersistentStoreCoordinator加载缓存区的配置。具体如下\n\n```objc\nNSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                         NSInferMappingModelAutomaticallyOption:@(YES),  \n                         };  \n  \n_store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                   configuration:nil  \n                                             URL:[self storeUrl]  \n                                         options:option  \n                                           error:&error]; \n```\n tips：使用iCloud开发程序的app，只能使用这种迁移方式。\n\n [1.2 默认的迁移方式](#2)\n\n 正常情况下，使用轻量级的数据迁移已经足够了，但是如果由于开发需要，需要将某个Entity下面的某个Attribute迁移到新的Entity下的某个Attribute，那么轻量级的迁移方式就不能够满足需求，这个时候就需要使用默认的迁移方式来进行数据迁移。这里以一个例子代码来详细阐述如何进行默认的迁移\n\n ![](http://ock9zbzms.bkt.clouddn.com/20151106182444884.jpg)\n\n  现在要将Model2里面的Measurement下面的name迁移到Account里面的下面的xyz属性下。\n1.根据model2来创建一个新model，并命名为model3，然后将model3设置为currentmodel。\n2.添加新的entity，并命名为Account，添加attribute xyz。\n3.删除model2里面的Measurement，根据model3创建NSManagerObect的子类Account。\n4.以model2为soureModel，model3为destinationModel添加一个MappingModel\n5.按照下图所示设置映射model即可\n6.最后记得将NSInferMappingModelAutomaticallyOption设置为Yes（coredata会优先读取映射model，如果没有就会自己推断），至此，默认的迁移方式就算是搞定了。\n\n![](http://ock9zbzms.bkt.clouddn.com/20151106183204704.jpg)\n![](http://ock9zbzms.bkt.clouddn.com/20151106183355504.jpg)\n\n[1.3 迁移管理器](#2)\n\n简单概述下何为迁移管理器，迁移管理器，就是不再使用系统的NSPersistentCoordinator进行数据迁移，而是使用NSMigrationManager进行数据缓存区的迁移。并配合一个数据迁移视图控制器提供优雅的迁移等待界面。等待界面如下，是不是感觉很丑呢，哈哈。那么使用迁移管理器的好处又是什么呢？可以实现更加精细化的数据操作，此外还能向用户报告迁移进度。有这俩点，还不够我们去研究下它么?Let's go!\n\n![](http://ock9zbzms.bkt.clouddn.com/coredata20151106184607971.jpg)\n\n准备工作\n\t何时启用迁移管理器，即迁移的时机？\n\t迁移工作如何进行？\n\t迁移完成如何善后？\n\n下面对上面的问题一一来做解答\n迁移的时机，迁移工作需要在载入数据库的时候进行，即上节所讲的 loadStore：的时候进行，但是呢？还需要做一些判断工作。具体代码如下\n\n```objc\n- (void)loadStore  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ ,'%@'\",[self class], NSStringFromSelector(_cmd));  \n    }  \n      \n    if (_store) {  \n        return;  \n    }  \n    \n    BOOL useMigrateManager = MigrationMode;  \n  \n    if (useMigrateManager && [self isMigrationNecessaryForStore:[self storeUrl]]) {  \n        [self performBackgroundManagedMigrationForStore:[self storeUrl]];  \n    }else{  \n        NSError *error;  \n          \n        //NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  \n        //NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  \n        NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                                 NSInferMappingModelAutomaticallyOption:@(YES),  \n                                 NSSQLitePragmasOption:@{@\"journal_mode\":@\"DELETE\"}};  \n          \n        _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                           configuration:nil  \n                                                     URL:[self storeUrl]  \n                                                 options:option  \n                                                   error:&error];  \n        if (!_store) {  \n            if (debug) {  \n                NSLog(@\"failed load store,error = %@\",error);  \n                abort();  \n            }  \n        }  \n        else/**/{  \n            NSLog(@\"successfully add store : %@\",_store);  \n        }  \n    }  \n}  \n```\n\n其中有开关，用来控制是否使用迁移管理器，以及系统是否需要进行迁移的判断。系统是否需要迁移的判断代码如下\n\n```objc\n- (BOOL)isMigrationNecessaryForStore:(NSURL *)storeUrl  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    //文件是否存在，如果不存在认为是用户设备上并没有持久化存储区，自然不需要迁移  \n    if (![[NSFileManager defaultManager]fileExistsAtPath:[self storeUrl].path isDirectory:nil]) {  \n        if (debug) {  \n            NSLog(@\"Skipped Migration, source database missing\");  \n        }  \n        return NO;  \n    }  \n      \n     NSError *error                         = nil;  \n     NSDictionary *sourceMetaData           = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType  \n                                                                                                     URL:storeUrl  \n                                                                                                      error:&error];\n    NSManagedObjectModel *destinationModel = _coordinate.managedObjectModel;  \n      \n    //比较当前对象模型是否与用户之前安装的应用持久化存储区是否兼容。如果兼容，不需要迁移  \n    if ([destinationModel isConfiguration:nil compatibleWithStoreMetadata:sourceMetaData]) {  \n        if (debug) {  \n            NSLog(@\"Skipped Migration, source database is already compatible\");  \n            return NO;  \n        }  \n    }  \n       \n    //所有情况都尝试了，发现还是需要进行数据迁移  \n    return YES;  \n} \n```\n\n迁移工作如何进行，众所周知，迁移工作是一项比较耗时间的工作，尤其是在数据库比较大的情况下，那么肯定不能放在前台进行,必须放在后台进行，前台展示加载进度，代码如下\n\n```objc\n- (void)performBackgroundManagedMigrationForStore:(NSURL *)store  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n    UIStoryboard *sb                      = [UIStoryboard storyboardWithName:@\"Main\" bundle:nil];  \n    self.migrationVC                      = [sb instantiateViewControllerWithIdentifier:@\"migration\"];  \n  \n    UIApplication *app                    = [UIApplication sharedApplication];  \n    UINavigationController *navigationCtl = (UINavigationController *)[app keyWindow].rootViewController;  \n      \n    [navigationCtl presentViewController:self.migrationVC  \n                                animated:YES  \n                              completion:nil];  \n      \n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{  \n         \n        BOOL done = [self migrateStore:[self storeUrl]];  \n        if (done) {  \n            dispatch_async(dispatch_get_main_queue(), ^{  \n                NSError *error              = nil;  \n  \n                NSDictionary *configuration = @{NSMigratePersistentStoresAutomaticallyOption:@(YES),  \n                                                NSInferMappingModelAutomaticallyOption:@(YES),  \n                                                NSSQLitePragmasOption:@{@\"journal_mode\":@\"DELETE\"}};  \n  \n                _store                      = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType  \n                                                   configuration:nil  \n                                                             URL:[self storeUrl]  \n                                                         options:configuration  \n                                                           error:&error];  \n                if (_store) {  \n                    if (debug) {  \n                        NSLog(@\"success create store\");  \n                    }  \n                }else {  \n                    if (debug) {  \n                        NSLog(@\"failed, error = %@\",error);  \n                    }  \n                    abort();  \n                }  \n                  \n                [self.migrationVC dismissViewControllerAnimated:YES  \n                                                     completion:nil];  \n                  \n                self.migrationVC = nil;  \n            });  \n        }  \n          \n    });  \n}\n```\n\n接下来是，真正的迁移过程\n```objc\n- (BOOL)migrateStore:(NSURL *)store  \n{  \n    if (debug) {  \n        NSLog(@\"Running %@ '%@'\",[self class],NSStringFromSelector(_cmd));  \n    }  \n      \n      \n    NSDictionary *sourceMeta               = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType  \n                                                                                                        URL:store  \n                                                                                                      error:nil];  \n  \n    NSManagedObjectModel *sourceModel      = [NSManagedObjectModel mergedModelFromBundles:nil  \n                                                                         forStoreMetadata:sourceMeta];  \n  \n    NSManagedObjectModel *destinationModel = _model;  \n    NSMappingModel *mappingModel           = [NSMappingModel mappingModelFromBundles:nil  \n                                                                      forSourceModel:sourceModel  \n                                                                    destinationModel:destinationModel];  \n    if (mappingModel) {  \n        NSError *error                       = nil;  \n  \n        NSMigrationManager *migrationManager = [[NSMigrationManager alloc]initWithSourceModel:sourceModel  \n                                                                             destinationModel:destinationModel];  \n  \n        [migrationManager addObserver:self  \n                           forKeyPath:@\"migrationProgress\"  \n                              options:NSKeyValueObservingOptionNew  \n                              context:nil];  \n  \n        NSURL *destinationStore              = [[self applicationStoreDirectory]URLByAppendingPathComponent:@\"temp.sqlite\"];  \n        BOOL success                         = NO;  \n        success                              = [migrationManager migrateStoreFromURL:store  \n                                                    type:NSSQLiteStoreType  \n                                                 options:nil  \n                                        withMappingModel:mappingModel  \n                                        toDestinationURL:destinationStore  \n                                         destinationType:NSSQLiteStoreType  \n                                      destinationOptions:nil  \n                                                   error:&error];  \n        if (success) {  \n            if (debug) {  \n                NSLog(@\"Migration Successfully!\");  \n            }  \n            if ([self replaceStore:store withStore:destinationStore]) {  \n                [migrationManager removeObserver:self forKeyPath:@\"migrationProgress\" context:NULL];  \n                [[NSNotificationCenter defaultCenter]postNotificationName:someThingChangedNotification object:nil];  \n            }  \n        }else{  \n            if (debug) {  \n                NSLog(@\"Migration Failed\");  \n            }  \n        }  \n    }else{  \n        if (debug) {  \n            NSLog(@\"Mapping model is NULL\");  \n        }  \n    }  \n    return YES;  \n}\n```\n最后附上俩个辅助方法，用来观察迁移过程和替换数据库的\n```objc\n- (BOOL)replaceStore:(NSURL *)old withStore:(NSURL *)new  \n{  \n    BOOL success   = NO;  \n    NSError *error = nil;  \n    if ([[NSFileManager defaultManager]removeItemAtURL:old error:&error]) {  \n        error = nil;  \n        if ([[NSFileManager defaultManager]moveItemAtURL:new toURL:old error:&error]) {  \n            success = YES;  \n        }else {  \n            if (debug) {  \n                NSLog(@\"failed move new store to old\");  \n            }  \n        }  \n    }else{  \n        if (debug) {  \n            NSLog(@\"failed remove old store\");  \n        }  \n    }  \n    return success;  \n} \n```\n```objc\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(voidvoid *)context  \n{  \n    if ([keyPath isEqualToString:@\"migrationProgress\"]) {  \n        dispatch_async(dispatch_get_main_queue(), ^{  \n            float progress                         = [[change objectForKey:NSKeyValueChangeNewKey]floatValue];  \n            self.migrationVC.progressView.progress = progress;  \n  \n            int percenttage                        = progress * 100;  \n            NSString *string                       = [NSString stringWithFormat:@\"Migration Progress %i%%\",percenttage];  \n            self.migrationVC.progressLabel.text    = string;  \n        });  \n    }  \n}  \n```\n至此，三种数据迁移的方式，都已叙述完毕。\n[2 小结]（#1）\n三种迁移方式，各有各的好处，轻量级的迁移可以配套icloud实现云端存储，默认的数据迁移，支持将属性级别的数据进行任意迁移。迁移管理器，可以管理文件存储路径，并能够报告迁移进度，我们在开发过程中，应该按照自己的需求合理选择迁移方式，下一小节结合NSFetchedResultController进行数据的实际应用。","slug":"《CoreData》系列（二）","published":1,"updated":"2016-12-29T02:18:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtg00008492wevmqsl8m","content":"<p>CoreData数据迁移以及版本升级</p>\n<a id=\"more\"></a>\n<p><a href=\"#1\">1 概述</a></p>\n<p>为什么要有数据迁移？<br>由于CoreData可视化的特殊性，那么当数据模型发生变化时，相应的sqlite数据库的表由于不知道model发生了变化，表结构必须相应的做出调整，否则会导致程序Crash，CoreData的解决方案是通过创建新的sqlite表，然后将旧的数据迁移到新表上得方案来处理。下面分别介绍三种数据迁移的方式，并详细说明三种迁移方式的应用场景和注意事项。</p>\n<p>1.轻量级的数据迁移方式<br>2.默认的迁移方式<br>3.使用迁移管理器</p>\n<p><a href=\"#2\">1.1 轻量级的数据迁移方式</a></p>\n<p>轻量级的数据迁移，也就是说，并不需要程序员做很多事情就可以完成数据的迁移，是由系统默认进行的数据迁移。<br>那么如何进行轻量级的数据迁移呢，当model的表字段发生变化，且应用程序已经发布过版本时，此时千万不能单单修改原model来达到修改model的目的，如果这样做的话，程序会crash。正确的做法是，</p>\n<p>1.新建一个model，并将model命名为model2，并将model2设置为当前model。<br>2.修改NSPersistentStoreCoordinator加载缓存区的配置。具体如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *option = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                         <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                         &#125;;  </div><div class=\"line\">  </div><div class=\"line\">_store = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                   configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                             URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                         options:option  </div><div class=\"line\">                                           error:&amp;error];</div></pre></td></tr></table></figure>\n<p> tips：使用iCloud开发程序的app，只能使用这种迁移方式。</p>\n<p> <a href=\"#2\">1.2 默认的迁移方式</a></p>\n<p> 正常情况下，使用轻量级的数据迁移已经足够了，但是如果由于开发需要，需要将某个Entity下面的某个Attribute迁移到新的Entity下的某个Attribute，那么轻量级的迁移方式就不能够满足需求，这个时候就需要使用默认的迁移方式来进行数据迁移。这里以一个例子代码来详细阐述如何进行默认的迁移</p>\n<p> <img src=\"http://ock9zbzms.bkt.clouddn.com/20151106182444884.jpg\" alt=\"\"></p>\n<p>  现在要将Model2里面的Measurement下面的name迁移到Account里面的下面的xyz属性下。<br>1.根据model2来创建一个新model，并命名为model3，然后将model3设置为currentmodel。<br>2.添加新的entity，并命名为Account，添加attribute xyz。<br>3.删除model2里面的Measurement，根据model3创建NSManagerObect的子类Account。<br>4.以model2为soureModel，model3为destinationModel添加一个MappingModel<br>5.按照下图所示设置映射model即可<br>6.最后记得将NSInferMappingModelAutomaticallyOption设置为Yes（coredata会优先读取映射model，如果没有就会自己推断），至此，默认的迁移方式就算是搞定了。</p>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/20151106183204704.jpg\" alt=\"\"><br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151106183355504.jpg\" alt=\"\"></p>\n<p><a href=\"#2\">1.3 迁移管理器</a></p>\n<p>简单概述下何为迁移管理器，迁移管理器，就是不再使用系统的NSPersistentCoordinator进行数据迁移，而是使用NSMigrationManager进行数据缓存区的迁移。并配合一个数据迁移视图控制器提供优雅的迁移等待界面。等待界面如下，是不是感觉很丑呢，哈哈。那么使用迁移管理器的好处又是什么呢？可以实现更加精细化的数据操作，此外还能向用户报告迁移进度。有这俩点，还不够我们去研究下它么?Let’s go!</p>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/coredata20151106184607971.jpg\" alt=\"\"></p>\n<p>准备工作<br>    何时启用迁移管理器，即迁移的时机？<br>    迁移工作如何进行？<br>    迁移完成如何善后？</p>\n<p>下面对上面的问题一一来做解答<br>迁移的时机，迁移工作需要在载入数据库的时候进行，即上节所讲的 loadStore：的时候进行，但是呢？还需要做一些判断工作。具体代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)loadStore  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ ,'%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">if</span> (_store) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">BOOL</span> useMigrateManager = MigrationMode;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">if</span> (useMigrateManager &amp;&amp; [<span class=\"keyword\">self</span> isMigrationNecessaryForStore:[<span class=\"keyword\">self</span> storeUrl]]) &#123;  </div><div class=\"line\">        [<span class=\"keyword\">self</span> performBackgroundManagedMigrationForStore:[<span class=\"keyword\">self</span> storeUrl]];  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  </span></div><div class=\"line\">        <span class=\"comment\">//NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  </span></div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *option = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSSQLitePragmasOption</span>:@&#123;<span class=\"string\">@\"journal_mode\"</span>:<span class=\"string\">@\"DELETE\"</span>&#125;&#125;;  </div><div class=\"line\">          </div><div class=\"line\">        _store = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                           configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                     URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                                 options:option  </div><div class=\"line\">                                                   error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (!_store) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed load store,error = %@\"</span>,error);  </div><div class=\"line\">                abort();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">/**/</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"successfully add store : %@\"</span>,_store);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中有开关，用来控制是否使用迁移管理器，以及系统是否需要进行迁移的判断。系统是否需要迁移的判断代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isMigrationNecessaryForStore:(<span class=\"built_in\">NSURL</span> *)storeUrl  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">//文件是否存在，如果不存在认为是用户设备上并没有持久化存储区，自然不需要迁移  </span></div><div class=\"line\">    <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager]fileExistsAtPath:[<span class=\"keyword\">self</span> storeUrl].path isDirectory:<span class=\"literal\">nil</span>]) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Skipped Migration, source database missing\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">     <span class=\"built_in\">NSError</span> *error                         = <span class=\"literal\">nil</span>;  </div><div class=\"line\">     <span class=\"built_in\">NSDictionary</span> *sourceMetaData           = [<span class=\"built_in\">NSPersistentStoreCoordinator</span> metadataForPersistentStoreOfType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                                                                     URL:storeUrl  </div><div class=\"line\">                                                                                                      error:&amp;error];</div><div class=\"line\">    <span class=\"built_in\">NSManagedObjectModel</span> *destinationModel = _coordinate.managedObjectModel;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">//比较当前对象模型是否与用户之前安装的应用持久化存储区是否兼容。如果兼容，不需要迁移  </span></div><div class=\"line\">    <span class=\"keyword\">if</span> ([destinationModel isConfiguration:<span class=\"literal\">nil</span> compatibleWithStoreMetadata:sourceMetaData]) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Skipped Migration, source database is already compatible\"</span>);  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">       </div><div class=\"line\">    <span class=\"comment\">//所有情况都尝试了，发现还是需要进行数据迁移  </span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>迁移工作如何进行，众所周知，迁移工作是一项比较耗时间的工作，尤其是在数据库比较大的情况下，那么肯定不能放在前台进行,必须放在后台进行，前台展示加载进度，代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)performBackgroundManagedMigrationForStore:(<span class=\"built_in\">NSURL</span> *)store  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">UIStoryboard</span> *sb                      = [<span class=\"built_in\">UIStoryboard</span> storyboardWithName:<span class=\"string\">@\"Main\"</span> bundle:<span class=\"literal\">nil</span>];  </div><div class=\"line\">    <span class=\"keyword\">self</span>.migrationVC                      = [sb instantiateViewControllerWithIdentifier:<span class=\"string\">@\"migration\"</span>];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">UIApplication</span> *app                    = [<span class=\"built_in\">UIApplication</span> sharedApplication];  </div><div class=\"line\">    <span class=\"built_in\">UINavigationController</span> *navigationCtl = (<span class=\"built_in\">UINavigationController</span> *)[app keyWindow].rootViewController;  </div><div class=\"line\">      </div><div class=\"line\">    [navigationCtl presentViewController:<span class=\"keyword\">self</span>.migrationVC  </div><div class=\"line\">                                animated:<span class=\"literal\">YES</span>  </div><div class=\"line\">                              completion:<span class=\"literal\">nil</span>];  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>), ^&#123;  </div><div class=\"line\">         </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> done = [<span class=\"keyword\">self</span> migrateStore:[<span class=\"keyword\">self</span> storeUrl]];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (done) &#123;  </div><div class=\"line\">            <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">                <span class=\"built_in\">NSError</span> *error              = <span class=\"literal\">nil</span>;  </div><div class=\"line\">  </div><div class=\"line\">                <span class=\"built_in\">NSDictionary</span> *configuration = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                                <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                                <span class=\"built_in\">NSSQLitePragmasOption</span>:@&#123;<span class=\"string\">@\"journal_mode\"</span>:<span class=\"string\">@\"DELETE\"</span>&#125;&#125;;  </div><div class=\"line\">  </div><div class=\"line\">                _store                      = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                   configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                             URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                                         options:configuration  </div><div class=\"line\">                                                           error:&amp;error];  </div><div class=\"line\">                <span class=\"keyword\">if</span> (_store) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"success create store\"</span>);  </div><div class=\"line\">                    &#125;  </div><div class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed, error = %@\"</span>,error);  </div><div class=\"line\">                    &#125;  </div><div class=\"line\">                    abort();  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                  </div><div class=\"line\">                [<span class=\"keyword\">self</span>.migrationVC dismissViewControllerAnimated:<span class=\"literal\">YES</span>  </div><div class=\"line\">                                                     completion:<span class=\"literal\">nil</span>];  </div><div class=\"line\">                  </div><div class=\"line\">                <span class=\"keyword\">self</span>.migrationVC = <span class=\"literal\">nil</span>;  </div><div class=\"line\">            &#125;);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">    &#125;);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来是，真正的迁移过程<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)migrateStore:(<span class=\"built_in\">NSURL</span> *)store  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSDictionary</span> *sourceMeta               = [<span class=\"built_in\">NSPersistentStoreCoordinator</span> metadataForPersistentStoreOfType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                                                                        URL:store  </div><div class=\"line\">                                                                                                      error:<span class=\"literal\">nil</span>];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">NSManagedObjectModel</span> *sourceModel      = [<span class=\"built_in\">NSManagedObjectModel</span> mergedModelFromBundles:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                                         forStoreMetadata:sourceMeta];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">NSManagedObjectModel</span> *destinationModel = _model;  </div><div class=\"line\">    <span class=\"built_in\">NSMappingModel</span> *mappingModel           = [<span class=\"built_in\">NSMappingModel</span> mappingModelFromBundles:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                                      forSourceModel:sourceModel  </div><div class=\"line\">                                                                    destinationModel:destinationModel];  </div><div class=\"line\">    <span class=\"keyword\">if</span> (mappingModel) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error                       = <span class=\"literal\">nil</span>;  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"built_in\">NSMigrationManager</span> *migrationManager = [[<span class=\"built_in\">NSMigrationManager</span> alloc]initWithSourceModel:sourceModel  </div><div class=\"line\">                                                                             destinationModel:destinationModel];  </div><div class=\"line\">  </div><div class=\"line\">        [migrationManager addObserver:<span class=\"keyword\">self</span>  </div><div class=\"line\">                           forKeyPath:<span class=\"string\">@\"migrationProgress\"</span>  </div><div class=\"line\">                              options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span>  </div><div class=\"line\">                              context:<span class=\"literal\">nil</span>];  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"built_in\">NSURL</span> *destinationStore              = [[<span class=\"keyword\">self</span> applicationStoreDirectory]URLByAppendingPathComponent:<span class=\"string\">@\"temp.sqlite\"</span>];  </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> success                         = <span class=\"literal\">NO</span>;  </div><div class=\"line\">        success                              = [migrationManager migrateStoreFromURL:store  </div><div class=\"line\">                                                    type:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                 options:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                        withMappingModel:mappingModel  </div><div class=\"line\">                                        toDestinationURL:destinationStore  </div><div class=\"line\">                                         destinationType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                      destinationOptions:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                   error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Migration Successfully!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> replaceStore:store withStore:destinationStore]) &#123;  </div><div class=\"line\">                [migrationManager removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"migrationProgress\"</span> context:<span class=\"literal\">NULL</span>];  </div><div class=\"line\">                [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]postNotificationName:someThingChangedNotification object:<span class=\"literal\">nil</span>];  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Migration Failed\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Mapping model is NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后附上俩个辅助方法，用来观察迁移过程和替换数据库的<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)replaceStore:(<span class=\"built_in\">NSURL</span> *)old withStore:(<span class=\"built_in\">NSURL</span> *)new  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"built_in\">BOOL</span> success   = <span class=\"literal\">NO</span>;  </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager]removeItemAtURL:old error:&amp;error]) &#123;  </div><div class=\"line\">        error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">        <span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager]moveItemAtURL:new toURL:old error:&amp;error]) &#123;  </div><div class=\"line\">            success = <span class=\"literal\">YES</span>;  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed move new store to old\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed remove old store\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> success;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(voidvoid *)context  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:<span class=\"string\">@\"migrationProgress\"</span>]) &#123;  </div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">            <span class=\"keyword\">float</span> progress                         = [[change objectForKey:<span class=\"built_in\">NSKeyValueChangeNewKey</span>]floatValue];  </div><div class=\"line\">            <span class=\"keyword\">self</span>.migrationVC.progressView.progress = progress;  </div><div class=\"line\">  </div><div class=\"line\">            <span class=\"keyword\">int</span> percenttage                        = progress * <span class=\"number\">100</span>;  </div><div class=\"line\">            <span class=\"built_in\">NSString</span> *string                       = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Migration Progress %i%%\"</span>,percenttage];  </div><div class=\"line\">            <span class=\"keyword\">self</span>.migrationVC.progressLabel.text    = string;  </div><div class=\"line\">        &#125;);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此，三种数据迁移的方式，都已叙述完毕。<br>[2 小结]（#1）<br>三种迁移方式，各有各的好处，轻量级的迁移可以配套icloud实现云端存储，默认的数据迁移，支持将属性级别的数据进行任意迁移。迁移管理器，可以管理文件存储路径，并能够报告迁移进度，我们在开发过程中，应该按照自己的需求合理选择迁移方式，下一小节结合NSFetchedResultController进行数据的实际应用。</p>\n","excerpt":"<p>CoreData数据迁移以及版本升级</p>","more":"<p><a href=\"#1\">1 概述</a></p>\n<p>为什么要有数据迁移？<br>由于CoreData可视化的特殊性，那么当数据模型发生变化时，相应的sqlite数据库的表由于不知道model发生了变化，表结构必须相应的做出调整，否则会导致程序Crash，CoreData的解决方案是通过创建新的sqlite表，然后将旧的数据迁移到新表上得方案来处理。下面分别介绍三种数据迁移的方式，并详细说明三种迁移方式的应用场景和注意事项。</p>\n<p>1.轻量级的数据迁移方式<br>2.默认的迁移方式<br>3.使用迁移管理器</p>\n<p><a href=\"#2\">1.1 轻量级的数据迁移方式</a></p>\n<p>轻量级的数据迁移，也就是说，并不需要程序员做很多事情就可以完成数据的迁移，是由系统默认进行的数据迁移。<br>那么如何进行轻量级的数据迁移呢，当model的表字段发生变化，且应用程序已经发布过版本时，此时千万不能单单修改原model来达到修改model的目的，如果这样做的话，程序会crash。正确的做法是，</p>\n<p>1.新建一个model，并将model命名为model2，并将model2设置为当前model。<br>2.修改NSPersistentStoreCoordinator加载缓存区的配置。具体如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *option = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                         <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                         &#125;;  </div><div class=\"line\">  </div><div class=\"line\">_store = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                   configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                             URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                         options:option  </div><div class=\"line\">                                           error:&amp;error];</div></pre></td></tr></table></figure>\n<p> tips：使用iCloud开发程序的app，只能使用这种迁移方式。</p>\n<p> <a href=\"#2\">1.2 默认的迁移方式</a></p>\n<p> 正常情况下，使用轻量级的数据迁移已经足够了，但是如果由于开发需要，需要将某个Entity下面的某个Attribute迁移到新的Entity下的某个Attribute，那么轻量级的迁移方式就不能够满足需求，这个时候就需要使用默认的迁移方式来进行数据迁移。这里以一个例子代码来详细阐述如何进行默认的迁移</p>\n<p> <img src=\"http://ock9zbzms.bkt.clouddn.com/20151106182444884.jpg\" alt=\"\"></p>\n<p>  现在要将Model2里面的Measurement下面的name迁移到Account里面的下面的xyz属性下。<br>1.根据model2来创建一个新model，并命名为model3，然后将model3设置为currentmodel。<br>2.添加新的entity，并命名为Account，添加attribute xyz。<br>3.删除model2里面的Measurement，根据model3创建NSManagerObect的子类Account。<br>4.以model2为soureModel，model3为destinationModel添加一个MappingModel<br>5.按照下图所示设置映射model即可<br>6.最后记得将NSInferMappingModelAutomaticallyOption设置为Yes（coredata会优先读取映射model，如果没有就会自己推断），至此，默认的迁移方式就算是搞定了。</p>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/20151106183204704.jpg\" alt=\"\"><br><img src=\"http://ock9zbzms.bkt.clouddn.com/20151106183355504.jpg\" alt=\"\"></p>\n<p><a href=\"#2\">1.3 迁移管理器</a></p>\n<p>简单概述下何为迁移管理器，迁移管理器，就是不再使用系统的NSPersistentCoordinator进行数据迁移，而是使用NSMigrationManager进行数据缓存区的迁移。并配合一个数据迁移视图控制器提供优雅的迁移等待界面。等待界面如下，是不是感觉很丑呢，哈哈。那么使用迁移管理器的好处又是什么呢？可以实现更加精细化的数据操作，此外还能向用户报告迁移进度。有这俩点，还不够我们去研究下它么?Let’s go!</p>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/coredata20151106184607971.jpg\" alt=\"\"></p>\n<p>准备工作<br>    何时启用迁移管理器，即迁移的时机？<br>    迁移工作如何进行？<br>    迁移完成如何善后？</p>\n<p>下面对上面的问题一一来做解答<br>迁移的时机，迁移工作需要在载入数据库的时候进行，即上节所讲的 loadStore：的时候进行，但是呢？还需要做一些判断工作。具体代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)loadStore  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ ,'%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">if</span> (_store) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">BOOL</span> useMigrateManager = MigrationMode;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">if</span> (useMigrateManager &amp;&amp; [<span class=\"keyword\">self</span> isMigrationNecessaryForStore:[<span class=\"keyword\">self</span> storeUrl]]) &#123;  </div><div class=\"line\">        [<span class=\"keyword\">self</span> performBackgroundManagedMigrationForStore:[<span class=\"keyword\">self</span> storeUrl]];  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移  </span></div><div class=\"line\">        <span class=\"comment\">//NSInferMappingModelAutomaticallyOption    coredata会自动创建迁移模型，会去自动尝试  </span></div><div class=\"line\">        <span class=\"built_in\">NSDictionary</span> *option = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                 <span class=\"built_in\">NSSQLitePragmasOption</span>:@&#123;<span class=\"string\">@\"journal_mode\"</span>:<span class=\"string\">@\"DELETE\"</span>&#125;&#125;;  </div><div class=\"line\">          </div><div class=\"line\">        _store = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                           configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                     URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                                 options:option  </div><div class=\"line\">                                                   error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (!_store) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed load store,error = %@\"</span>,error);  </div><div class=\"line\">                abort();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">/**/</span>&#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"successfully add store : %@\"</span>,_store);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中有开关，用来控制是否使用迁移管理器，以及系统是否需要进行迁移的判断。系统是否需要迁移的判断代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isMigrationNecessaryForStore:(<span class=\"built_in\">NSURL</span> *)storeUrl  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">//文件是否存在，如果不存在认为是用户设备上并没有持久化存储区，自然不需要迁移  </span></div><div class=\"line\">    <span class=\"keyword\">if</span> (![[<span class=\"built_in\">NSFileManager</span> defaultManager]fileExistsAtPath:[<span class=\"keyword\">self</span> storeUrl].path isDirectory:<span class=\"literal\">nil</span>]) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Skipped Migration, source database missing\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">     <span class=\"built_in\">NSError</span> *error                         = <span class=\"literal\">nil</span>;  </div><div class=\"line\">     <span class=\"built_in\">NSDictionary</span> *sourceMetaData           = [<span class=\"built_in\">NSPersistentStoreCoordinator</span> metadataForPersistentStoreOfType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                                                                     URL:storeUrl  </div><div class=\"line\">                                                                                                      error:&amp;error];</div><div class=\"line\">    <span class=\"built_in\">NSManagedObjectModel</span> *destinationModel = _coordinate.managedObjectModel;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">//比较当前对象模型是否与用户之前安装的应用持久化存储区是否兼容。如果兼容，不需要迁移  </span></div><div class=\"line\">    <span class=\"keyword\">if</span> ([destinationModel isConfiguration:<span class=\"literal\">nil</span> compatibleWithStoreMetadata:sourceMetaData]) &#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Skipped Migration, source database is already compatible\"</span>);  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">       </div><div class=\"line\">    <span class=\"comment\">//所有情况都尝试了，发现还是需要进行数据迁移  </span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>迁移工作如何进行，众所周知，迁移工作是一项比较耗时间的工作，尤其是在数据库比较大的情况下，那么肯定不能放在前台进行,必须放在后台进行，前台展示加载进度，代码如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)performBackgroundManagedMigrationForStore:(<span class=\"built_in\">NSURL</span> *)store  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">UIStoryboard</span> *sb                      = [<span class=\"built_in\">UIStoryboard</span> storyboardWithName:<span class=\"string\">@\"Main\"</span> bundle:<span class=\"literal\">nil</span>];  </div><div class=\"line\">    <span class=\"keyword\">self</span>.migrationVC                      = [sb instantiateViewControllerWithIdentifier:<span class=\"string\">@\"migration\"</span>];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">UIApplication</span> *app                    = [<span class=\"built_in\">UIApplication</span> sharedApplication];  </div><div class=\"line\">    <span class=\"built_in\">UINavigationController</span> *navigationCtl = (<span class=\"built_in\">UINavigationController</span> *)[app keyWindow].rootViewController;  </div><div class=\"line\">      </div><div class=\"line\">    [navigationCtl presentViewController:<span class=\"keyword\">self</span>.migrationVC  </div><div class=\"line\">                                animated:<span class=\"literal\">YES</span>  </div><div class=\"line\">                              completion:<span class=\"literal\">nil</span>];  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class=\"number\">0</span>), ^&#123;  </div><div class=\"line\">         </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> done = [<span class=\"keyword\">self</span> migrateStore:[<span class=\"keyword\">self</span> storeUrl]];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (done) &#123;  </div><div class=\"line\">            <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">                <span class=\"built_in\">NSError</span> *error              = <span class=\"literal\">nil</span>;  </div><div class=\"line\">  </div><div class=\"line\">                <span class=\"built_in\">NSDictionary</span> *configuration = @&#123;<span class=\"built_in\">NSMigratePersistentStoresAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                                <span class=\"built_in\">NSInferMappingModelAutomaticallyOption</span>:@(<span class=\"literal\">YES</span>),  </div><div class=\"line\">                                                <span class=\"built_in\">NSSQLitePragmasOption</span>:@&#123;<span class=\"string\">@\"journal_mode\"</span>:<span class=\"string\">@\"DELETE\"</span>&#125;&#125;;  </div><div class=\"line\">  </div><div class=\"line\">                _store                      = [_coordinate addPersistentStoreWithType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                   configuration:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                             URL:[<span class=\"keyword\">self</span> storeUrl]  </div><div class=\"line\">                                                         options:configuration  </div><div class=\"line\">                                                           error:&amp;error];  </div><div class=\"line\">                <span class=\"keyword\">if</span> (_store) &#123;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"success create store\"</span>);  </div><div class=\"line\">                    &#125;  </div><div class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;  </div><div class=\"line\">                    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed, error = %@\"</span>,error);  </div><div class=\"line\">                    &#125;  </div><div class=\"line\">                    abort();  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                  </div><div class=\"line\">                [<span class=\"keyword\">self</span>.migrationVC dismissViewControllerAnimated:<span class=\"literal\">YES</span>  </div><div class=\"line\">                                                     completion:<span class=\"literal\">nil</span>];  </div><div class=\"line\">                  </div><div class=\"line\">                <span class=\"keyword\">self</span>.migrationVC = <span class=\"literal\">nil</span>;  </div><div class=\"line\">            &#125;);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">    &#125;);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来是，真正的迁移过程<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)migrateStore:(<span class=\"built_in\">NSURL</span> *)store  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Running %@ '%@'\"</span>,[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],<span class=\"built_in\">NSStringFromSelector</span>(_cmd));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"built_in\">NSDictionary</span> *sourceMeta               = [<span class=\"built_in\">NSPersistentStoreCoordinator</span> metadataForPersistentStoreOfType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                                                                        URL:store  </div><div class=\"line\">                                                                                                      error:<span class=\"literal\">nil</span>];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">NSManagedObjectModel</span> *sourceModel      = [<span class=\"built_in\">NSManagedObjectModel</span> mergedModelFromBundles:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                                         forStoreMetadata:sourceMeta];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"built_in\">NSManagedObjectModel</span> *destinationModel = _model;  </div><div class=\"line\">    <span class=\"built_in\">NSMappingModel</span> *mappingModel           = [<span class=\"built_in\">NSMappingModel</span> mappingModelFromBundles:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                                      forSourceModel:sourceModel  </div><div class=\"line\">                                                                    destinationModel:destinationModel];  </div><div class=\"line\">    <span class=\"keyword\">if</span> (mappingModel) &#123;  </div><div class=\"line\">        <span class=\"built_in\">NSError</span> *error                       = <span class=\"literal\">nil</span>;  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"built_in\">NSMigrationManager</span> *migrationManager = [[<span class=\"built_in\">NSMigrationManager</span> alloc]initWithSourceModel:sourceModel  </div><div class=\"line\">                                                                             destinationModel:destinationModel];  </div><div class=\"line\">  </div><div class=\"line\">        [migrationManager addObserver:<span class=\"keyword\">self</span>  </div><div class=\"line\">                           forKeyPath:<span class=\"string\">@\"migrationProgress\"</span>  </div><div class=\"line\">                              options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span>  </div><div class=\"line\">                              context:<span class=\"literal\">nil</span>];  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"built_in\">NSURL</span> *destinationStore              = [[<span class=\"keyword\">self</span> applicationStoreDirectory]URLByAppendingPathComponent:<span class=\"string\">@\"temp.sqlite\"</span>];  </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> success                         = <span class=\"literal\">NO</span>;  </div><div class=\"line\">        success                              = [migrationManager migrateStoreFromURL:store  </div><div class=\"line\">                                                    type:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                                 options:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                        withMappingModel:mappingModel  </div><div class=\"line\">                                        toDestinationURL:destinationStore  </div><div class=\"line\">                                         destinationType:<span class=\"built_in\">NSSQLiteStoreType</span>  </div><div class=\"line\">                                      destinationOptions:<span class=\"literal\">nil</span>  </div><div class=\"line\">                                                   error:&amp;error];  </div><div class=\"line\">        <span class=\"keyword\">if</span> (success) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Migration Successfully!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> replaceStore:store withStore:destinationStore]) &#123;  </div><div class=\"line\">                [migrationManager removeObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"migrationProgress\"</span> context:<span class=\"literal\">NULL</span>];  </div><div class=\"line\">                [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter]postNotificationName:someThingChangedNotification object:<span class=\"literal\">nil</span>];  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Migration Failed\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Mapping model is NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后附上俩个辅助方法，用来观察迁移过程和替换数据库的<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)replaceStore:(<span class=\"built_in\">NSURL</span> *)old withStore:(<span class=\"built_in\">NSURL</span> *)new  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"built_in\">BOOL</span> success   = <span class=\"literal\">NO</span>;  </div><div class=\"line\">    <span class=\"built_in\">NSError</span> *error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager]removeItemAtURL:old error:&amp;error]) &#123;  </div><div class=\"line\">        error = <span class=\"literal\">nil</span>;  </div><div class=\"line\">        <span class=\"keyword\">if</span> ([[<span class=\"built_in\">NSFileManager</span> defaultManager]moveItemAtURL:new toURL:old error:&amp;error]) &#123;  </div><div class=\"line\">            success = <span class=\"literal\">YES</span>;  </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed move new store to old\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (debug) &#123;  </div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"failed remove old store\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> success;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> *)change context:(voidvoid *)context  </div><div class=\"line\">&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:<span class=\"string\">@\"migrationProgress\"</span>]) &#123;  </div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">            <span class=\"keyword\">float</span> progress                         = [[change objectForKey:<span class=\"built_in\">NSKeyValueChangeNewKey</span>]floatValue];  </div><div class=\"line\">            <span class=\"keyword\">self</span>.migrationVC.progressView.progress = progress;  </div><div class=\"line\">  </div><div class=\"line\">            <span class=\"keyword\">int</span> percenttage                        = progress * <span class=\"number\">100</span>;  </div><div class=\"line\">            <span class=\"built_in\">NSString</span> *string                       = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Migration Progress %i%%\"</span>,percenttage];  </div><div class=\"line\">            <span class=\"keyword\">self</span>.migrationVC.progressLabel.text    = string;  </div><div class=\"line\">        &#125;);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此，三种数据迁移的方式，都已叙述完毕。<br>[2 小结]（#1）<br>三种迁移方式，各有各的好处，轻量级的迁移可以配套icloud实现云端存储，默认的数据迁移，支持将属性级别的数据进行任意迁移。迁移管理器，可以管理文件存储路径，并能够报告迁移进度，我们在开发过程中，应该按照自己的需求合理选择迁移方式，下一小节结合NSFetchedResultController进行数据的实际应用。</p>"},{"title":"点点滴滴：关于va_list","date":"2016-08-27T12:52:29.000Z","toc":false,"_content":"\n想必在iOS这行混过一段时间的人看到下面的代码都会很熟悉\n<!--more-->\n![](http://ock9zbzms.bkt.clouddn.com/small-small640.png)\n我们今天要讨论的就是这个方法最后边的可变参数列表的使用。这个方法内部到底是如何实现的呢？以及这样提供函数调用的好处又有哪些呢？接下来，我们慢慢研究下\n\n1.首先，苹果这么做，肯定是有它这么设计的原因。相比于最后一个参数换为数组，可变参数列表的形式更加直观，可读性强！此外，相对于只能传递一个参数的方法，可变参数列表参数又提供了扩展性，基于此，很有必要去研究下可变参数列表的使用了。\n2.其次，iOS实现可变参数列表的关键点是什么？关键在于va_list。va_list是C语言提供的处理可变参数的一种方法。具体的注意事项如下\n\n1.首先在函数里面定义va_list的变量，这个变量是指向参数的指针。\n2.然后用va_start初始化刚定义的va_list变量。\n3.然后用va_arg返回可变的参数，va_arg的第二个参数是返回的参数类型，例如va_arg(args,NSString *)，va_arg每调用一次就会指向下个参数的地址，直到再也没有获取到参数为止。\n4.最后用va_end宏结束可变参数的获取。\n\n下面，用一个demo来具体演示下如果使用可变参数列表声明、定义函数\n\n![](http://ock9zbzms.bkt.clouddn.com/small-small641.png)\n![](http://ock9zbzms.bkt.clouddn.com/small-small642.png)\n\nTips\n\n1.函数调用的时候，最后一个参数后面一定要加nil，我们也在函数声明的定义用编译器去做了属性声明，要求最后一个参数传递nil进去，否则会crash。\n2.函数传递的参数类型要求是相同数据类型，要传字符串都传字符串，要传数字都传数字，否则也会有问题。\n今天主要就对这个进行一个小小的总结，总结这个题材会做多少期，目前我个人也不知道，等哪天总结的差不多了，也许就停下来了吧。嘿嘿！","source":"_posts/点点滴滴：关于va-list.md","raw":"---\ntitle: 点点滴滴：关于va_list\ndate: 2016-08-27 20:52:29\ntags: 点点滴滴\ntoc: false\n---\n\n想必在iOS这行混过一段时间的人看到下面的代码都会很熟悉\n<!--more-->\n![](http://ock9zbzms.bkt.clouddn.com/small-small640.png)\n我们今天要讨论的就是这个方法最后边的可变参数列表的使用。这个方法内部到底是如何实现的呢？以及这样提供函数调用的好处又有哪些呢？接下来，我们慢慢研究下\n\n1.首先，苹果这么做，肯定是有它这么设计的原因。相比于最后一个参数换为数组，可变参数列表的形式更加直观，可读性强！此外，相对于只能传递一个参数的方法，可变参数列表参数又提供了扩展性，基于此，很有必要去研究下可变参数列表的使用了。\n2.其次，iOS实现可变参数列表的关键点是什么？关键在于va_list。va_list是C语言提供的处理可变参数的一种方法。具体的注意事项如下\n\n1.首先在函数里面定义va_list的变量，这个变量是指向参数的指针。\n2.然后用va_start初始化刚定义的va_list变量。\n3.然后用va_arg返回可变的参数，va_arg的第二个参数是返回的参数类型，例如va_arg(args,NSString *)，va_arg每调用一次就会指向下个参数的地址，直到再也没有获取到参数为止。\n4.最后用va_end宏结束可变参数的获取。\n\n下面，用一个demo来具体演示下如果使用可变参数列表声明、定义函数\n\n![](http://ock9zbzms.bkt.clouddn.com/small-small641.png)\n![](http://ock9zbzms.bkt.clouddn.com/small-small642.png)\n\nTips\n\n1.函数调用的时候，最后一个参数后面一定要加nil，我们也在函数声明的定义用编译器去做了属性声明，要求最后一个参数传递nil进去，否则会crash。\n2.函数传递的参数类型要求是相同数据类型，要传字符串都传字符串，要传数字都传数字，否则也会有问题。\n今天主要就对这个进行一个小小的总结，总结这个题材会做多少期，目前我个人也不知道，等哪天总结的差不多了，也许就停下来了吧。嘿嘿！","slug":"点点滴滴：关于va-list","published":1,"updated":"2016-12-29T02:18:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtg10009492wgifyiiok","content":"<p>想必在iOS这行混过一段时间的人看到下面的代码都会很熟悉<br><a id=\"more\"></a><br><img src=\"http://ock9zbzms.bkt.clouddn.com/small-small640.png\" alt=\"\"><br>我们今天要讨论的就是这个方法最后边的可变参数列表的使用。这个方法内部到底是如何实现的呢？以及这样提供函数调用的好处又有哪些呢？接下来，我们慢慢研究下</p>\n<p>1.首先，苹果这么做，肯定是有它这么设计的原因。相比于最后一个参数换为数组，可变参数列表的形式更加直观，可读性强！此外，相对于只能传递一个参数的方法，可变参数列表参数又提供了扩展性，基于此，很有必要去研究下可变参数列表的使用了。<br>2.其次，iOS实现可变参数列表的关键点是什么？关键在于va_list。va_list是C语言提供的处理可变参数的一种方法。具体的注意事项如下</p>\n<p>1.首先在函数里面定义va_list的变量，这个变量是指向参数的指针。<br>2.然后用va_start初始化刚定义的va_list变量。<br>3.然后用va_arg返回可变的参数，va_arg的第二个参数是返回的参数类型，例如va_arg(args,NSString *)，va_arg每调用一次就会指向下个参数的地址，直到再也没有获取到参数为止。<br>4.最后用va_end宏结束可变参数的获取。</p>\n<p>下面，用一个demo来具体演示下如果使用可变参数列表声明、定义函数</p>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/small-small641.png\" alt=\"\"><br><img src=\"http://ock9zbzms.bkt.clouddn.com/small-small642.png\" alt=\"\"></p>\n<p>Tips</p>\n<p>1.函数调用的时候，最后一个参数后面一定要加nil，我们也在函数声明的定义用编译器去做了属性声明，要求最后一个参数传递nil进去，否则会crash。<br>2.函数传递的参数类型要求是相同数据类型，要传字符串都传字符串，要传数字都传数字，否则也会有问题。<br>今天主要就对这个进行一个小小的总结，总结这个题材会做多少期，目前我个人也不知道，等哪天总结的差不多了，也许就停下来了吧。嘿嘿！</p>\n","excerpt":"<p>想必在iOS这行混过一段时间的人看到下面的代码都会很熟悉<br>","more":"<br><img src=\"http://ock9zbzms.bkt.clouddn.com/small-small640.png\" alt=\"\"><br>我们今天要讨论的就是这个方法最后边的可变参数列表的使用。这个方法内部到底是如何实现的呢？以及这样提供函数调用的好处又有哪些呢？接下来，我们慢慢研究下</p>\n<p>1.首先，苹果这么做，肯定是有它这么设计的原因。相比于最后一个参数换为数组，可变参数列表的形式更加直观，可读性强！此外，相对于只能传递一个参数的方法，可变参数列表参数又提供了扩展性，基于此，很有必要去研究下可变参数列表的使用了。<br>2.其次，iOS实现可变参数列表的关键点是什么？关键在于va_list。va_list是C语言提供的处理可变参数的一种方法。具体的注意事项如下</p>\n<p>1.首先在函数里面定义va_list的变量，这个变量是指向参数的指针。<br>2.然后用va_start初始化刚定义的va_list变量。<br>3.然后用va_arg返回可变的参数，va_arg的第二个参数是返回的参数类型，例如va_arg(args,NSString *)，va_arg每调用一次就会指向下个参数的地址，直到再也没有获取到参数为止。<br>4.最后用va_end宏结束可变参数的获取。</p>\n<p>下面，用一个demo来具体演示下如果使用可变参数列表声明、定义函数</p>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/small-small641.png\" alt=\"\"><br><img src=\"http://ock9zbzms.bkt.clouddn.com/small-small642.png\" alt=\"\"></p>\n<p>Tips</p>\n<p>1.函数调用的时候，最后一个参数后面一定要加nil，我们也在函数声明的定义用编译器去做了属性声明，要求最后一个参数传递nil进去，否则会crash。<br>2.函数传递的参数类型要求是相同数据类型，要传字符串都传字符串，要传数字都传数字，否则也会有问题。<br>今天主要就对这个进行一个小小的总结，总结这个题材会做多少期，目前我个人也不知道，等哪天总结的差不多了，也许就停下来了吧。嘿嘿！</p>"},{"title":"点点滴滴：NSScanner的用法小结","date":"2016-08-27T12:36:20.000Z","toc":true,"_content":"\nNSScanner类是一个类簇的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。\n<!--more-->\nNSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。\n由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和Configuring a Scanner方法下面列举的所有的方法。\n在 NSScanner 对象扫描字符串的时候，你可以通过设置属性charactersToBeSkipped忽略某些字符。在扫描字符串之前，那些位于忽略字符集中的字符将会被跳过。默认的忽略字符是空格和回车字符。\n可以通过[[scanner string] substringFromIndex:[scanner scanLocation]]获取未扫描的字符串。\n\n#### [创建 Scanner对象](#1)\n```objc\n+ scannerWithString:\n+ localizedScannerWithString:\n- initWithString: Designated Initializer\n```\nscannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;\nlocalizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;\ninitWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化\n\n#### [获取Scanner对象字符串](#1)\n```objc\nstring Property\n```\n\n#### [设置scanner对象](#1)\n```objc\nscanLocation Property\ncaseSensitive Property\ncharactersToBeSkipped Property\nlocale Property\n\nscanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起NSRangeException,该属性在发生错误后重新扫描时非常有用。\ncaseSensitive，是否区分字符串中大小写的标志。默认为NO，注意：该设置不会应用到被跳过的字符集。\ncharactersToBeSkipped,在扫描时被跳过的字符集，默认是空白格和回车键。被跳过的字符集优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”};\nlocale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。\n```\n\n#### [扫描字符串](#1)\n```objc\n- scanCharactersFromSet:intoString:\n- scanUpToCharactersFromSet:intoString:\n- scanDecimal:\n- scanDouble:\n- scanFloat:\n- scanHexDouble:\n- scanHexFloat:\n- scanHexInt:\n- scanHexLongLong:\n- scanInteger:\n- scanInt:\n- scanLongLong:\n- scanString:intoString:\n- scanUnsignedLongLong:\n- scanUpToString:intoString:\natEnd Property\n\nscanCharactersFromSet:intoString:扫描字符串中和NSCharacterSet字符集中匹配的字符，是按字符单个匹配的，例如，NSCharacterSet字符集为@\"test123Dmo\"，scanner字符串为 @\" 123test12Demotest\"，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为\"123test12Demotest\"\nscanUpToCharactersFromSet:intoString：扫描字符串直到遇到NSCharacterSet字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容\nscanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回YES,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，如果当前的扫描位置为0，那么扫描不到，但是如果将扫描位置设置成3，就可以扫描到了。\nscanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，存储的内容为123\nscanDecimal:扫描NSDecimal类型的值，有关NSDecimal类型的值更多的信息可以查看：NSDecimalNumber\nscanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。\nscanFloat：扫描单精度浮点型字符，具体内容同scanDouble\nscanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加  0x或者 0X。\nscanHexInt 扫描十六进制无符整型，unsigned int指针指向的地址值为 扫描到的值，包含溢出时的UINT_MAX。\nscanHexLongLong 同scanHexDouble\nscanInt 扫描整型，溢出也被认为是有效的整型，int 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。\nscanInteger 同scanInt\nscanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。\n```\n\n### [如何使用](#1)\n#### [场景1：获取URL中的请求key和value。](#2)\n\n我们知道在iOS中，系统封装的URL会有一个属性叫做Query，如果是一个正确的URL会有类似的格式 \n@\"https://wwww.baidu.com/home.php?name=cheng&age=19&nickname=hehe\"\n\n其中？后面的就是URL的Query，那么如何分别获取key和value呢？\n\n```objc\nvoid scannerStringDemo(){\n    \n    NSURL *url = [NSURL URLWithString:@\"https://wwww.baidu.com/home.php?name=cheng&age=19&nickname=hehe\"];\n    NSScanner *scanner = [[NSScanner alloc]initWithString:url.query];\n    NSCharacterSet *delimiterSet = [NSCharacterSet characterSetWithCharactersInString:@\"&\"];\n    NSMutableDictionary *paris = [@{} mutableCopy];\n    \n    while (![scanner isAtEnd]) {\n        NSString *pairString = nil;\n        [scanner scanUpToCharactersFromSet:delimiterSet intoString:&pairString];\n        [scanner scanCharactersFromSet:delimiterSet intoString:NULL];\n        NSRange range = [pairString rangeOfString:@\"=\"];\n        if (range.location != NSNotFound) {\n            NSString *key = [pairString substringToIndex:range.location];\n            NSString *value = [pairString substringFromIndex:range.location + range.length];\n            [paris setObject:key forKey:@\"key\"];\n            [paris setObject:value forKey:@\"value\"];\n        }\n    }\n}\n\n```\n#### [场景2：判断当前的字符串是否是一个纯数字](#2)\n\n```objc\n- (BOOL)isPureInt:(NSString*)string{\n    NSScanner* scan = [NSScanner scannerWithString:string];\n    int val;\n    return[scan scanInt:&val] && [scan isAtEnd];\n}\n```\n\n#### [场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字](#2)\n```objc\n+(BOOL)isValidAboutInputText:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string decimalNumber:(NSInteger)number{\n    NSScanner      *scanner    = [NSScanner scannerWithString:string];\n    NSCharacterSet *numbers;\n    NSRange         pointRange = [textField.text rangeOfString:@\".\"];\n    if ( (pointRange.length > 0) && (pointRange.location < range.location  || pointRange.location > range.location + range.length) ){\n        numbers = [NSCharacterSet characterSetWithCharactersInString:@\"0123456789\"];\n    }else{\n        numbers = [NSCharacterSet characterSetWithCharactersInString:@\"0123456789.\"];\n    }\n    if ( [textField.text isEqualToString:@\"\"] && [string isEqualToString:@\".\"] ){\n        return NO;\n    }\n    short remain = number; //保留 number位小数\n    NSString *tempStr = [textField.text stringByAppendingString:string];\n    NSUInteger strlen = [tempStr length];\n    if(pointRange.length > 0 && pointRange.location > 0){ //判断输入框内是否含有“.”。\n        if([string isEqualToString:@\".\"]){ //当输入框内已经含有“.”时，如果再输入“.”则被视为无效。\n            return NO;\n        }\n        if(strlen > 0 && (strlen - pointRange.location) > remain+1){ //当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。\n            return NO;\n        }\n    }\n    NSRange zeroRange = [textField.text rangeOfString:@\"0\"];\n    if(zeroRange.length == 1 && zeroRange.location == 0){ //判断输入框第一个字符是否为“0”\n        if(![string isEqualToString:@\"0\"] && ![string isEqualToString:@\".\"] && [textField.text length] == 1){ //当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。\n            textField.text = string;\n            return NO;\n        }else{\n            if(pointRange.length == 0 && pointRange.location > 0){ //当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。\n                if([string isEqualToString:@\"0\"]){\n                    return NO;\n                }\n            }\n        }\n    }\n    NSString *buffer;\n    if ( ![scanner scanCharactersFromSet:numbers intoString:&buffer] && ([string length] != 0) ){\n        return NO;\n    }else{\n        return YES;\n    }\n}\n```\n\n### [注意事项](#2)\n```objc\n[scanner scanCharactersFromSet:delimiterSet intoString:NULL];可以使用这个方法，跳过不需要的字符。\n```\n目前能想到的用法就这些，如果有更多的用法，以后慢慢补充！","source":"_posts/点点滴滴：NSScanner的用法小结.md","raw":"---\ntitle: 点点滴滴：NSScanner的用法小结\ndate: 2016-08-27 20:36:20\ntags: 点点滴滴\ntoc: true\n---\n\nNSScanner类是一个类簇的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。\n<!--more-->\nNSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。\n由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和Configuring a Scanner方法下面列举的所有的方法。\n在 NSScanner 对象扫描字符串的时候，你可以通过设置属性charactersToBeSkipped忽略某些字符。在扫描字符串之前，那些位于忽略字符集中的字符将会被跳过。默认的忽略字符是空格和回车字符。\n可以通过[[scanner string] substringFromIndex:[scanner scanLocation]]获取未扫描的字符串。\n\n#### [创建 Scanner对象](#1)\n```objc\n+ scannerWithString:\n+ localizedScannerWithString:\n- initWithString: Designated Initializer\n```\nscannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;\nlocalizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;\ninitWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化\n\n#### [获取Scanner对象字符串](#1)\n```objc\nstring Property\n```\n\n#### [设置scanner对象](#1)\n```objc\nscanLocation Property\ncaseSensitive Property\ncharactersToBeSkipped Property\nlocale Property\n\nscanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起NSRangeException,该属性在发生错误后重新扫描时非常有用。\ncaseSensitive，是否区分字符串中大小写的标志。默认为NO，注意：该设置不会应用到被跳过的字符集。\ncharactersToBeSkipped,在扫描时被跳过的字符集，默认是空白格和回车键。被跳过的字符集优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”};\nlocale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。\n```\n\n#### [扫描字符串](#1)\n```objc\n- scanCharactersFromSet:intoString:\n- scanUpToCharactersFromSet:intoString:\n- scanDecimal:\n- scanDouble:\n- scanFloat:\n- scanHexDouble:\n- scanHexFloat:\n- scanHexInt:\n- scanHexLongLong:\n- scanInteger:\n- scanInt:\n- scanLongLong:\n- scanString:intoString:\n- scanUnsignedLongLong:\n- scanUpToString:intoString:\natEnd Property\n\nscanCharactersFromSet:intoString:扫描字符串中和NSCharacterSet字符集中匹配的字符，是按字符单个匹配的，例如，NSCharacterSet字符集为@\"test123Dmo\"，scanner字符串为 @\" 123test12Demotest\"，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为\"123test12Demotest\"\nscanUpToCharactersFromSet:intoString：扫描字符串直到遇到NSCharacterSet字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容\nscanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回YES,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，如果当前的扫描位置为0，那么扫描不到，但是如果将扫描位置设置成3，就可以扫描到了。\nscanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，存储的内容为123\nscanDecimal:扫描NSDecimal类型的值，有关NSDecimal类型的值更多的信息可以查看：NSDecimalNumber\nscanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。\nscanFloat：扫描单精度浮点型字符，具体内容同scanDouble\nscanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加  0x或者 0X。\nscanHexInt 扫描十六进制无符整型，unsigned int指针指向的地址值为 扫描到的值，包含溢出时的UINT_MAX。\nscanHexLongLong 同scanHexDouble\nscanInt 扫描整型，溢出也被认为是有效的整型，int 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。\nscanInteger 同scanInt\nscanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。\n```\n\n### [如何使用](#1)\n#### [场景1：获取URL中的请求key和value。](#2)\n\n我们知道在iOS中，系统封装的URL会有一个属性叫做Query，如果是一个正确的URL会有类似的格式 \n@\"https://wwww.baidu.com/home.php?name=cheng&age=19&nickname=hehe\"\n\n其中？后面的就是URL的Query，那么如何分别获取key和value呢？\n\n```objc\nvoid scannerStringDemo(){\n    \n    NSURL *url = [NSURL URLWithString:@\"https://wwww.baidu.com/home.php?name=cheng&age=19&nickname=hehe\"];\n    NSScanner *scanner = [[NSScanner alloc]initWithString:url.query];\n    NSCharacterSet *delimiterSet = [NSCharacterSet characterSetWithCharactersInString:@\"&\"];\n    NSMutableDictionary *paris = [@{} mutableCopy];\n    \n    while (![scanner isAtEnd]) {\n        NSString *pairString = nil;\n        [scanner scanUpToCharactersFromSet:delimiterSet intoString:&pairString];\n        [scanner scanCharactersFromSet:delimiterSet intoString:NULL];\n        NSRange range = [pairString rangeOfString:@\"=\"];\n        if (range.location != NSNotFound) {\n            NSString *key = [pairString substringToIndex:range.location];\n            NSString *value = [pairString substringFromIndex:range.location + range.length];\n            [paris setObject:key forKey:@\"key\"];\n            [paris setObject:value forKey:@\"value\"];\n        }\n    }\n}\n\n```\n#### [场景2：判断当前的字符串是否是一个纯数字](#2)\n\n```objc\n- (BOOL)isPureInt:(NSString*)string{\n    NSScanner* scan = [NSScanner scannerWithString:string];\n    int val;\n    return[scan scanInt:&val] && [scan isAtEnd];\n}\n```\n\n#### [场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字](#2)\n```objc\n+(BOOL)isValidAboutInputText:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string decimalNumber:(NSInteger)number{\n    NSScanner      *scanner    = [NSScanner scannerWithString:string];\n    NSCharacterSet *numbers;\n    NSRange         pointRange = [textField.text rangeOfString:@\".\"];\n    if ( (pointRange.length > 0) && (pointRange.location < range.location  || pointRange.location > range.location + range.length) ){\n        numbers = [NSCharacterSet characterSetWithCharactersInString:@\"0123456789\"];\n    }else{\n        numbers = [NSCharacterSet characterSetWithCharactersInString:@\"0123456789.\"];\n    }\n    if ( [textField.text isEqualToString:@\"\"] && [string isEqualToString:@\".\"] ){\n        return NO;\n    }\n    short remain = number; //保留 number位小数\n    NSString *tempStr = [textField.text stringByAppendingString:string];\n    NSUInteger strlen = [tempStr length];\n    if(pointRange.length > 0 && pointRange.location > 0){ //判断输入框内是否含有“.”。\n        if([string isEqualToString:@\".\"]){ //当输入框内已经含有“.”时，如果再输入“.”则被视为无效。\n            return NO;\n        }\n        if(strlen > 0 && (strlen - pointRange.location) > remain+1){ //当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。\n            return NO;\n        }\n    }\n    NSRange zeroRange = [textField.text rangeOfString:@\"0\"];\n    if(zeroRange.length == 1 && zeroRange.location == 0){ //判断输入框第一个字符是否为“0”\n        if(![string isEqualToString:@\"0\"] && ![string isEqualToString:@\".\"] && [textField.text length] == 1){ //当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。\n            textField.text = string;\n            return NO;\n        }else{\n            if(pointRange.length == 0 && pointRange.location > 0){ //当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。\n                if([string isEqualToString:@\"0\"]){\n                    return NO;\n                }\n            }\n        }\n    }\n    NSString *buffer;\n    if ( ![scanner scanCharactersFromSet:numbers intoString:&buffer] && ([string length] != 0) ){\n        return NO;\n    }else{\n        return YES;\n    }\n}\n```\n\n### [注意事项](#2)\n```objc\n[scanner scanCharactersFromSet:delimiterSet intoString:NULL];可以使用这个方法，跳过不需要的字符。\n```\n目前能想到的用法就这些，如果有更多的用法，以后慢慢补充！","slug":"点点滴滴：NSScanner的用法小结","published":1,"updated":"2016-12-29T02:18:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix9ujtg3000c492wv5vbikni","content":"<p>NSScanner类是一个类簇的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。<br><a id=\"more\"></a><br>NSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。<br>由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和Configuring a Scanner方法下面列举的所有的方法。<br>在 NSScanner 对象扫描字符串的时候，你可以通过设置属性charactersToBeSkipped忽略某些字符。在扫描字符串之前，那些位于忽略字符集中的字符将会被跳过。默认的忽略字符是空格和回车字符。<br>可以通过[[scanner string] substringFromIndex:[scanner scanLocation]]获取未扫描的字符串。</p>\n<h4 id=\"创建-Scanner对象\"><a href=\"#创建-Scanner对象\" class=\"headerlink\" title=\"创建 Scanner对象\"></a><a href=\"#1\">创建 Scanner对象</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ scannerWithString:</div><div class=\"line\">+ localizedScannerWithString:</div><div class=\"line\">- initWithString: Designated Initializer</div></pre></td></tr></table></figure>\n<p>scannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;<br>localizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;<br>initWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化</p>\n<h4 id=\"获取Scanner对象字符串\"><a href=\"#获取Scanner对象字符串\" class=\"headerlink\" title=\"获取Scanner对象字符串\"></a><a href=\"#1\">获取Scanner对象字符串</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">string Property</div></pre></td></tr></table></figure>\n<h4 id=\"设置scanner对象\"><a href=\"#设置scanner对象\" class=\"headerlink\" title=\"设置scanner对象\"></a><a href=\"#1\">设置scanner对象</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">scanLocation Property</div><div class=\"line\">caseSensitive Property</div><div class=\"line\">charactersToBeSkipped Property</div><div class=\"line\">locale Property</div><div class=\"line\"></div><div class=\"line\">scanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起<span class=\"built_in\">NSRangeException</span>,该属性在发生错误后重新扫描时非常有用。</div><div class=\"line\">caseSensitive，是否区分字符串中大小写的标志。默认为<span class=\"literal\">NO</span>，注意：该设置不会应用到被跳过的字符集。</div><div class=\"line\">charactersToBeSkipped,在扫描时被跳过的字符集，默认是空白格和回车键。被跳过的字符集优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”&#125;;</div><div class=\"line\">locale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。</div></pre></td></tr></table></figure>\n<h4 id=\"扫描字符串\"><a href=\"#扫描字符串\" class=\"headerlink\" title=\"扫描字符串\"></a><a href=\"#1\">扫描字符串</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- scanCharactersFromSet:intoString:</div><div class=\"line\">- scanUpToCharactersFromSet:intoString:</div><div class=\"line\">- scanDecimal:</div><div class=\"line\">- scanDouble:</div><div class=\"line\">- scanFloat:</div><div class=\"line\">- scanHexDouble:</div><div class=\"line\">- scanHexFloat:</div><div class=\"line\">- scanHexInt:</div><div class=\"line\">- scanHexLongLong:</div><div class=\"line\">- scanInteger:</div><div class=\"line\">- scanInt:</div><div class=\"line\">- scanLongLong:</div><div class=\"line\">- scanString:intoString:</div><div class=\"line\">- scanUnsignedLongLong:</div><div class=\"line\">- scanUpToString:intoString:</div><div class=\"line\">atEnd Property</div><div class=\"line\"></div><div class=\"line\">scanCharactersFromSet:intoString:扫描字符串中和<span class=\"built_in\">NSCharacterSet</span>字符集中匹配的字符，是按字符单个匹配的，例如，<span class=\"built_in\">NSCharacterSet</span>字符集为<span class=\"string\">@\"test123Dmo\"</span>，scanner字符串为 <span class=\"string\">@\" 123test12Demotest\"</span>，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为<span class=\"string\">\"123test12Demotest\"</span></div><div class=\"line\">scanUpToCharactersFromSet:intoString：扫描字符串直到遇到<span class=\"built_in\">NSCharacterSet</span>字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容</div><div class=\"line\">scanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回<span class=\"literal\">YES</span>,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为<span class=\"number\">123</span>abc678,传入的字符串内容为abc，如果当前的扫描位置为<span class=\"number\">0</span>，那么扫描不到，但是如果将扫描位置设置成<span class=\"number\">3</span>，就可以扫描到了。</div><div class=\"line\">scanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为<span class=\"number\">123</span>abc678,传入的字符串内容为abc，存储的内容为<span class=\"number\">123</span></div><div class=\"line\">scanDecimal:扫描<span class=\"built_in\">NSDecimal</span>类型的值，有关<span class=\"built_in\">NSDecimal</span>类型的值更多的信息可以查看：<span class=\"built_in\">NSDecimalNumber</span></div><div class=\"line\">scanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。<span class=\"keyword\">double</span>指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的<span class=\"number\">0.0</span>。</div><div class=\"line\">scanFloat：扫描单精度浮点型字符，具体内容同scanDouble</div><div class=\"line\">scanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。<span class=\"keyword\">double</span>指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的<span class=\"number\">0.0</span>。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加  <span class=\"number\">0</span>x或者 <span class=\"number\">0</span>X。</div><div class=\"line\">scanHexInt 扫描十六进制无符整型，<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>指针指向的地址值为 扫描到的值，包含溢出时的<span class=\"built_in\">UINT_MAX</span>。</div><div class=\"line\">scanHexLongLong 同scanHexDouble</div><div class=\"line\">scanInt 扫描整型，溢出也被认为是有效的整型，<span class=\"keyword\">int</span> 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。</div><div class=\"line\">scanInteger 同scanInt</div><div class=\"line\">scanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。</div></pre></td></tr></table></figure>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a><a href=\"#1\">如何使用</a></h3><h4 id=\"场景1：获取URL中的请求key和value。\"><a href=\"#场景1：获取URL中的请求key和value。\" class=\"headerlink\" title=\"场景1：获取URL中的请求key和value。\"></a><a href=\"#2\">场景1：获取URL中的请求key和value。</a></h4><p>我们知道在iOS中，系统封装的URL会有一个属性叫做Query，如果是一个正确的URL会有类似的格式<br>@”<a href=\"https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe\" target=\"_blank\" rel=\"external\">https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe</a>“</p>\n<p>其中？后面的就是URL的Query，那么如何分别获取key和value呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> scannerStringDemo()&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSScanner</span> *scanner = [[<span class=\"built_in\">NSScanner</span> alloc]initWithString:url.query];</div><div class=\"line\">    <span class=\"built_in\">NSCharacterSet</span> *delimiterSet = [<span class=\"built_in\">NSCharacterSet</span> characterSetWithCharactersInString:<span class=\"string\">@\"&amp;\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *paris = [@&#123;&#125; mutableCopy];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">while</span> (![scanner isAtEnd]) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *pairString = <span class=\"literal\">nil</span>;</div><div class=\"line\">        [scanner scanUpToCharactersFromSet:delimiterSet intoString:&amp;pairString];</div><div class=\"line\">        [scanner scanCharactersFromSet:delimiterSet intoString:<span class=\"literal\">NULL</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRange</span> range = [pairString rangeOfString:<span class=\"string\">@\"=\"</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (range.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *key = [pairString substringToIndex:range.location];</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *value = [pairString substringFromIndex:range.location + range.length];</div><div class=\"line\">            [paris setObject:key forKey:<span class=\"string\">@\"key\"</span>];</div><div class=\"line\">            [paris setObject:value forKey:<span class=\"string\">@\"value\"</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"场景2：判断当前的字符串是否是一个纯数字\"><a href=\"#场景2：判断当前的字符串是否是一个纯数字\" class=\"headerlink\" title=\"场景2：判断当前的字符串是否是一个纯数字\"></a><a href=\"#2\">场景2：判断当前的字符串是否是一个纯数字</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPureInt:(<span class=\"built_in\">NSString</span>*)string&#123;</div><div class=\"line\">    <span class=\"built_in\">NSScanner</span>* scan = [<span class=\"built_in\">NSScanner</span> scannerWithString:string];</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    <span class=\"keyword\">return</span>[scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字\"><a href=\"#场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字\" class=\"headerlink\" title=\"场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字\"></a><a href=\"#2\">场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)isValidAboutInputText:(<span class=\"built_in\">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class=\"built_in\">NSRange</span>)range replacementString:(<span class=\"built_in\">NSString</span> *)string decimalNumber:(<span class=\"built_in\">NSInteger</span>)number&#123;</div><div class=\"line\">    <span class=\"built_in\">NSScanner</span>      *scanner    = [<span class=\"built_in\">NSScanner</span> scannerWithString:string];</div><div class=\"line\">    <span class=\"built_in\">NSCharacterSet</span> *numbers;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span>         pointRange = [textField.text rangeOfString:<span class=\"string\">@\".\"</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> ( (pointRange.length &gt; <span class=\"number\">0</span>) &amp;&amp; (pointRange.location &lt; range.location  || pointRange.location &gt; range.location + range.length) )&#123;</div><div class=\"line\">        numbers = [<span class=\"built_in\">NSCharacterSet</span> characterSetWithCharactersInString:<span class=\"string\">@\"0123456789\"</span>];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        numbers = [<span class=\"built_in\">NSCharacterSet</span> characterSetWithCharactersInString:<span class=\"string\">@\"0123456789.\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> ( [textField.text isEqualToString:<span class=\"string\">@\"\"</span>] &amp;&amp; [string isEqualToString:<span class=\"string\">@\".\"</span>] )&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">short</span> remain = number; <span class=\"comment\">//保留 number位小数</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *tempStr = [textField.text stringByAppendingString:string];</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> strlen = [tempStr length];</div><div class=\"line\">    <span class=\"keyword\">if</span>(pointRange.length &gt; <span class=\"number\">0</span> &amp;&amp; pointRange.location &gt; <span class=\"number\">0</span>)&#123; <span class=\"comment\">//判断输入框内是否含有“.”。</span></div><div class=\"line\">        <span class=\"keyword\">if</span>([string isEqualToString:<span class=\"string\">@\".\"</span>])&#123; <span class=\"comment\">//当输入框内已经含有“.”时，如果再输入“.”则被视为无效。</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(strlen &gt; <span class=\"number\">0</span> &amp;&amp; (strlen - pointRange.location) &gt; remain+<span class=\"number\">1</span>)&#123; <span class=\"comment\">//当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span> zeroRange = [textField.text rangeOfString:<span class=\"string\">@\"0\"</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span>(zeroRange.length == <span class=\"number\">1</span> &amp;&amp; zeroRange.location == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//判断输入框第一个字符是否为“0”</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(![string isEqualToString:<span class=\"string\">@\"0\"</span>] &amp;&amp; ![string isEqualToString:<span class=\"string\">@\".\"</span>] &amp;&amp; [textField.text length] == <span class=\"number\">1</span>)&#123; <span class=\"comment\">//当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。</span></div><div class=\"line\">            textField.text = string;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(pointRange.length == <span class=\"number\">0</span> &amp;&amp; pointRange.location &gt; <span class=\"number\">0</span>)&#123; <span class=\"comment\">//当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。</span></div><div class=\"line\">                <span class=\"keyword\">if</span>([string isEqualToString:<span class=\"string\">@\"0\"</span>])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *buffer;</div><div class=\"line\">    <span class=\"keyword\">if</span> ( ![scanner scanCharactersFromSet:numbers intoString:&amp;buffer] &amp;&amp; ([string length] != <span class=\"number\">0</span>) )&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a><a href=\"#2\">注意事项</a></h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[scanner scanCharactersFromSet:delimiterSet intoString:<span class=\"literal\">NULL</span>];可以使用这个方法，跳过不需要的字符。</div></pre></td></tr></table></figure>\n<p>目前能想到的用法就这些，如果有更多的用法，以后慢慢补充！</p>\n","excerpt":"<p>NSScanner类是一个类簇的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。<br>","more":"<br>NSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。<br>由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和Configuring a Scanner方法下面列举的所有的方法。<br>在 NSScanner 对象扫描字符串的时候，你可以通过设置属性charactersToBeSkipped忽略某些字符。在扫描字符串之前，那些位于忽略字符集中的字符将会被跳过。默认的忽略字符是空格和回车字符。<br>可以通过[[scanner string] substringFromIndex:[scanner scanLocation]]获取未扫描的字符串。</p>\n<h4 id=\"创建-Scanner对象\"><a href=\"#创建-Scanner对象\" class=\"headerlink\" title=\"创建 Scanner对象\"></a><a href=\"#1\">创建 Scanner对象</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ scannerWithString:</div><div class=\"line\">+ localizedScannerWithString:</div><div class=\"line\">- initWithString: Designated Initializer</div></pre></td></tr></table></figure>\n<p>scannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;<br>localizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;<br>initWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化</p>\n<h4 id=\"获取Scanner对象字符串\"><a href=\"#获取Scanner对象字符串\" class=\"headerlink\" title=\"获取Scanner对象字符串\"></a><a href=\"#1\">获取Scanner对象字符串</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">string Property</div></pre></td></tr></table></figure>\n<h4 id=\"设置scanner对象\"><a href=\"#设置scanner对象\" class=\"headerlink\" title=\"设置scanner对象\"></a><a href=\"#1\">设置scanner对象</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">scanLocation Property</div><div class=\"line\">caseSensitive Property</div><div class=\"line\">charactersToBeSkipped Property</div><div class=\"line\">locale Property</div><div class=\"line\"></div><div class=\"line\">scanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起<span class=\"built_in\">NSRangeException</span>,该属性在发生错误后重新扫描时非常有用。</div><div class=\"line\">caseSensitive，是否区分字符串中大小写的标志。默认为<span class=\"literal\">NO</span>，注意：该设置不会应用到被跳过的字符集。</div><div class=\"line\">charactersToBeSkipped,在扫描时被跳过的字符集，默认是空白格和回车键。被跳过的字符集优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”&#125;;</div><div class=\"line\">locale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。</div></pre></td></tr></table></figure>\n<h4 id=\"扫描字符串\"><a href=\"#扫描字符串\" class=\"headerlink\" title=\"扫描字符串\"></a><a href=\"#1\">扫描字符串</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- scanCharactersFromSet:intoString:</div><div class=\"line\">- scanUpToCharactersFromSet:intoString:</div><div class=\"line\">- scanDecimal:</div><div class=\"line\">- scanDouble:</div><div class=\"line\">- scanFloat:</div><div class=\"line\">- scanHexDouble:</div><div class=\"line\">- scanHexFloat:</div><div class=\"line\">- scanHexInt:</div><div class=\"line\">- scanHexLongLong:</div><div class=\"line\">- scanInteger:</div><div class=\"line\">- scanInt:</div><div class=\"line\">- scanLongLong:</div><div class=\"line\">- scanString:intoString:</div><div class=\"line\">- scanUnsignedLongLong:</div><div class=\"line\">- scanUpToString:intoString:</div><div class=\"line\">atEnd Property</div><div class=\"line\"></div><div class=\"line\">scanCharactersFromSet:intoString:扫描字符串中和<span class=\"built_in\">NSCharacterSet</span>字符集中匹配的字符，是按字符单个匹配的，例如，<span class=\"built_in\">NSCharacterSet</span>字符集为<span class=\"string\">@\"test123Dmo\"</span>，scanner字符串为 <span class=\"string\">@\" 123test12Demotest\"</span>，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为<span class=\"string\">\"123test12Demotest\"</span></div><div class=\"line\">scanUpToCharactersFromSet:intoString：扫描字符串直到遇到<span class=\"built_in\">NSCharacterSet</span>字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容</div><div class=\"line\">scanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回<span class=\"literal\">YES</span>,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为<span class=\"number\">123</span>abc678,传入的字符串内容为abc，如果当前的扫描位置为<span class=\"number\">0</span>，那么扫描不到，但是如果将扫描位置设置成<span class=\"number\">3</span>，就可以扫描到了。</div><div class=\"line\">scanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为<span class=\"number\">123</span>abc678,传入的字符串内容为abc，存储的内容为<span class=\"number\">123</span></div><div class=\"line\">scanDecimal:扫描<span class=\"built_in\">NSDecimal</span>类型的值，有关<span class=\"built_in\">NSDecimal</span>类型的值更多的信息可以查看：<span class=\"built_in\">NSDecimalNumber</span></div><div class=\"line\">scanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。<span class=\"keyword\">double</span>指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的<span class=\"number\">0.0</span>。</div><div class=\"line\">scanFloat：扫描单精度浮点型字符，具体内容同scanDouble</div><div class=\"line\">scanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。<span class=\"keyword\">double</span>指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的<span class=\"number\">0.0</span>。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加  <span class=\"number\">0</span>x或者 <span class=\"number\">0</span>X。</div><div class=\"line\">scanHexInt 扫描十六进制无符整型，<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>指针指向的地址值为 扫描到的值，包含溢出时的<span class=\"built_in\">UINT_MAX</span>。</div><div class=\"line\">scanHexLongLong 同scanHexDouble</div><div class=\"line\">scanInt 扫描整型，溢出也被认为是有效的整型，<span class=\"keyword\">int</span> 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。</div><div class=\"line\">scanInteger 同scanInt</div><div class=\"line\">scanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。</div></pre></td></tr></table></figure>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a><a href=\"#1\">如何使用</a></h3><h4 id=\"场景1：获取URL中的请求key和value。\"><a href=\"#场景1：获取URL中的请求key和value。\" class=\"headerlink\" title=\"场景1：获取URL中的请求key和value。\"></a><a href=\"#2\">场景1：获取URL中的请求key和value。</a></h4><p>我们知道在iOS中，系统封装的URL会有一个属性叫做Query，如果是一个正确的URL会有类似的格式<br>@”<a href=\"https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe\">https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe</a>“</p>\n<p>其中？后面的就是URL的Query，那么如何分别获取key和value呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> scannerStringDemo()&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *url = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSScanner</span> *scanner = [[<span class=\"built_in\">NSScanner</span> alloc]initWithString:url.query];</div><div class=\"line\">    <span class=\"built_in\">NSCharacterSet</span> *delimiterSet = [<span class=\"built_in\">NSCharacterSet</span> characterSetWithCharactersInString:<span class=\"string\">@\"&amp;\"</span>];</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *paris = [@&#123;&#125; mutableCopy];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">while</span> (![scanner isAtEnd]) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *pairString = <span class=\"literal\">nil</span>;</div><div class=\"line\">        [scanner scanUpToCharactersFromSet:delimiterSet intoString:&amp;pairString];</div><div class=\"line\">        [scanner scanCharactersFromSet:delimiterSet intoString:<span class=\"literal\">NULL</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRange</span> range = [pairString rangeOfString:<span class=\"string\">@\"=\"</span>];</div><div class=\"line\">        <span class=\"keyword\">if</span> (range.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *key = [pairString substringToIndex:range.location];</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *value = [pairString substringFromIndex:range.location + range.length];</div><div class=\"line\">            [paris setObject:key forKey:<span class=\"string\">@\"key\"</span>];</div><div class=\"line\">            [paris setObject:value forKey:<span class=\"string\">@\"value\"</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"场景2：判断当前的字符串是否是一个纯数字\"><a href=\"#场景2：判断当前的字符串是否是一个纯数字\" class=\"headerlink\" title=\"场景2：判断当前的字符串是否是一个纯数字\"></a><a href=\"#2\">场景2：判断当前的字符串是否是一个纯数字</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isPureInt:(<span class=\"built_in\">NSString</span>*)string&#123;</div><div class=\"line\">    <span class=\"built_in\">NSScanner</span>* scan = [<span class=\"built_in\">NSScanner</span> scannerWithString:string];</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    <span class=\"keyword\">return</span>[scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字\"><a href=\"#场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字\" class=\"headerlink\" title=\"场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字\"></a><a href=\"#2\">场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字</a></h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)isValidAboutInputText:(<span class=\"built_in\">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class=\"built_in\">NSRange</span>)range replacementString:(<span class=\"built_in\">NSString</span> *)string decimalNumber:(<span class=\"built_in\">NSInteger</span>)number&#123;</div><div class=\"line\">    <span class=\"built_in\">NSScanner</span>      *scanner    = [<span class=\"built_in\">NSScanner</span> scannerWithString:string];</div><div class=\"line\">    <span class=\"built_in\">NSCharacterSet</span> *numbers;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span>         pointRange = [textField.text rangeOfString:<span class=\"string\">@\".\"</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> ( (pointRange.length &gt; <span class=\"number\">0</span>) &amp;&amp; (pointRange.location &lt; range.location  || pointRange.location &gt; range.location + range.length) )&#123;</div><div class=\"line\">        numbers = [<span class=\"built_in\">NSCharacterSet</span> characterSetWithCharactersInString:<span class=\"string\">@\"0123456789\"</span>];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        numbers = [<span class=\"built_in\">NSCharacterSet</span> characterSetWithCharactersInString:<span class=\"string\">@\"0123456789.\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> ( [textField.text isEqualToString:<span class=\"string\">@\"\"</span>] &amp;&amp; [string isEqualToString:<span class=\"string\">@\".\"</span>] )&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">short</span> remain = number; <span class=\"comment\">//保留 number位小数</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *tempStr = [textField.text stringByAppendingString:string];</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> strlen = [tempStr length];</div><div class=\"line\">    <span class=\"keyword\">if</span>(pointRange.length &gt; <span class=\"number\">0</span> &amp;&amp; pointRange.location &gt; <span class=\"number\">0</span>)&#123; <span class=\"comment\">//判断输入框内是否含有“.”。</span></div><div class=\"line\">        <span class=\"keyword\">if</span>([string isEqualToString:<span class=\"string\">@\".\"</span>])&#123; <span class=\"comment\">//当输入框内已经含有“.”时，如果再输入“.”则被视为无效。</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(strlen &gt; <span class=\"number\">0</span> &amp;&amp; (strlen - pointRange.location) &gt; remain+<span class=\"number\">1</span>)&#123; <span class=\"comment\">//当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span> zeroRange = [textField.text rangeOfString:<span class=\"string\">@\"0\"</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span>(zeroRange.length == <span class=\"number\">1</span> &amp;&amp; zeroRange.location == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//判断输入框第一个字符是否为“0”</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(![string isEqualToString:<span class=\"string\">@\"0\"</span>] &amp;&amp; ![string isEqualToString:<span class=\"string\">@\".\"</span>] &amp;&amp; [textField.text length] == <span class=\"number\">1</span>)&#123; <span class=\"comment\">//当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。</span></div><div class=\"line\">            textField.text = string;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(pointRange.length == <span class=\"number\">0</span> &amp;&amp; pointRange.location &gt; <span class=\"number\">0</span>)&#123; <span class=\"comment\">//当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。</span></div><div class=\"line\">                <span class=\"keyword\">if</span>([string isEqualToString:<span class=\"string\">@\"0\"</span>])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *buffer;</div><div class=\"line\">    <span class=\"keyword\">if</span> ( ![scanner scanCharactersFromSet:numbers intoString:&amp;buffer] &amp;&amp; ([string length] != <span class=\"number\">0</span>) )&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a><a href=\"#2\">注意事项</a></h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[scanner scanCharactersFromSet:delimiterSet intoString:<span class=\"literal\">NULL</span>];可以使用这个方法，跳过不需要的字符。</div></pre></td></tr></table></figure>\n<p>目前能想到的用法就这些，如果有更多的用法，以后慢慢补充！</p>"},{"title":"译 ios并发编程指南","date":"2016-08-27T13:28:47.000Z","_content":"\n[并发编程指南](#1)\n\n<!--more-->\n\n![](http://ock9zbzms.bkt.clouddn.com/translationconcurrency.png)\n\n# [并发](#1)\n## [1 概述](#2)\n### [1.1 并发的概念](#3)\n并发其实指的是多项任务在同一时间进行，随着多核CPU的普及以及发现任务只在某一核上不停的增加，软件开发者需要一种方式充分的利用多核系统。虽然诸如IOS、MacOS兼容多项程序同时执行，但是大多数的程序运行在后台，并且执行任务只需要很短的CPU时间。这是因为前台应用同时获取了用户的关注并且是设备处于忙的状态。如果一个程序有很多的任务需要处理，但是又只获得了很少的碎片CPU时间，那些额外的处理资源将被浪费。 在过去，在应用中引入并发要求创建一个或者多个额外的线程，遗憾的是，编写线程代码是一项非常有挑战性的事情，线程是一种‘低级’的工具，并且需要手动去管理，获取多少个线程是最优的，动态取决于当前的系统以及底层硬件的支持。实现一个完美的线程解决方案，变的极其困难或者说不可能实现。另外，采取添加线程的方式实现同步的机制，不仅给软件开发带来了复杂性和风险性，而且也并不能确保提升性能。 OSX和iOS采取了一种比传统的基于线程的系统和程序，更加异步的方式去执行并发任务。并不是直接去创建线程，应用需要做的是定义一些特殊的任务，然后让系统去执行它们，让操作系统去管理线程，程序获得了原生线程更强的伸缩性，而程序开发者也获得了更加简单更加高效的编程模型。 本文档就是描述这项技术和技艺，你应该使用这项技术来实现并发。这项技术同时使用于iOS和OSX。\n\n## [1.2 文档的组织](#3)\n本文档包括以下章节 \n1、并发和程序设计——介绍异步程序设计的一些基本概念和异步的执行自定义任务的技术 \n2、操作队列——展示怎样用OC去组装和执行一个任务 \n3、分发队列——展示怎样在基于C的应用程序中去并发地执行任务\n4、资源分发——展示如何异步的处理系统事件 \n5、从线程变成用迁移到新的技术——提供一些技术帮助从旧的线程变成迁移到新的变成技术 本文当同时也包括一些相关章节的专业术语的定义\n\n## [1.3 一些专业名词](#3)\n在开始讨论并发之前，非常有必要去定义一些相关的专业名词来避免混淆，一些开发UNIX或者早先开发OSX的程序员，可能会对任务，队列处理、线程有一些新的任务，本文档对这几个概念有如下定义 \n1、在本文中，线程专指一个分离的支线去执行一段代码，而在老的OSX中特指基于POSIX的API 2、在本文中，执行专指可执行的任务正在执行中，可能包裹着多个线程。\n3、在本文中，任务专指一个需要被执行的抽象工作 关于完整的类似这些概念的定义，参见词汇定义\n\n## [1.4 其他](#3)\n本文档专注于如何在你的程序中实现并发编程，而不包括如何使用线程，如果你需要更多的有关线程开发的只是，请去参考线程编程指导\n\n# [2 并发及程序设计](#2)\n## [2.1 并发编程和程序设计](#3)\n在以前的计算机运行的时候，计算机单位时间最大执行数量的任务取决于CPU的时钟速度，但是随着技术的发展和中央处理器设计的更加紧凑，热量和物理因素开始限制中央处理器的最大时钟速度，所以，主板供应商也在寻找其他的方式去提升他们主板的总体性能，他们发现的解决方案是增加主板上的处理器个数，通过增加处理器个数，一个主板可以在单位时间内执行更多的任务，而并不需要去增加CPU的时钟速度，或是改变主板的大小或考虑热量参数，现在剩下的唯一问题就是如何去充分的利用这些多核。 为了利用这些多核，计算机需要程序设计者能够去同时执行多项任务，在当代，多核操作系统，如OSX或者IOS，可能有几百或者更多的程序在同时运行，所以根据时序安排程序在不同的中央处理器上变得成为可能，然而，大多数的时候，这些程序要么是系统守护进程，要么是那些消费很小处理时间的后台应用程序，取而代之的是，真正需要多核开发的是，独立的前台运行的程序更高效的获取更多核心。 传统的使应用获取多核的方式是创建多线程，然而，随着多核的增加，线程方案有一些问题，最大的问题是线程开发的方式对多核系统不具备很好的伸缩性，你不能仅靠创建更多的行程就能确保程序和处理器运行良好，你需要知道的是，如何高效的利用这些中央处理器。对于程序来讲，如何计算它自身是一件有挑战的事情，尽管你可以正确的管理这些线程，程序去管理这些线程也依然是一项挑战，去确保他们高效运行、确保他们不被别的线程干扰。 所以，总结这些问题，程序需要一种方式去充分应用多核，单个程序可伸缩的执行大量工作，而且这个解决方案需要足够简单，去面对单个处理器任务的任务增长，好消息是，苹果已经提供了解决方案对处理所有这些问题，本章节先睹为快，去看看这项技术的组成以及牛逼的设计，你可以使你的代码从中获益。\n\n## [2.2 从线程开发中走出来](#3)\n尽管线程开发已经应用了多年，而且它们在某些地方还将有用武之地，但是它们并没有可伸缩的解决多核场景，如果你使用线程开发，那么创建一个可伸缩的解决方案的麻烦就落在你肩上了，开发者，你需要去动态的根据系统的多核个数去决定创建多少个线程，此外，你的应用将花费很多消耗在创建和管理这些线程本身的消耗上。 取代线程开发，OSX和IOS使用异步设计的方式解决并发问题，异步方法已经在操作系统中提供了很多年，而且一般都是应用在创建很耗时的任务上，如从磁盘读取文件。当调用的时候，一个异步任务开始在后台执行，并立即返回在任务执行完之前。通常，这项任务会调用一个后台线程，开始这项任务在该后台线程上，然后在任务完成的时候发送一个消息给调用者（通常使用回调的方式）。在过去，如果没有一个你需要的异步方法，你需要自己去写一个异步方法还需要创建自己的线程，但是现在，OSX和iOS提供技术，你可以不用自己去管理线程就可以异步执行任务。 一种开启异步任务的技术叫 GCD，一项将过去需要在你程序中自己写管理线程代码移交给系统去管理。所有你需要做的事情仅仅是创建任务，然后将任务提交给合适的系统的GCD队列。GCD去创建和管理这些线程，因为这些线程已经提交给系统去管理，GCD提供全套的任务管理和执行，比传统的线程管理更加高效。 操作队列是非常类似于分发队列的一种OC对象管理方式，你可以定义你想执行的任务，然后把他们扔到操作队列中，当执行这些安排好的任务时，类似于GCD，操作队列为你执行所有的管理。确保在系统长执行的高效且迅速。 下面的段落提供了更多的信息关于操作队列、分发队列、以及一些你可能在异步编程中用到的技术\n\n### [2.2.1 分发队列](#4)\n分发队列是一套C的机制，为可执行自定义任务。分发队列要么是串行的要么是并行的，但是通常都是按照FIFO的方式去调度任务，一个串行的队列，一次只能运行一个任务，只有等前一个任务完成之后，下个任务才能开启。作为对比，并行的队列可以同时开启尽可能多的任务而并不需要前面的任务执行完毕。 分发队列有下面几个好处 \n\n\t1、提供了简单的直观的编程接口 \n\t2、提供了自动的和完全的线程池管理 \n\t3、任务执行速度提升 \n\t4、更多的内存方面的优化 \n\t5、他们不会增加内核的负载 \n\t6、不会导致队列死锁 \n\t7、伸缩性强（对多核系统来讲） \n\t8、串行队列提供了比过去线程同步更为优秀的一种选择 \n\n你提供给分发队列的任务必须是封装好的一个方法或者是一个Block对象，Block是一种具有C语言特性的，开始引进与OSX 10.6,IOS 4.0的一个新特性。但是相比C语言有一些别的好处。不同于在Block的语法区域定义Block对象，你通常在别的方法或者是函数中去定义，这样可以去捕获到别的方法或者函数中的变量，Block同样可以移动到他们的作用区域以外，拷贝到堆上，这通常发生在你将任务添加到一个分发队列上的时候，所有这些语法特性，使得通过添加少量代码就可以获得非常好的实现。 分发队列是GCD技术的一部分，也是C运行时的一部分，要想获取更多的有关分发队列相关的信息，请参见 分发队列，要获取更多关于Block的信息和他们的好处，参见Block 程序编程观点。\n\n### [2.2.2 分发资源](#4)\n分发资源是异步的处理系统分发资源的一种C语言机制，分发资源封装了一个特殊类型的系统事件，并将这个特殊的系统事件提交给一个特殊的Block对象，或者函数，当系统事件发生的时候，你可以使用分发资源去监测如下特殊系统事件 定时器 信号事件 描述符相关事件 进程相关事件 端口匹配相关事件 自定义的事件，并由你来触发 分发资源也是GCD技术的一部分，要获取更多有关分发资源相关的信息，参见分发资源\n\n### [2.2.3 操作队列](#4)\n操作队列是cocoa环境的一种并发队列，由NSOperationQueueClass 实现，操作队列总是按照FIFO的方式去执行任务，操作队列考虑其他因素去影响执行队列的顺序，在这些因素中，优先考虑一个任务的执行是否是依赖于其他任务，你可以给自己的任务设置依赖关系，然后创建一个复杂的执行顺序图。 任务添加到操作队列中的，必须是NSOperation的子类，一个操作对象是一个OC类型的封装了你要执行的数据和任务的对象，由于NSOperation是一个抽象基类，所以你通常需要去自定义子类去执行你的任务，然而，Foundation Framework已经提供了一些相关的子类，你可以使用它们去执行任务。 操作的对象产生KVO通知，这个是非常有用的，当监视你的任务进度的时候，虽然任务执行通常是并发的，但是可以利用依赖是的任务有序。 关于更多操作队列的信息，参见操作队列\n\n## [2.3 异步编程技术](#3)\n在你开始考虑重新用并发编程的方式重新设计程序的时候，你最好先问下自己这么做是否必要，并发可以提高你代码的可响应性，去确保主线程能相应更多的用户事件，它同样可以提高你代码的性能，通过促进多核去执行更多的任务，但是它也同时带来了上层复杂性，从而使你的代码更加难调试。 由于它带来了复杂性，并发并不是一个在你程序开周期中考虑的特性，当把它嫁接到应用中。做对这件事需要你好好考虑你程序执行的任务以及向这些任务提交的数据结构。如果做错的话，你可能发现你的代码运行缓慢，甚至还不如从前，因此，在你开始程序设计的时候，你就应该考虑你要实现的目标和通过何种方式来达到它。 每个应用都包含有不同的要求和不同的任务需要它去执行，这不可能靠一个文档就告诉你，怎么去设计你的程序和管理任务，然而，下面几段可以给你提供一些指导，帮助你去在程序设计的时候做出好的选择。\n\n### [2.3.1 明确程序期望的表现](#4)\n在你决定是否要将并发引导到应用中的时候，你应当开始思考你的应用程序想要达到的一个什么表现。明白了应用要达到的表现之后，会给你是否使用并发提供一个参考。同样的，也会给你一些引入并发之后程序能获取的性能收益方面的启发。 首先、你需要列举应用程序所要执行的任务和数据结构之间的关系。开始，你可能通过点击一个菜单或者一个按钮开启一个任务并执行，这些任务可能是一些离散的任务，并有明确的开始和结束点。你还需要列举出应用程序可能执行的其他类型的任务，而不仅仅是用户行为相关的，比如说基于时间的一些任务 在你有了自己任务列表之后，开始把任务进行更加的分组集合，确保这些任务能够成功执行。在这个层面，你优先考虑的是那些数据或对象修改如何对应用状态进行修改的。你同样需要考虑不同任务之间的相互依赖关系，例如：如果一个任务牵涉到一个数组中所有对象的修改，对于其中一个数据的修改，会对其他数据产生任何影响。如果一个数据的修改，独立于其他的数据，那么这个时候你可以考虑使用并发去做提升性能，创建多个任务去做。\n\n### [2.3.2 单位工作的可执行因子](#4)\n在明白你程序执行的任务类型之后，你应该明白在什么地方去使用并发会有好处了。如果在一个任务中改变一个或者多个的顺序，会影响到执行结果。你应该还是需要考虑到使用串行的方式去执行这些任务，如果改变执行顺序之后，并不会影响到执行结果，你可以考虑将这些任务用并发的方式去做，在这俩种情形下，你定义可执行的单位工作，并让它们执行，这些工作单元，就成为你封装好的Block对象或者操作对象或者分发队列。 对于每个单独的可执行任务，并不需要过多的担心任务执行的数量，在最后，分到线程中总是会有开销，但是分发队列或者操作队列相比传统的线程开发还是有很多优势的，因此，执行一些单元工作使用操作队列还是要比直接操作线程要好很多，当然，你常常应该确保任务执行的性能和你开启的任务恰好如你所需，但是，任务并不是越小就越好。\n\n### [2.3.3 区分你需要什么队列](#4)\n此时，你的任务已经切割为一些可执行的单元，并且封装成了Block对象或者是操作对象，你需要去定义你要执行的队列以执行这些任务。对一个任务来讲，测试这些Block或者是操作任务，能够在队列中执行正确。 如果你使用Block去实现你的任务,你可以添加任务到串行或者并行的队列里，如果对顺序有要求的话，你只能添加到一个串行队列中，如果没有要求，根据你的要求，你可以添加的并行队列中，或者添加到多个队列中去。 如果你是用操作队列去执行任务，那么选择的队列并不对添加到里面的任务的配置感兴趣，如果要串行去执行任务，那么你需要给相关的任务设置依赖关系，依赖会阻止任务开始执行，直到它依赖的任务执行完成。\n\n### [2.3.4 提升执行效率的贴士](#4)\n在把任务分割为更小的任务并将他们添加到队列中后，这里还有一些使用队列提升程序性能的小Tips 如果内存考虑是一个因素的话，那么在任务里面直接计算。如果你的应用已经内存警告了，那么在任务中直接计算会比从内存中加载要快一些。运用在寄存器或者是该核上的内存计算，会比从主内存加载要快一些。当然，你也可以通过测试来选择哪种方案会好一些。 将串行的任务，可能的话改变为并发。如果一个任务由于共享资源必须串行去执行，可以考虑将共享资源移除使得可以并发执行，可以考虑把这些资源给每个客户都拷贝一份。 避免使用锁，操作队列和分发队列的支持在大多数情况下并不需要锁。做为取代，可以使用一个串行的队列或者使用依赖去保证顺序正确。 如果可能的话依赖系统框架，最好的方式去实现并发就是使用系统提供的框架，许多框架使用线程或者其他技术来实现并发，当定义你的任务的时候，看看系统框架中是否已经有方法或者函数能够实现并发，使用系统接口会提升你的效率，而且帮你做到更多的并发可能性。\n\n## [2.4 性能相关](#3)\n操作队列、分发队列、资源分发提供了一种执行并发更加容易的方式。但是这些技术并不保证提升程序的性能和可响应性。具体来讲，根据你的需要同时兼顾性能提升和不要影响到其他资源仍然是你自己需要衡量的一件事。举个例子来讲，尽管你创建了10000个任务并把他们都提交到操作队列中，这么干的话，肯定会导致你的程序分配潜在的大量内存，这个会导致增加调度和减少性能。 引入并发到你的程序中前--是使用队列还是线程，你需要根据程序当前的性能来设置一个参考的标准。在引入并发之后，也同样需要做个列表对性能方面的改变进行比较，来确保程序是真的性能提升了，如果引入并发并不能给性能带来大的提升，你应该考虑其他的性能工具来检测潜在的原因。 关于性能的介绍和可用的性能工具，参见性能概览。\n\n## [2.5 并发和其他技术](#3)\n将你的代码分解为模块任务是一种最好的提升应用并发的方式，但是这种设计方式并不是对每个应用每个情况都很适合，取决于你执行的任务，也可能存在其他的选择来提升程序的整体并发，下面的俩小节提供了其他的并发技术供你参考\n\n### [2.5.1 OpenGL和并发](#4)\n在OSX中，OpenGC技术是图形计算方便最基础和核心的技术，OpenGL是非常棒的计算大数据集合的一种技术，举个例子来讲，你可能使用OpenGL技术来给图片做像素级别的滤镜，或者用它来计算复杂的数学计算。换而言之，OpenGL可以用来计算大量数据集合是并行的。 尽管OpenGL在大量数据并行执行方面有着非常好的性能优势，但是它并不合适执行自定义的计算，在任务提交给GPU处理之前，有大量的准备工做，而且要将数据和其他必要的核心操作转换图形卡片。同样的，要想获取OpenGL的产生结果也需要偶很多其他的努力。因此，所有跟系统交互相关的任务不建议提交给OpenGL去执行，举个例子，你不应该用OpenGL去运算从文件中或者网络流中拿到的数据，取而代之的是，你要用OpenGL执行的任务，必然是自己已经持有的这样相对来讲传递给GPU运算更加独立。 更多关于OpenGL的只是，参见OpenGL开发指导。\n\n### [2.5.2 何时使用线程](#4)\n尽管操作队列和分发队列是执行并发任务的更优选择，但是它们不是万能的，取决于你的应用程序，这里仍然后一些情况是需要创建线程去开发的，如果你创建了自定义的线程，那么你要确保尽量少的开启线程，并且确保这些线程只执行特定的任务，而不去干别的事情。 线程仍然是一种较好的解决方案，当执行实时任务的时候，分发队列会确保尽快的去执行他们的任务，但是并不能实时的去开线程去做。如果你需要可预测的后台代码执行，那么线程仍是一种选择。 作为线程编程，你还是需要去使用线程，当必须和完全必要的时候，关于更多线程方面的知识，参见线程开发指导。\n\n# [3 操作队列](#2)\ncocoa的操作都是原生的对象封装的可执行异步任务。这些操作同时可提交给操作队列去执行，也可以直接自己执行。由于是基于OC的框架，那么操作可应用在IOS和OSX中。本章节将介绍如何去使用和定义操作。\n\n## [3.1 关于操作对象](#3)\n一个操作对象是一个NSOperation类的实例，你可以用它来封装你要执行的任务。NSOperation类本身是一个抽象基类。所以要想执行可用的任务，必须得使用它的子类。尽管是一个抽象类，它还是提供了一些有用的基本操作，而省去了你在自己定义的子类中去做的麻烦。此外，Foundation 框架还提供了俩个具体的子类，可以用它们来执行你的任务，下表列出了这俩个类，还有如何使用它们的介绍。 NSInvocationOperation ：这是一个基于你的类和要执行的Seletor的类，你可以在已经定义过这个任务的地方去调用它，然后执行异步操作。由于它并不要强制你去做继承，所以可以使用该类去实现一个更加动态的风格。 NSBlockOperation：这是一个执行block封装任务的操作类，因为它可以执行多个block。block任务执行任务使用了组的语法，当所有的相关的block执行完之后，这个block操作才被任务是执行完成 NSOperation：这是定义其他操作任务的基类，继承它给你自定义操作类带来了完成的并发控制以及实现。包含可以完全控制任务的执行能力和执行状态。 所有上述的操作对象都包含以下核心的特性 支持建立图形化的任务间相互依赖，这些依赖将会阻止任务开始，直到它依赖的任务完成之后。 支持可选的完成回调block。指的是当所有的执行任务结束之后的回调方法。 支持检测任务执行状态（使用KVO） 支持对操作顺序进行调整，并影响他们的执行顺序。 支持取消语义，也即允许你半路对任务执行终止操作。 操作对象是设计来帮助你提升程序的并发水平，操作也是一种不错的组织和包装你的应用为几个独立的分支的一种手段，作为取代提交一些任务给主线程的开发方式，可以将任务分割为一个或多个不同的操作，然后提交给队列，使相关的工作可以在一个或多个线程中去并发的执行。\n\n## [3.2 同时VS非同时操作](#3)\n尽管，你通常将任务添加到操作队列中，但是做这个并不是必须的。你也可以直接调用它的start方法去开始一个操作。但是执行这个操作，并不能保证你的操作同步的运行在你当前代码所在的线程中。那么NSOperation类的这个isConcurrent方法会告知你，当前运行的操作是同步还是异步的在你调用Start方法的线程中，默认情况下这个方法会返回NO，也就是说这个操作是在当前调用的线程中同步去执行的。 如果你想去实现一个异步执行的操作，也就是调度任务的线程和任务执行的线程是异步的。你需要写额外的代码去异步的开启它。举个例子，你可以创建一个独立的线程，调用一个系统的异步方法，去执行其他的事情以保证start函数的调用时异步去执行。 大多数的开发并不需要去实现一个并发操作对象，如果你总是将你的操作去添加到一个操作队列中，你并不需要实现这些并发操作，当你添加一个操作对象到操作队列中的时候，操作队列自己就会创建一个线程去执行你的操作，因此，将一个并不是异步的任务添加到操作队列中去，结果还是会以异步的方式去执行代码，去定义一个异步任务这种费力不讨好的工作，也只是你就是想创建异步执行任务，而不是将它添加到队列中去的时候才有必要。 关于更多有关异步任务的信息，参见设置任务去异步执行。\n\n## [3.3 创建一个NSInocationOperation对象](#3)\nNSInvocationOperation是NSOperation的具体子类，当它运行的时候，会执行它的selector里面，指派给它的任务。使用该类时，应该避免将大量的自定义的操作给每个任务。尤其是当你需要改变一个已经存在的应用程序和这些对象已经存在任务，还有很多必备要执行的任务时。你可以使用它来改变依赖环境的时候。举个例子，你可以使用一个Invocation对象来执行一个选择器，这个选择器是基于获取用户的输入信息动态的选择。 创建一个Invocation操作的步骤是很简单的，你可以创建并实例化一个该对象，然后传递需要的对象和selector去执行指定的代码，下面提供了俩个方法去举例说明这个操作步骤，taskWithData：方法创建一个操作对象，然后通过另外一个方法去执行任务。 \n```objc\n\n@implementation MyCustomClass \n\n- (NSOperation*)taskWithData:(id)data { \n\tNSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self \n\tselector:@selector(myTaskMethod:) \n\tobject:data]; \nreturn theOp;\n } // This is the method that does the actual work of the task. \n\n- (void)myTaskMethod:(id)data { // Perform the task. } \n@end\n```\n\n## [3.4 创建一个NSBlockOperation对象](#3)\nNSBlockOperation是NSOperation的具体子类，作为一个或者多个Block对象的封装器，这个类提供了对象层面的封装，而且它已经使用了操作分发队列，所以并不需要创建分发队列，但是你也可以使用其他的诸如操作任务的依赖、KVO通知或者其他特性，而这些特性是分发队列所没有的。 当你创建一个block操作的时候，在创建他的时候，你至少已经添加了一个block，你也可以在之后再添加更多的block进去。当执行NSBlockOperation对象的时间来临的时候，该对象会将它的所有block都提交给默认优先级的异步分发队列，然后这个对象等待它的block全部执行完，之后会把自己标记为isfinish。因此，你可以使用一个Block操作去监听一组任务的完成，非常像用一个线程去管理多个线程的结果。而不同之处在于block操作自己运行在一个分离的线程，而你的程序可以干其他的活儿，在这个block等待它的任务执行完成之前。 下面的代码介绍了如何去创建一个BlockOperation，这个Block没带参数且没有返回什么有意义的结果 NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{ NSLog(@\"Beginning operation.\\n\"); // Do some work. }]; 当创建一个block操作之后，你可以添加更多的block给它，通过 addExecutionBlock：方法，如果你想让添加的任务线性去执行，那么你必须直接将它提交给指定的串行队列中去。\n\n## [3.5 定义一个自定义的操作](#3)\n如果一个Block操作对象或者Invocation操作对象没法完全满足你的需求的时候，你可以考虑自己定义个继承自NSOperation的操作对象，NSOperation对象提供了一系列的继承点给所有的操作对象，这个类已经实现了大量的基础的函数或方法，满足那些依赖或者KVO的操作，然而，还是有一些地方需要你自己的自定义实现确保你的操作对象能够正确的执行，具体的工作量的大小取决于你要自定义的是一个同步操作对象还是异步操作对象。 定义个同步操作对象要比定义一个异步操作对象简单的多，对于一个同步操作对象来讲，所有你要做的工作就是实现main执行函数和响应取消操作事件。父类已经帮你做了所有其他该做的工作，而对于一个异步操作对象来将，你需要替换一些父类已经做过的工作，在你自己定义的操作对象上。下面的俩小节将介绍如何去实现这俩种不同的操作对象。\n\n### [3.5.1 执行main任务](#4)\n至少一个操作对象需要实现下面的函数 一个自定义的初始化函数 main 你需要自定义个初始化函数去初始化一个操作对象，以及一个自定义的main函数去执行任务，你也可以根据需要执行其他的函数，如下所示 自定义函数供你的main函数去调用 属性方法去访问数据 实现NSCoding协议去固化一个操作对象 下面的模板，展示了一个自定义的操作对象，下面的代码并不展示如何去实现取消方法，但是也实现了你通常要实现的方法，具体怎么取消任务，参见取消任务介绍，下面的初始化函数初始化了一个对象，携带一个数据参数并把它存到了类内部方便以后访问，main函数将会显式的去操作这个对象，在你的应用将结果返回给你之前。 \n```objc\n@interface MyNonConcurrentOperation : NSOperation\n@property id (strong) myData; \n-(id)initWithData:(id)data;\n@end \n@implementation MyNonConcurrentOperation \n- (id)initWithData:(id)data { \n\tif(self = [super init]) \n\tmyData = data;\n\treturn self; \n}\n\n-(void)main { \n\t@try {\n\t // Do some work on myData and report the results. \n\t} \n\t@catch(...)\n\t {\n\t  // Do not rethrow exceptions.\n\t  } \n\t} \n@end 更多的细节参见NSOperationSample\n```\n\n### [3.5.2 响应取消事件](#4)\n当一个操作开始执行的时候，它将持续执行任务直到结束或者任务被显式的取消掉，取消操作可能发生在任何时候，甚至是操作开始执行的时候，尽管NSOperation对象提供了一个方式供子类去使用，指出取消事件是完全必要的。如果一个操作完全结束了，那么也可以提供一个方式去清理之前分配的资源等等，所以，一个操作对象需要去检测是否已经取消了，然后就可以优雅的结束任务。 操作对象支持取消操作，你应该做的事情就是频繁的去检查是否任务已经被取消了，支持取消是非常重要的，对于你自定义的任务和系统给的那俩个子类操作对象来说，isCancel方法是非常轻量级的，可以频繁去访问而不会造成内存方面的空扰，当设计一个操作对象的时候，你可以在如下几个地方去访问iscancel 1、在你开始执行任务之前 2、在开启一个loop之前，或者是更加频繁的在每个循环之前 3、在你的每个可能导致任务退出的地方 下面的代码介绍了在main函数中如何去调用cancel，在这个例子中，iscancel在每次while loop前都会调用，使得任务可以快速的退出，且获取了一个定期的间隔。 \n```objc\n- (void)main { \n@try { BOOL isDone = NO; \nwhile (![self isCancelled] && !isDone) \n{ // Do some work and set isDone to YES when finished } } \n@catch(...) { // Do not rethrow exceptions. } } \n```\n尽管上面的代码，并不包含清理数据的工作，但是你自己的代码还是要保证资源被及时的释放。\n\n### [3.5.3 定义一个可并发执行的操作](#4)\n一个操作对象默认情况是按照同步的方式去执行任务，也就是说他们执行任务的线程也就是start调用的线程。因为操作队列会对操作任务提供开启的线程，因此，大多数的任务就会异步运行，然而，如果你计划手动去执行一个任务，而且还希望这个任务异步的去运行，你必须得采取一些手段来保证能够这么干，你需要把你的操作对象定义为一个可并发执行的操作对象。下面列出来的函数就是你需要重写的并发操作。 start：（必须重写）所有的自定义并发操作必须重写这个函数，从而替换之前这个函数的默认实现。要手动的执行一个操作，你就可以调用start函数，因此从，你对该方法的实现就是自定义操作对象的开启任务的节点，也就是你要提交你的任务到线程中去执行的节点，你的实现在任何时候都不应该去调用super start。 main：（可选的）这个函数通常用来实现与操作对象相关的任务。虽然你可以把执行任务的任务放到start中去执行，利用mian方法去执行任务会对你的任务开始和清理工作有好处。 isExecuting：（必须的） isFinish：（必须） 并发操作非常有必要向使用它的客户报告配置环境和执行状态，因此一个并发操作必须得包含执行的状态信息包括何时开始执行任务，何时结束任务，如果要报告状态，那么必须使用这些方法。 当别的线程在同时调用上述方法的时候，你必须得保证这些方法是安全的。同时，你也必须得实现KVO通知，以报告这些状态。 isConcurrent：（必须）区分一个操作是否是并发操作，重写该方法，并返回YES 本小节的剩余部分将展示一个MyOperationClass的例子，这个类列举了实现一个并发操作的基本函数，MyOperation 类将在它自己开启的线程中执行任务，而正在的执行任务将与操作类是不相干的，下面例子将的几点，就是你在定义一个并发操作时需要提供的一些基础函数。 下面的代码显示了部分MyOperation的接口和实现函数，这些实现包括isConcurrent、isExecuting，isFinish，等函数。其中isConcurrent函数非常简单，只需要返回YES去指明本操作是一个并发操作就可以了，isExecuting 和 isFinished 也比较简单，返回在类中存储的成员变量的值就可以了。 \n\n```objc\n@interface MyOperation : NSOperation \n{ \n\tBOOL executing;\n\tBOOL finished; \n}\n- (void)completeOperation;\n@end \n@implementation MyOperation \n- (id)init {\n self = [super init]; \n if (self) {\n  executing = NO; \n  finished = NO;\n   } \n return self; \n}\n- (BOOL)isConcurrent { return YES; } \n- (BOOL)isExecuting { return executing; } \n- (BOOL)isFinished { return finished; } \n@end\n```\n下面的方法展示了MyOperation的 start函数，下面的实现是一个start函数，执行任务至少要实现的内容。在这种情况下，start函数简单的开启一个新的线程，然后让这个线程去调用main函数。这个函数同样要更新executing成员变量，而且要对isExecuting关键路径产生KVO通知，当这些工作完成之后，就会离开函数，并去到新的线程中去执行任务。 \n```objc\n- (void)start { // Always check for cancellation before launching the task. \nif ([self isCancelled]) { // Must move the operation to the finished state if it is canceled. [self willChangeValueForKey:@\"isFinished\"]; \nfinished = YES; \n[self didChangeValueForKey:@\"isFinished\"]; return; }\n// If the operation is not canceled, begin executing the task. \n[self willChangeValueForKey:@\"isExecuting\"]; \n[NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil]; executing = YES; [self didChangeValueForKey:@\"isExecuting\"]; \n} \n```\n下面展示了MyOperation剩下的实现，在上面的代码已经知道 main函数将作为新的线程开启任务的节点，它将执行操作对象带来的任务，并且要执行completeOperation函数来说明任务已经结束，completeoperation函数将对isExecuting和isFinished关键路径发送KVO通知，来反应操作对象的状态已经改变。\n\n```objc\n- (void)main { \n\t@try { \n\t\t// Do the main work of the operation here. \n\t\t[self completeOperation]; \n\t} \n\t@catch(...) { \n\t// Do not rethrow exceptions.\n\t }\n} \n- (void)completeOperation { \n\t[self willChangeValueForKey:@\"isFinished\"]; \n\t[self willChangeValueForKey:@\"isExecuting\"]; \n\texecuting = NO; \n\tfinished = YES; \n\t[self didChangeValueForKey:@\"isExecuting\"]; \n\t[self didChangeValueForKey:@\"isFinished\"]; \n}\n```\n尽管是操作对象被取消掉了，你也应该发送KVO通知，来通知你的任务已经完成，当一个操作对象的执行时依赖其他操作对象的时候，它将检测isFinished状态，只有当它依赖的所有isfinished状态都变为YES的时候，如果无法发送isFinshed通知将会阻止其他依赖他的操作对象的执行。\n\n### [3.5.4 维护KVO的兼容](#4)\nNSOperation类是服从下列关键字的KVO isCanceled isConcurrent isExecuting isFinished isReady dependencies queuePriority completeBlock 如果你重写了start函数，和自定义了一些其他比较重要的函数，而不是单单重写main函数，你必须保证自定义的对象能够响应KVO，当重写start函数，其中你最需要关注的就是isExecuting和isFInished，这里有大量的方法会受到这俩个函数的影响。 如果你想实现支持依赖关系，以对其他一些操作对象的时候，你也可以重写isReady函数，并强制返回NO，直到你自定义的依赖关系满足。（如果你仍然想支持系统提供的依赖关系的时候，请保证调用super的函数）当你操作对象的isReady状态发生变化的时候，请发送KVO通知去报告这个状态，不过幸运的是，除非你去重写addDependency和removeDependency:，你并不需要担心KVO通知的发送。 虽然你可以发送其他关键字的KVO通知，但是通常你并不需要这么做，如果你想取消一个任务，你可以简单的调用cancel函数就好了。同样的，你也不需要去修改队列的优先级在操作对象上，最后，除非你的操作对象支持动态的修改isConcurrent，你也不需要发送KVO通知给isConcurrent关键路径。 如果要知道更多关于KVO的操作，请参见KVO编程指导。\n\n## [3.6 自定义一个操作对象的执行行为](#3)\n在添加一个操作对象到操作队列里面之前，需要将一个操作对象设置好，这些对操作对象设置的信息将会对所有的操作对象有效，不仅是自定义的操作对象，还包括系统定义的那俩个操作对象。\n\n### [3.6.1 设置依赖关系](#4)\n依赖是一种限制操作对象执行顺序的一种手段，一个操作对象的执行，必须得在它依赖的所有对象执行完成之后才能进行。也就是说，你可以创建简单的一对一的或者是负责的依赖关系树。 在俩个操作对象之间创建依赖关系，你可以使用addDependency：方法，这个方法可以在你传的目标对象和自己之间创建一个依赖关系。也就是说在目标对象没有执行完成之前，你的这个对象是不会执行的。依赖还不仅仅限制在一个操作队列中，因为是操作对象管理依赖关系，所以在不同的操作队列之中，依赖也是可以起到作用的。但是有一种情况是不允许的，那就是设置依赖环，这是一种语法错误，会导致任务永远得不到执行。 当操作对象所依赖的所有操作对象都执行完成之后，操作对象就变成ready状态，准备执行。（如果是你自己定义的操作对象 ，并自定义了isReady函数，那么准备状态就和你设置的条件有关系了）如果一个操作对象是在操作队列中，那么isReady状态的操作对象在任何时候都可能被执行，如果你计划手动去执行一个操作对象的话，那么可以调用他的start方法。 重要:你应当在将操作对象提交到操作队列之前就去设置依赖关系，如果在之后去设置依赖，也许将不会阻止该任务的执行。 依赖基于的是操作对象间在任何时候都可能发生变化的KVO通知，如果你自定义了操作对象的话，你需要自己去发送KVO通知，以防出现依赖方面的问题。关于更多KVO的信息，参考维护KVO兼容，关于更多设置依赖的信息，参考NSOperation 类\n\n### [3.6.2 改变操作对象的执行优先级](#4)\n对于添加到队列中的操作对象，是否能够执行，首先是受操作对象的isReady状态控制，其次是他们的优先级，是否准备好执行，是由操作对象的依赖对象是否执行完来限制的，但是这个优先级是操作对象的一个属性值，默认情况下，所有新创建的操作对象都是普通优先级，但是你可以增加或者是减少操作对象的优先级，通过setQueuePriority方法 优先级只对同一个队列中的操作对象起作用，如果你的应用有多个操作队列，不同队列中的操作对象的优先级是相互独立的，也就是说，在不同队列里面，存在低优先级的操作比高优先级的操作先执行。 优先级并不是依赖的替代，优先级决定的是那些在队列中已经是准备状态的操作对象的执行顺序，举个例子，如果一个队列中同时有高优先级和低优先级的操作对象准备好了，那么操作队列先执行高优先级的操作对象，然而，如果高优先级的没有准备好，但是低优先级的准备好了，那么将先执行低优先级的，如果你想阻止一个操作任务在另外一个操作对象执行完之后再执行，你需要使用依赖关系去 做\n\n### [3.6.3 改变依附线程的优先级](#4)\n在OSX 10.6及以后，设置一个操作对象所在的线程的优先级成为可能，系统的线程策略是依靠内核去管理，但是高优先级的线程将获得更高的执行机会，对一个操作对象，你可以显式的指定它的线程优先级，通过设置一个浮点型的数值，0-1.0之前。0是优先级最低、1是优先级最高。如果不显式设置的话，系统默认的线程优先级是0.5. 要设置线程优先级的话，你需要在讲操作对象添加到操作队列之前，调用setThreadPriority函数。当它的执行时间到来的时候，默认的start函数就会设置你之前指定的线程优先级来修改优先级。这个优先级只在你执行的main函数执行过程用有效。所有的其他代码包括你的完成回调，仍然是运行在默认的优先级下的。如果你自定义了一个并发的操作，那么你需要重写start函数，并手动去修改线程的优先级。\n\n### [3.6.4 设置一个完成后的回调block](#4)\n在OSX 10.6及以后，一个操作对象可以在它的所有任务执行完成之后去执行一个完成的block，你可以用这个完成的block执行任何与main函数执行的任务里面不相关的的block。举个例子，你可能需要告诉客户这个操作对象的任务都执行完成了，一个并发的操作对象可能会使用这个block去执行它最后的KVO通知 要设置一个完成block，你可以使用setCompleteBlock：函数，这个函数不需要传任何参数，也没有返回值。\n\n## [3.7 关于实现一个操作对象的一些Tips](#3)\n尽管一个操作对象可能非常容易去实现，但是有一些事情在你自定义的操作对象上还是要注意一下，下面的小段描述了这么几个方面。\n\n### [3.7.1 管理操作对象的内存](#4)\n下面的小段，描述了几个在操作对象中管理内存的关键元素，关于更多的OC的内存管理，参见内存管理开发指导。\n#### [3.7.1.1 避免依靠线程存储数据](#5)\n尽管大多是的操作都是在一个线程中执行的，在同步操作对象中，这个线程通常是由操作队列分配给它的，如果一个操作队列将线程分配给操作对象，那么你需要知道这个线程它是属于操作队列的，你不应该和你的操作对象有任何瓜葛，尤其是，你不应该有任何数据相关的在这个线程中，而这些数据并不是你创建和管理的数据，因为线程的生存和死亡是有操作队列或者系统来控制的，因此在线程间数据传递通过线程来传递将是不可靠，也是容易失败的。 在操作队列上，没有任何的理由可以使用线程存储数据，当你初始化一个操作对象，你应该提供给它所有执行任务需要的数据去做这件事，因此，操作对象要提供所有数据，所有来的、去的数据都应该存在操作对象上，知道任务结束或者应用不在需要它。\n\n#### [3.7.1.2 如果需要的话保持操作对象的引用](#5)\n因为操作对象是异步运行的，你不应该认为你可以创建或者忘记他们，它们也只是对象而已，也需要你去管理他们，尤其是你需要在它完成之后获取数据的情况下。 你需要保持对操作对象的引用，主要还有可能你再没有机会获取这个操作对象的引用的机会了，操作对象是执行很快的，在很多情况下，操作任务一旦添加到操作队列中，就会被执行，当你的代码获取到从操作队列中拿到的操作对象的时候，很可能，这个操作对象已经结束了，并从操作队列移除了，释放了。\n\n### [3.7.2 处理错误和异常](#4)\n由于操作对象在你的应用里面是完全独立的实例，因此有必要去处理那些异常和错误，在OSX 10.6及以后，默认的start的函数不在提供捕获异常。你自己的代码需要去直接的捕获和处理异常，如果需要也要检测错误代码并通知给应用程序，如果你替换了start函数，那么你的代码需要在程序离开底层线程之前就去处理这些异常。 你可能处理的错误可能有一下几种情况 检测UNIX errno 类型的错误 检测显式的由代码返回的错误 捕获来自你自己的代码和系统框架带来的异常 当一个操作对象没有准备好，start方法就开始执行的时候 当一个操作已经在执行或者执行完成了，或取消了，start函数被再次调用的。 当添加一个block任务，但是它已经被执行或者完成的。 当你准备从NSInvocationOperation对象获取数据，但是它已经被取消的情况。 如果你自定义的代码遇到异常或者错误，你需要提供操作步骤给你的应用去处理，Operation对象不会显式的把错误代码或者异常传递给你应用的其他地方，因此，如果对于应用程序是比较重要的信息，你需要提供相关必要的代码去处理这些错误。\n\n## [3.8 决定操作对象合适的数量，不要太多，也不要太少](#3)\n虽然可以给一个操作队列中，添加大量的操作对象，但是这么做，往往并不太好，像其他对象一样，创建NSOperation对象也是需要消耗内存，并且他们的执行也是需要开销的。如果你的每个任务都是很小的，而你又创建了成千上万个，你会发现你会消耗更多的时间在分发操作对象上，而不是在执行真正的任务，而如果你的设备已经内存不足时，你会发现成千上万的任务会严重影响程序的性能。 高效的应用操作对象的关键在于，在充分利用设备和执行一定数量的操作任务之间找到平衡点，尝试去找到你的设备执行任务的一个真正的数量值。举个例子，如果你的应用创建了100个操作对象去处理100个不同的值，那么你可以考虑使用10个操作对象，去处理10个值去代替。 同时，你也需要避免一次性的给操作队列中添加大量的任务，也要避免不停的给操作队列以比它处理速度更快的添加更多的任务，相比于一次泛哄式的添加任务，不如批量式的去添加，然后利用完成block回调去执行下一批次的任务。这样可以避免内存过多的消耗。 当然，创建操作对象的数量、以及没个操作对象需要执行的任务量，是由你的程序动态去管理的。你应该是用性能测试工具，例如Instruments去找到性能处理和速度的平衡点，关于Instruments 和其他性能工具的更多信息，参见性能。\n\n## [3.9 操作对象的执行](#3)\n最后，你的应用需要执行这些操作对象以真正的处理任务，在这一小节，你将学到就像你熟练的执行你的操作一样，去执行这些操作。\n\n### [3.9.1 添加操作对象到操作队列中](#4)\n到目前为止，最容易的执行操作的方式是使用操作队列，即NSOperationQueue类的实例，你的应用有责任去创建和维护这些操作队列。一个应用程序可以有任意数量的操作队列，但是实际上在同一时间有多少个操作会被执行还是有限制的，被系统调用的操作队列会根据可利用的CPU和系统的载入量来进行限制单位时间执行的操作对象，因此，创建更多的操作队列并不意味着可以执行更多的操作对象 就想创建其他的对象一样，在你的应用中创建操作队列\n```objc\nNSOperationQueue* aQueue = [[NSOperationQueue alloc] init];\n```\n添加一个操作对象到操作队列中，你可以使用addOperation方法，在OSX 10.6以后，你还可以添加操作对象组，通过\n```objc\naddOperations：waitUntilFinished：\n```\n方法，你也可以直接添加blocl对像到操作队列中（而不需要与一个操作对象关联），通过\n```objc\naddOperationWithBlock：\n```\n方法，上面的这些方法，队列都会入一个操作对象并通知队列去执行他们，在大多数情况下，操作对象将会被很快执行，但是有时候，操作队列也可能延迟执行操作对象，大概有这么几个原因，最普遍的就是，操作对象间可能有依赖关系，还有可能是操作队列自己可能被挂起，或者是操作队列执行操作任务的数量达到了上限。下面的代码展示了最基础的添加操作到操作队列的语法 \n```objc\n[aQueue addOperation:anOp]; // Add a single operation \n[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations \n[aQueue addOperationWithBlock:^{ /* Do something. */\n }];\n```\n 重要 千万不要在一个操作对象进入操作队列之后再去修改它，因为当操作在操作队列中等待执行的时候，它可能在任何时候去执行任务，改变它的依赖和数据，可能会起到坏的作用。如果你想知道一个操作对象的状态，请使用操作对象的属性 去获取。\n\n### [3.9.2 手动执行操作对象](#4)\n尽管操作队列对于运行操作对象已经很方便了，但是还是有一种可能不使用操作队列去执行一个操作对象，如果你选择手动去执行操作对象，那么有一些注意事项，最主要的是，操作对象必须得是ready，而且你需要用start函数去启动它。 一个操作对象如果不是ready状态的话不应该去执行，isReady函数被Operation对象的依赖关系封装到了上层，只有当它的依赖关系都清除的时候，一个操作才能够被执行、 当执行一个操作对象，应该去使用start函数去做。用这个函数而不是用main，是因为start函数会在执行之前执行一个安全检查，尤其是，默认的start函数还会产生KVO通知，以保证依赖关系能够正确进行，这个函数同时也避免当你的操作对象被取消的时候，再去执行，以及当操作对象没有准备好的时候就去调用导致的异常抛出 。 如果你的程序定义了并发的操作对象，你同时需要在启动任务之前考虑isConcurrent。当这个方法返回NO的时候，你就可以考虑是在当前线程中同步的执行还是创建一个新的子线程。然而，这些方法的检测完全取决于你。 下面展示了一个比较简单的，手动开启并发操作对象的一个例子。如果这个函数返回NO，你可以启动一个timer，在之后再去调用它。然后直到它返回YES之后，取消掉Timer。因为这种情况可能在操作对象被取消的时候发生。 \n```objc\n- (BOOL)performOperation:(NSOperation*)anOp { \n\tBOOL ranIt = NO; \n\tif ([anOp isReady] && ![anOp isCancelled]) { \n\t\tif (![anOp isConcurrent]) \n\t\t[anOp start]; \n\t\telse [NSThread detachNewThreadSelector:@selector(start) toTarget:anOp withObject:nil]; \n\t\tranIt = YES; \n\t}else if ([anOp isCancelled]){ \n\t\t// If it was canceled before it was started, // move the operation to the finished state. \n\t \t[self willChangeValueForKey:@\"isFinished\"]; \n\t \t[self willChangeValueForKey:@\"isExecuting\"];\n\t  \texecuting = NO; \n\t  \tfinished = YES; \n\t  \t[self didChangeValueForKey:@\"isExecuting\"]; \n\t  \t[self didChangeValueForKey:@\"isFinished\"]; \n\t  \t// Set ranIt to YES to prevent the operation from \n\t  \t// being passed to this method again in the future. \n\t  \tranIt = YES; \n\t} return ranIt; \n}\n```\n\n### [3.9.3 取消操作对象](#4)\n当将操作对象添加到操作队列里面的时候，一个操作对象的管理就交给了操作队列，也不能被移除了，唯一使操作对象出列的方法就是调用它的cancel函数，你也可以取消所有的操作对象，通过调用操作队列的cancelAllOperations 你可以在确保你不在需要操作对象的时候取消掉它。发出一个cancel命令，会将操作对象的关键路径变为canceled状态，这将阻止任务继续执行，由于canceled的操作对象也认为是完成的，那么依赖它的操作对象就可以移除依赖关系。然而，更多情况下，更常用的是取消所有操作独享，在某些重要的时候，比如应用退出、或者用户发出了取消指令，这比一个个取消要好很多。\n\n### [3.9.4 等待操作对象的完成](#4)\n为了获取最佳的性能，你应该尽可能的让操作对象并发执行，让系统去干更多的事情，在你执行操作对象任务的时候，如果创建一个操作对象的时候，同时希望获得了操作对象的结果，你可以使用waitUntilFinished：方法来阻塞代码继续执行，直到这个操作对象执行完成。通常来讲，这是最好的方式去避免你能帮到它的时候，阻塞当前线程也许是一个比较好的解决方法。但这也带来了更多的同步性，而限制了整体的可并发性。 你绝不允许在主线程中调用这个方法，你最好在子线程或者其他的线程操作中这么做，阻塞主线程将会降低程序的可响应性。 除了等待一个任务完成，你可以等待一个操作队列所有的任务执行完成，通过调用waitUntilAllOperationsAreFinished，当你等待一个操作队列任务完成的时候，避免在别的线程中添加任务给它，以防延长等待时间。\n\n### [3.9.5 挂起和恢复操作队列](#4)\n如果你想中途终止一个操作队列的话，你可以挂起相应的操作队列，使用setSuspended方法，挂起一个操作队列并不会导致正在执行的操作任务终止。它只是会阻止别的操作对象（操作队列中的）不去执行，你可能会在用户想暂停任务的时候挂起所有操作，因为用户还期望在某个时候恢复这些任务。","source":"_posts/[译] ios并发编程指南.md","raw":"---\ntitle: 译 ios并发编程指南\ndate: 2016-08-27 21:28:47\ntags: 翻译\n---\n\n[并发编程指南](#1)\n\n<!--more-->\n\n![](http://ock9zbzms.bkt.clouddn.com/translationconcurrency.png)\n\n# [并发](#1)\n## [1 概述](#2)\n### [1.1 并发的概念](#3)\n并发其实指的是多项任务在同一时间进行，随着多核CPU的普及以及发现任务只在某一核上不停的增加，软件开发者需要一种方式充分的利用多核系统。虽然诸如IOS、MacOS兼容多项程序同时执行，但是大多数的程序运行在后台，并且执行任务只需要很短的CPU时间。这是因为前台应用同时获取了用户的关注并且是设备处于忙的状态。如果一个程序有很多的任务需要处理，但是又只获得了很少的碎片CPU时间，那些额外的处理资源将被浪费。 在过去，在应用中引入并发要求创建一个或者多个额外的线程，遗憾的是，编写线程代码是一项非常有挑战性的事情，线程是一种‘低级’的工具，并且需要手动去管理，获取多少个线程是最优的，动态取决于当前的系统以及底层硬件的支持。实现一个完美的线程解决方案，变的极其困难或者说不可能实现。另外，采取添加线程的方式实现同步的机制，不仅给软件开发带来了复杂性和风险性，而且也并不能确保提升性能。 OSX和iOS采取了一种比传统的基于线程的系统和程序，更加异步的方式去执行并发任务。并不是直接去创建线程，应用需要做的是定义一些特殊的任务，然后让系统去执行它们，让操作系统去管理线程，程序获得了原生线程更强的伸缩性，而程序开发者也获得了更加简单更加高效的编程模型。 本文档就是描述这项技术和技艺，你应该使用这项技术来实现并发。这项技术同时使用于iOS和OSX。\n\n## [1.2 文档的组织](#3)\n本文档包括以下章节 \n1、并发和程序设计——介绍异步程序设计的一些基本概念和异步的执行自定义任务的技术 \n2、操作队列——展示怎样用OC去组装和执行一个任务 \n3、分发队列——展示怎样在基于C的应用程序中去并发地执行任务\n4、资源分发——展示如何异步的处理系统事件 \n5、从线程变成用迁移到新的技术——提供一些技术帮助从旧的线程变成迁移到新的变成技术 本文当同时也包括一些相关章节的专业术语的定义\n\n## [1.3 一些专业名词](#3)\n在开始讨论并发之前，非常有必要去定义一些相关的专业名词来避免混淆，一些开发UNIX或者早先开发OSX的程序员，可能会对任务，队列处理、线程有一些新的任务，本文档对这几个概念有如下定义 \n1、在本文中，线程专指一个分离的支线去执行一段代码，而在老的OSX中特指基于POSIX的API 2、在本文中，执行专指可执行的任务正在执行中，可能包裹着多个线程。\n3、在本文中，任务专指一个需要被执行的抽象工作 关于完整的类似这些概念的定义，参见词汇定义\n\n## [1.4 其他](#3)\n本文档专注于如何在你的程序中实现并发编程，而不包括如何使用线程，如果你需要更多的有关线程开发的只是，请去参考线程编程指导\n\n# [2 并发及程序设计](#2)\n## [2.1 并发编程和程序设计](#3)\n在以前的计算机运行的时候，计算机单位时间最大执行数量的任务取决于CPU的时钟速度，但是随着技术的发展和中央处理器设计的更加紧凑，热量和物理因素开始限制中央处理器的最大时钟速度，所以，主板供应商也在寻找其他的方式去提升他们主板的总体性能，他们发现的解决方案是增加主板上的处理器个数，通过增加处理器个数，一个主板可以在单位时间内执行更多的任务，而并不需要去增加CPU的时钟速度，或是改变主板的大小或考虑热量参数，现在剩下的唯一问题就是如何去充分的利用这些多核。 为了利用这些多核，计算机需要程序设计者能够去同时执行多项任务，在当代，多核操作系统，如OSX或者IOS，可能有几百或者更多的程序在同时运行，所以根据时序安排程序在不同的中央处理器上变得成为可能，然而，大多数的时候，这些程序要么是系统守护进程，要么是那些消费很小处理时间的后台应用程序，取而代之的是，真正需要多核开发的是，独立的前台运行的程序更高效的获取更多核心。 传统的使应用获取多核的方式是创建多线程，然而，随着多核的增加，线程方案有一些问题，最大的问题是线程开发的方式对多核系统不具备很好的伸缩性，你不能仅靠创建更多的行程就能确保程序和处理器运行良好，你需要知道的是，如何高效的利用这些中央处理器。对于程序来讲，如何计算它自身是一件有挑战的事情，尽管你可以正确的管理这些线程，程序去管理这些线程也依然是一项挑战，去确保他们高效运行、确保他们不被别的线程干扰。 所以，总结这些问题，程序需要一种方式去充分应用多核，单个程序可伸缩的执行大量工作，而且这个解决方案需要足够简单，去面对单个处理器任务的任务增长，好消息是，苹果已经提供了解决方案对处理所有这些问题，本章节先睹为快，去看看这项技术的组成以及牛逼的设计，你可以使你的代码从中获益。\n\n## [2.2 从线程开发中走出来](#3)\n尽管线程开发已经应用了多年，而且它们在某些地方还将有用武之地，但是它们并没有可伸缩的解决多核场景，如果你使用线程开发，那么创建一个可伸缩的解决方案的麻烦就落在你肩上了，开发者，你需要去动态的根据系统的多核个数去决定创建多少个线程，此外，你的应用将花费很多消耗在创建和管理这些线程本身的消耗上。 取代线程开发，OSX和IOS使用异步设计的方式解决并发问题，异步方法已经在操作系统中提供了很多年，而且一般都是应用在创建很耗时的任务上，如从磁盘读取文件。当调用的时候，一个异步任务开始在后台执行，并立即返回在任务执行完之前。通常，这项任务会调用一个后台线程，开始这项任务在该后台线程上，然后在任务完成的时候发送一个消息给调用者（通常使用回调的方式）。在过去，如果没有一个你需要的异步方法，你需要自己去写一个异步方法还需要创建自己的线程，但是现在，OSX和iOS提供技术，你可以不用自己去管理线程就可以异步执行任务。 一种开启异步任务的技术叫 GCD，一项将过去需要在你程序中自己写管理线程代码移交给系统去管理。所有你需要做的事情仅仅是创建任务，然后将任务提交给合适的系统的GCD队列。GCD去创建和管理这些线程，因为这些线程已经提交给系统去管理，GCD提供全套的任务管理和执行，比传统的线程管理更加高效。 操作队列是非常类似于分发队列的一种OC对象管理方式，你可以定义你想执行的任务，然后把他们扔到操作队列中，当执行这些安排好的任务时，类似于GCD，操作队列为你执行所有的管理。确保在系统长执行的高效且迅速。 下面的段落提供了更多的信息关于操作队列、分发队列、以及一些你可能在异步编程中用到的技术\n\n### [2.2.1 分发队列](#4)\n分发队列是一套C的机制，为可执行自定义任务。分发队列要么是串行的要么是并行的，但是通常都是按照FIFO的方式去调度任务，一个串行的队列，一次只能运行一个任务，只有等前一个任务完成之后，下个任务才能开启。作为对比，并行的队列可以同时开启尽可能多的任务而并不需要前面的任务执行完毕。 分发队列有下面几个好处 \n\n\t1、提供了简单的直观的编程接口 \n\t2、提供了自动的和完全的线程池管理 \n\t3、任务执行速度提升 \n\t4、更多的内存方面的优化 \n\t5、他们不会增加内核的负载 \n\t6、不会导致队列死锁 \n\t7、伸缩性强（对多核系统来讲） \n\t8、串行队列提供了比过去线程同步更为优秀的一种选择 \n\n你提供给分发队列的任务必须是封装好的一个方法或者是一个Block对象，Block是一种具有C语言特性的，开始引进与OSX 10.6,IOS 4.0的一个新特性。但是相比C语言有一些别的好处。不同于在Block的语法区域定义Block对象，你通常在别的方法或者是函数中去定义，这样可以去捕获到别的方法或者函数中的变量，Block同样可以移动到他们的作用区域以外，拷贝到堆上，这通常发生在你将任务添加到一个分发队列上的时候，所有这些语法特性，使得通过添加少量代码就可以获得非常好的实现。 分发队列是GCD技术的一部分，也是C运行时的一部分，要想获取更多的有关分发队列相关的信息，请参见 分发队列，要获取更多关于Block的信息和他们的好处，参见Block 程序编程观点。\n\n### [2.2.2 分发资源](#4)\n分发资源是异步的处理系统分发资源的一种C语言机制，分发资源封装了一个特殊类型的系统事件，并将这个特殊的系统事件提交给一个特殊的Block对象，或者函数，当系统事件发生的时候，你可以使用分发资源去监测如下特殊系统事件 定时器 信号事件 描述符相关事件 进程相关事件 端口匹配相关事件 自定义的事件，并由你来触发 分发资源也是GCD技术的一部分，要获取更多有关分发资源相关的信息，参见分发资源\n\n### [2.2.3 操作队列](#4)\n操作队列是cocoa环境的一种并发队列，由NSOperationQueueClass 实现，操作队列总是按照FIFO的方式去执行任务，操作队列考虑其他因素去影响执行队列的顺序，在这些因素中，优先考虑一个任务的执行是否是依赖于其他任务，你可以给自己的任务设置依赖关系，然后创建一个复杂的执行顺序图。 任务添加到操作队列中的，必须是NSOperation的子类，一个操作对象是一个OC类型的封装了你要执行的数据和任务的对象，由于NSOperation是一个抽象基类，所以你通常需要去自定义子类去执行你的任务，然而，Foundation Framework已经提供了一些相关的子类，你可以使用它们去执行任务。 操作的对象产生KVO通知，这个是非常有用的，当监视你的任务进度的时候，虽然任务执行通常是并发的，但是可以利用依赖是的任务有序。 关于更多操作队列的信息，参见操作队列\n\n## [2.3 异步编程技术](#3)\n在你开始考虑重新用并发编程的方式重新设计程序的时候，你最好先问下自己这么做是否必要，并发可以提高你代码的可响应性，去确保主线程能相应更多的用户事件，它同样可以提高你代码的性能，通过促进多核去执行更多的任务，但是它也同时带来了上层复杂性，从而使你的代码更加难调试。 由于它带来了复杂性，并发并不是一个在你程序开周期中考虑的特性，当把它嫁接到应用中。做对这件事需要你好好考虑你程序执行的任务以及向这些任务提交的数据结构。如果做错的话，你可能发现你的代码运行缓慢，甚至还不如从前，因此，在你开始程序设计的时候，你就应该考虑你要实现的目标和通过何种方式来达到它。 每个应用都包含有不同的要求和不同的任务需要它去执行，这不可能靠一个文档就告诉你，怎么去设计你的程序和管理任务，然而，下面几段可以给你提供一些指导，帮助你去在程序设计的时候做出好的选择。\n\n### [2.3.1 明确程序期望的表现](#4)\n在你决定是否要将并发引导到应用中的时候，你应当开始思考你的应用程序想要达到的一个什么表现。明白了应用要达到的表现之后，会给你是否使用并发提供一个参考。同样的，也会给你一些引入并发之后程序能获取的性能收益方面的启发。 首先、你需要列举应用程序所要执行的任务和数据结构之间的关系。开始，你可能通过点击一个菜单或者一个按钮开启一个任务并执行，这些任务可能是一些离散的任务，并有明确的开始和结束点。你还需要列举出应用程序可能执行的其他类型的任务，而不仅仅是用户行为相关的，比如说基于时间的一些任务 在你有了自己任务列表之后，开始把任务进行更加的分组集合，确保这些任务能够成功执行。在这个层面，你优先考虑的是那些数据或对象修改如何对应用状态进行修改的。你同样需要考虑不同任务之间的相互依赖关系，例如：如果一个任务牵涉到一个数组中所有对象的修改，对于其中一个数据的修改，会对其他数据产生任何影响。如果一个数据的修改，独立于其他的数据，那么这个时候你可以考虑使用并发去做提升性能，创建多个任务去做。\n\n### [2.3.2 单位工作的可执行因子](#4)\n在明白你程序执行的任务类型之后，你应该明白在什么地方去使用并发会有好处了。如果在一个任务中改变一个或者多个的顺序，会影响到执行结果。你应该还是需要考虑到使用串行的方式去执行这些任务，如果改变执行顺序之后，并不会影响到执行结果，你可以考虑将这些任务用并发的方式去做，在这俩种情形下，你定义可执行的单位工作，并让它们执行，这些工作单元，就成为你封装好的Block对象或者操作对象或者分发队列。 对于每个单独的可执行任务，并不需要过多的担心任务执行的数量，在最后，分到线程中总是会有开销，但是分发队列或者操作队列相比传统的线程开发还是有很多优势的，因此，执行一些单元工作使用操作队列还是要比直接操作线程要好很多，当然，你常常应该确保任务执行的性能和你开启的任务恰好如你所需，但是，任务并不是越小就越好。\n\n### [2.3.3 区分你需要什么队列](#4)\n此时，你的任务已经切割为一些可执行的单元，并且封装成了Block对象或者是操作对象，你需要去定义你要执行的队列以执行这些任务。对一个任务来讲，测试这些Block或者是操作任务，能够在队列中执行正确。 如果你使用Block去实现你的任务,你可以添加任务到串行或者并行的队列里，如果对顺序有要求的话，你只能添加到一个串行队列中，如果没有要求，根据你的要求，你可以添加的并行队列中，或者添加到多个队列中去。 如果你是用操作队列去执行任务，那么选择的队列并不对添加到里面的任务的配置感兴趣，如果要串行去执行任务，那么你需要给相关的任务设置依赖关系，依赖会阻止任务开始执行，直到它依赖的任务执行完成。\n\n### [2.3.4 提升执行效率的贴士](#4)\n在把任务分割为更小的任务并将他们添加到队列中后，这里还有一些使用队列提升程序性能的小Tips 如果内存考虑是一个因素的话，那么在任务里面直接计算。如果你的应用已经内存警告了，那么在任务中直接计算会比从内存中加载要快一些。运用在寄存器或者是该核上的内存计算，会比从主内存加载要快一些。当然，你也可以通过测试来选择哪种方案会好一些。 将串行的任务，可能的话改变为并发。如果一个任务由于共享资源必须串行去执行，可以考虑将共享资源移除使得可以并发执行，可以考虑把这些资源给每个客户都拷贝一份。 避免使用锁，操作队列和分发队列的支持在大多数情况下并不需要锁。做为取代，可以使用一个串行的队列或者使用依赖去保证顺序正确。 如果可能的话依赖系统框架，最好的方式去实现并发就是使用系统提供的框架，许多框架使用线程或者其他技术来实现并发，当定义你的任务的时候，看看系统框架中是否已经有方法或者函数能够实现并发，使用系统接口会提升你的效率，而且帮你做到更多的并发可能性。\n\n## [2.4 性能相关](#3)\n操作队列、分发队列、资源分发提供了一种执行并发更加容易的方式。但是这些技术并不保证提升程序的性能和可响应性。具体来讲，根据你的需要同时兼顾性能提升和不要影响到其他资源仍然是你自己需要衡量的一件事。举个例子来讲，尽管你创建了10000个任务并把他们都提交到操作队列中，这么干的话，肯定会导致你的程序分配潜在的大量内存，这个会导致增加调度和减少性能。 引入并发到你的程序中前--是使用队列还是线程，你需要根据程序当前的性能来设置一个参考的标准。在引入并发之后，也同样需要做个列表对性能方面的改变进行比较，来确保程序是真的性能提升了，如果引入并发并不能给性能带来大的提升，你应该考虑其他的性能工具来检测潜在的原因。 关于性能的介绍和可用的性能工具，参见性能概览。\n\n## [2.5 并发和其他技术](#3)\n将你的代码分解为模块任务是一种最好的提升应用并发的方式，但是这种设计方式并不是对每个应用每个情况都很适合，取决于你执行的任务，也可能存在其他的选择来提升程序的整体并发，下面的俩小节提供了其他的并发技术供你参考\n\n### [2.5.1 OpenGL和并发](#4)\n在OSX中，OpenGC技术是图形计算方便最基础和核心的技术，OpenGL是非常棒的计算大数据集合的一种技术，举个例子来讲，你可能使用OpenGL技术来给图片做像素级别的滤镜，或者用它来计算复杂的数学计算。换而言之，OpenGL可以用来计算大量数据集合是并行的。 尽管OpenGL在大量数据并行执行方面有着非常好的性能优势，但是它并不合适执行自定义的计算，在任务提交给GPU处理之前，有大量的准备工做，而且要将数据和其他必要的核心操作转换图形卡片。同样的，要想获取OpenGL的产生结果也需要偶很多其他的努力。因此，所有跟系统交互相关的任务不建议提交给OpenGL去执行，举个例子，你不应该用OpenGL去运算从文件中或者网络流中拿到的数据，取而代之的是，你要用OpenGL执行的任务，必然是自己已经持有的这样相对来讲传递给GPU运算更加独立。 更多关于OpenGL的只是，参见OpenGL开发指导。\n\n### [2.5.2 何时使用线程](#4)\n尽管操作队列和分发队列是执行并发任务的更优选择，但是它们不是万能的，取决于你的应用程序，这里仍然后一些情况是需要创建线程去开发的，如果你创建了自定义的线程，那么你要确保尽量少的开启线程，并且确保这些线程只执行特定的任务，而不去干别的事情。 线程仍然是一种较好的解决方案，当执行实时任务的时候，分发队列会确保尽快的去执行他们的任务，但是并不能实时的去开线程去做。如果你需要可预测的后台代码执行，那么线程仍是一种选择。 作为线程编程，你还是需要去使用线程，当必须和完全必要的时候，关于更多线程方面的知识，参见线程开发指导。\n\n# [3 操作队列](#2)\ncocoa的操作都是原生的对象封装的可执行异步任务。这些操作同时可提交给操作队列去执行，也可以直接自己执行。由于是基于OC的框架，那么操作可应用在IOS和OSX中。本章节将介绍如何去使用和定义操作。\n\n## [3.1 关于操作对象](#3)\n一个操作对象是一个NSOperation类的实例，你可以用它来封装你要执行的任务。NSOperation类本身是一个抽象基类。所以要想执行可用的任务，必须得使用它的子类。尽管是一个抽象类，它还是提供了一些有用的基本操作，而省去了你在自己定义的子类中去做的麻烦。此外，Foundation 框架还提供了俩个具体的子类，可以用它们来执行你的任务，下表列出了这俩个类，还有如何使用它们的介绍。 NSInvocationOperation ：这是一个基于你的类和要执行的Seletor的类，你可以在已经定义过这个任务的地方去调用它，然后执行异步操作。由于它并不要强制你去做继承，所以可以使用该类去实现一个更加动态的风格。 NSBlockOperation：这是一个执行block封装任务的操作类，因为它可以执行多个block。block任务执行任务使用了组的语法，当所有的相关的block执行完之后，这个block操作才被任务是执行完成 NSOperation：这是定义其他操作任务的基类，继承它给你自定义操作类带来了完成的并发控制以及实现。包含可以完全控制任务的执行能力和执行状态。 所有上述的操作对象都包含以下核心的特性 支持建立图形化的任务间相互依赖，这些依赖将会阻止任务开始，直到它依赖的任务完成之后。 支持可选的完成回调block。指的是当所有的执行任务结束之后的回调方法。 支持检测任务执行状态（使用KVO） 支持对操作顺序进行调整，并影响他们的执行顺序。 支持取消语义，也即允许你半路对任务执行终止操作。 操作对象是设计来帮助你提升程序的并发水平，操作也是一种不错的组织和包装你的应用为几个独立的分支的一种手段，作为取代提交一些任务给主线程的开发方式，可以将任务分割为一个或多个不同的操作，然后提交给队列，使相关的工作可以在一个或多个线程中去并发的执行。\n\n## [3.2 同时VS非同时操作](#3)\n尽管，你通常将任务添加到操作队列中，但是做这个并不是必须的。你也可以直接调用它的start方法去开始一个操作。但是执行这个操作，并不能保证你的操作同步的运行在你当前代码所在的线程中。那么NSOperation类的这个isConcurrent方法会告知你，当前运行的操作是同步还是异步的在你调用Start方法的线程中，默认情况下这个方法会返回NO，也就是说这个操作是在当前调用的线程中同步去执行的。 如果你想去实现一个异步执行的操作，也就是调度任务的线程和任务执行的线程是异步的。你需要写额外的代码去异步的开启它。举个例子，你可以创建一个独立的线程，调用一个系统的异步方法，去执行其他的事情以保证start函数的调用时异步去执行。 大多数的开发并不需要去实现一个并发操作对象，如果你总是将你的操作去添加到一个操作队列中，你并不需要实现这些并发操作，当你添加一个操作对象到操作队列中的时候，操作队列自己就会创建一个线程去执行你的操作，因此，将一个并不是异步的任务添加到操作队列中去，结果还是会以异步的方式去执行代码，去定义一个异步任务这种费力不讨好的工作，也只是你就是想创建异步执行任务，而不是将它添加到队列中去的时候才有必要。 关于更多有关异步任务的信息，参见设置任务去异步执行。\n\n## [3.3 创建一个NSInocationOperation对象](#3)\nNSInvocationOperation是NSOperation的具体子类，当它运行的时候，会执行它的selector里面，指派给它的任务。使用该类时，应该避免将大量的自定义的操作给每个任务。尤其是当你需要改变一个已经存在的应用程序和这些对象已经存在任务，还有很多必备要执行的任务时。你可以使用它来改变依赖环境的时候。举个例子，你可以使用一个Invocation对象来执行一个选择器，这个选择器是基于获取用户的输入信息动态的选择。 创建一个Invocation操作的步骤是很简单的，你可以创建并实例化一个该对象，然后传递需要的对象和selector去执行指定的代码，下面提供了俩个方法去举例说明这个操作步骤，taskWithData：方法创建一个操作对象，然后通过另外一个方法去执行任务。 \n```objc\n\n@implementation MyCustomClass \n\n- (NSOperation*)taskWithData:(id)data { \n\tNSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self \n\tselector:@selector(myTaskMethod:) \n\tobject:data]; \nreturn theOp;\n } // This is the method that does the actual work of the task. \n\n- (void)myTaskMethod:(id)data { // Perform the task. } \n@end\n```\n\n## [3.4 创建一个NSBlockOperation对象](#3)\nNSBlockOperation是NSOperation的具体子类，作为一个或者多个Block对象的封装器，这个类提供了对象层面的封装，而且它已经使用了操作分发队列，所以并不需要创建分发队列，但是你也可以使用其他的诸如操作任务的依赖、KVO通知或者其他特性，而这些特性是分发队列所没有的。 当你创建一个block操作的时候，在创建他的时候，你至少已经添加了一个block，你也可以在之后再添加更多的block进去。当执行NSBlockOperation对象的时间来临的时候，该对象会将它的所有block都提交给默认优先级的异步分发队列，然后这个对象等待它的block全部执行完，之后会把自己标记为isfinish。因此，你可以使用一个Block操作去监听一组任务的完成，非常像用一个线程去管理多个线程的结果。而不同之处在于block操作自己运行在一个分离的线程，而你的程序可以干其他的活儿，在这个block等待它的任务执行完成之前。 下面的代码介绍了如何去创建一个BlockOperation，这个Block没带参数且没有返回什么有意义的结果 NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{ NSLog(@\"Beginning operation.\\n\"); // Do some work. }]; 当创建一个block操作之后，你可以添加更多的block给它，通过 addExecutionBlock：方法，如果你想让添加的任务线性去执行，那么你必须直接将它提交给指定的串行队列中去。\n\n## [3.5 定义一个自定义的操作](#3)\n如果一个Block操作对象或者Invocation操作对象没法完全满足你的需求的时候，你可以考虑自己定义个继承自NSOperation的操作对象，NSOperation对象提供了一系列的继承点给所有的操作对象，这个类已经实现了大量的基础的函数或方法，满足那些依赖或者KVO的操作，然而，还是有一些地方需要你自己的自定义实现确保你的操作对象能够正确的执行，具体的工作量的大小取决于你要自定义的是一个同步操作对象还是异步操作对象。 定义个同步操作对象要比定义一个异步操作对象简单的多，对于一个同步操作对象来讲，所有你要做的工作就是实现main执行函数和响应取消操作事件。父类已经帮你做了所有其他该做的工作，而对于一个异步操作对象来将，你需要替换一些父类已经做过的工作，在你自己定义的操作对象上。下面的俩小节将介绍如何去实现这俩种不同的操作对象。\n\n### [3.5.1 执行main任务](#4)\n至少一个操作对象需要实现下面的函数 一个自定义的初始化函数 main 你需要自定义个初始化函数去初始化一个操作对象，以及一个自定义的main函数去执行任务，你也可以根据需要执行其他的函数，如下所示 自定义函数供你的main函数去调用 属性方法去访问数据 实现NSCoding协议去固化一个操作对象 下面的模板，展示了一个自定义的操作对象，下面的代码并不展示如何去实现取消方法，但是也实现了你通常要实现的方法，具体怎么取消任务，参见取消任务介绍，下面的初始化函数初始化了一个对象，携带一个数据参数并把它存到了类内部方便以后访问，main函数将会显式的去操作这个对象，在你的应用将结果返回给你之前。 \n```objc\n@interface MyNonConcurrentOperation : NSOperation\n@property id (strong) myData; \n-(id)initWithData:(id)data;\n@end \n@implementation MyNonConcurrentOperation \n- (id)initWithData:(id)data { \n\tif(self = [super init]) \n\tmyData = data;\n\treturn self; \n}\n\n-(void)main { \n\t@try {\n\t // Do some work on myData and report the results. \n\t} \n\t@catch(...)\n\t {\n\t  // Do not rethrow exceptions.\n\t  } \n\t} \n@end 更多的细节参见NSOperationSample\n```\n\n### [3.5.2 响应取消事件](#4)\n当一个操作开始执行的时候，它将持续执行任务直到结束或者任务被显式的取消掉，取消操作可能发生在任何时候，甚至是操作开始执行的时候，尽管NSOperation对象提供了一个方式供子类去使用，指出取消事件是完全必要的。如果一个操作完全结束了，那么也可以提供一个方式去清理之前分配的资源等等，所以，一个操作对象需要去检测是否已经取消了，然后就可以优雅的结束任务。 操作对象支持取消操作，你应该做的事情就是频繁的去检查是否任务已经被取消了，支持取消是非常重要的，对于你自定义的任务和系统给的那俩个子类操作对象来说，isCancel方法是非常轻量级的，可以频繁去访问而不会造成内存方面的空扰，当设计一个操作对象的时候，你可以在如下几个地方去访问iscancel 1、在你开始执行任务之前 2、在开启一个loop之前，或者是更加频繁的在每个循环之前 3、在你的每个可能导致任务退出的地方 下面的代码介绍了在main函数中如何去调用cancel，在这个例子中，iscancel在每次while loop前都会调用，使得任务可以快速的退出，且获取了一个定期的间隔。 \n```objc\n- (void)main { \n@try { BOOL isDone = NO; \nwhile (![self isCancelled] && !isDone) \n{ // Do some work and set isDone to YES when finished } } \n@catch(...) { // Do not rethrow exceptions. } } \n```\n尽管上面的代码，并不包含清理数据的工作，但是你自己的代码还是要保证资源被及时的释放。\n\n### [3.5.3 定义一个可并发执行的操作](#4)\n一个操作对象默认情况是按照同步的方式去执行任务，也就是说他们执行任务的线程也就是start调用的线程。因为操作队列会对操作任务提供开启的线程，因此，大多数的任务就会异步运行，然而，如果你计划手动去执行一个任务，而且还希望这个任务异步的去运行，你必须得采取一些手段来保证能够这么干，你需要把你的操作对象定义为一个可并发执行的操作对象。下面列出来的函数就是你需要重写的并发操作。 start：（必须重写）所有的自定义并发操作必须重写这个函数，从而替换之前这个函数的默认实现。要手动的执行一个操作，你就可以调用start函数，因此从，你对该方法的实现就是自定义操作对象的开启任务的节点，也就是你要提交你的任务到线程中去执行的节点，你的实现在任何时候都不应该去调用super start。 main：（可选的）这个函数通常用来实现与操作对象相关的任务。虽然你可以把执行任务的任务放到start中去执行，利用mian方法去执行任务会对你的任务开始和清理工作有好处。 isExecuting：（必须的） isFinish：（必须） 并发操作非常有必要向使用它的客户报告配置环境和执行状态，因此一个并发操作必须得包含执行的状态信息包括何时开始执行任务，何时结束任务，如果要报告状态，那么必须使用这些方法。 当别的线程在同时调用上述方法的时候，你必须得保证这些方法是安全的。同时，你也必须得实现KVO通知，以报告这些状态。 isConcurrent：（必须）区分一个操作是否是并发操作，重写该方法，并返回YES 本小节的剩余部分将展示一个MyOperationClass的例子，这个类列举了实现一个并发操作的基本函数，MyOperation 类将在它自己开启的线程中执行任务，而正在的执行任务将与操作类是不相干的，下面例子将的几点，就是你在定义一个并发操作时需要提供的一些基础函数。 下面的代码显示了部分MyOperation的接口和实现函数，这些实现包括isConcurrent、isExecuting，isFinish，等函数。其中isConcurrent函数非常简单，只需要返回YES去指明本操作是一个并发操作就可以了，isExecuting 和 isFinished 也比较简单，返回在类中存储的成员变量的值就可以了。 \n\n```objc\n@interface MyOperation : NSOperation \n{ \n\tBOOL executing;\n\tBOOL finished; \n}\n- (void)completeOperation;\n@end \n@implementation MyOperation \n- (id)init {\n self = [super init]; \n if (self) {\n  executing = NO; \n  finished = NO;\n   } \n return self; \n}\n- (BOOL)isConcurrent { return YES; } \n- (BOOL)isExecuting { return executing; } \n- (BOOL)isFinished { return finished; } \n@end\n```\n下面的方法展示了MyOperation的 start函数，下面的实现是一个start函数，执行任务至少要实现的内容。在这种情况下，start函数简单的开启一个新的线程，然后让这个线程去调用main函数。这个函数同样要更新executing成员变量，而且要对isExecuting关键路径产生KVO通知，当这些工作完成之后，就会离开函数，并去到新的线程中去执行任务。 \n```objc\n- (void)start { // Always check for cancellation before launching the task. \nif ([self isCancelled]) { // Must move the operation to the finished state if it is canceled. [self willChangeValueForKey:@\"isFinished\"]; \nfinished = YES; \n[self didChangeValueForKey:@\"isFinished\"]; return; }\n// If the operation is not canceled, begin executing the task. \n[self willChangeValueForKey:@\"isExecuting\"]; \n[NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil]; executing = YES; [self didChangeValueForKey:@\"isExecuting\"]; \n} \n```\n下面展示了MyOperation剩下的实现，在上面的代码已经知道 main函数将作为新的线程开启任务的节点，它将执行操作对象带来的任务，并且要执行completeOperation函数来说明任务已经结束，completeoperation函数将对isExecuting和isFinished关键路径发送KVO通知，来反应操作对象的状态已经改变。\n\n```objc\n- (void)main { \n\t@try { \n\t\t// Do the main work of the operation here. \n\t\t[self completeOperation]; \n\t} \n\t@catch(...) { \n\t// Do not rethrow exceptions.\n\t }\n} \n- (void)completeOperation { \n\t[self willChangeValueForKey:@\"isFinished\"]; \n\t[self willChangeValueForKey:@\"isExecuting\"]; \n\texecuting = NO; \n\tfinished = YES; \n\t[self didChangeValueForKey:@\"isExecuting\"]; \n\t[self didChangeValueForKey:@\"isFinished\"]; \n}\n```\n尽管是操作对象被取消掉了，你也应该发送KVO通知，来通知你的任务已经完成，当一个操作对象的执行时依赖其他操作对象的时候，它将检测isFinished状态，只有当它依赖的所有isfinished状态都变为YES的时候，如果无法发送isFinshed通知将会阻止其他依赖他的操作对象的执行。\n\n### [3.5.4 维护KVO的兼容](#4)\nNSOperation类是服从下列关键字的KVO isCanceled isConcurrent isExecuting isFinished isReady dependencies queuePriority completeBlock 如果你重写了start函数，和自定义了一些其他比较重要的函数，而不是单单重写main函数，你必须保证自定义的对象能够响应KVO，当重写start函数，其中你最需要关注的就是isExecuting和isFInished，这里有大量的方法会受到这俩个函数的影响。 如果你想实现支持依赖关系，以对其他一些操作对象的时候，你也可以重写isReady函数，并强制返回NO，直到你自定义的依赖关系满足。（如果你仍然想支持系统提供的依赖关系的时候，请保证调用super的函数）当你操作对象的isReady状态发生变化的时候，请发送KVO通知去报告这个状态，不过幸运的是，除非你去重写addDependency和removeDependency:，你并不需要担心KVO通知的发送。 虽然你可以发送其他关键字的KVO通知，但是通常你并不需要这么做，如果你想取消一个任务，你可以简单的调用cancel函数就好了。同样的，你也不需要去修改队列的优先级在操作对象上，最后，除非你的操作对象支持动态的修改isConcurrent，你也不需要发送KVO通知给isConcurrent关键路径。 如果要知道更多关于KVO的操作，请参见KVO编程指导。\n\n## [3.6 自定义一个操作对象的执行行为](#3)\n在添加一个操作对象到操作队列里面之前，需要将一个操作对象设置好，这些对操作对象设置的信息将会对所有的操作对象有效，不仅是自定义的操作对象，还包括系统定义的那俩个操作对象。\n\n### [3.6.1 设置依赖关系](#4)\n依赖是一种限制操作对象执行顺序的一种手段，一个操作对象的执行，必须得在它依赖的所有对象执行完成之后才能进行。也就是说，你可以创建简单的一对一的或者是负责的依赖关系树。 在俩个操作对象之间创建依赖关系，你可以使用addDependency：方法，这个方法可以在你传的目标对象和自己之间创建一个依赖关系。也就是说在目标对象没有执行完成之前，你的这个对象是不会执行的。依赖还不仅仅限制在一个操作队列中，因为是操作对象管理依赖关系，所以在不同的操作队列之中，依赖也是可以起到作用的。但是有一种情况是不允许的，那就是设置依赖环，这是一种语法错误，会导致任务永远得不到执行。 当操作对象所依赖的所有操作对象都执行完成之后，操作对象就变成ready状态，准备执行。（如果是你自己定义的操作对象 ，并自定义了isReady函数，那么准备状态就和你设置的条件有关系了）如果一个操作对象是在操作队列中，那么isReady状态的操作对象在任何时候都可能被执行，如果你计划手动去执行一个操作对象的话，那么可以调用他的start方法。 重要:你应当在将操作对象提交到操作队列之前就去设置依赖关系，如果在之后去设置依赖，也许将不会阻止该任务的执行。 依赖基于的是操作对象间在任何时候都可能发生变化的KVO通知，如果你自定义了操作对象的话，你需要自己去发送KVO通知，以防出现依赖方面的问题。关于更多KVO的信息，参考维护KVO兼容，关于更多设置依赖的信息，参考NSOperation 类\n\n### [3.6.2 改变操作对象的执行优先级](#4)\n对于添加到队列中的操作对象，是否能够执行，首先是受操作对象的isReady状态控制，其次是他们的优先级，是否准备好执行，是由操作对象的依赖对象是否执行完来限制的，但是这个优先级是操作对象的一个属性值，默认情况下，所有新创建的操作对象都是普通优先级，但是你可以增加或者是减少操作对象的优先级，通过setQueuePriority方法 优先级只对同一个队列中的操作对象起作用，如果你的应用有多个操作队列，不同队列中的操作对象的优先级是相互独立的，也就是说，在不同队列里面，存在低优先级的操作比高优先级的操作先执行。 优先级并不是依赖的替代，优先级决定的是那些在队列中已经是准备状态的操作对象的执行顺序，举个例子，如果一个队列中同时有高优先级和低优先级的操作对象准备好了，那么操作队列先执行高优先级的操作对象，然而，如果高优先级的没有准备好，但是低优先级的准备好了，那么将先执行低优先级的，如果你想阻止一个操作任务在另外一个操作对象执行完之后再执行，你需要使用依赖关系去 做\n\n### [3.6.3 改变依附线程的优先级](#4)\n在OSX 10.6及以后，设置一个操作对象所在的线程的优先级成为可能，系统的线程策略是依靠内核去管理，但是高优先级的线程将获得更高的执行机会，对一个操作对象，你可以显式的指定它的线程优先级，通过设置一个浮点型的数值，0-1.0之前。0是优先级最低、1是优先级最高。如果不显式设置的话，系统默认的线程优先级是0.5. 要设置线程优先级的话，你需要在讲操作对象添加到操作队列之前，调用setThreadPriority函数。当它的执行时间到来的时候，默认的start函数就会设置你之前指定的线程优先级来修改优先级。这个优先级只在你执行的main函数执行过程用有效。所有的其他代码包括你的完成回调，仍然是运行在默认的优先级下的。如果你自定义了一个并发的操作，那么你需要重写start函数，并手动去修改线程的优先级。\n\n### [3.6.4 设置一个完成后的回调block](#4)\n在OSX 10.6及以后，一个操作对象可以在它的所有任务执行完成之后去执行一个完成的block，你可以用这个完成的block执行任何与main函数执行的任务里面不相关的的block。举个例子，你可能需要告诉客户这个操作对象的任务都执行完成了，一个并发的操作对象可能会使用这个block去执行它最后的KVO通知 要设置一个完成block，你可以使用setCompleteBlock：函数，这个函数不需要传任何参数，也没有返回值。\n\n## [3.7 关于实现一个操作对象的一些Tips](#3)\n尽管一个操作对象可能非常容易去实现，但是有一些事情在你自定义的操作对象上还是要注意一下，下面的小段描述了这么几个方面。\n\n### [3.7.1 管理操作对象的内存](#4)\n下面的小段，描述了几个在操作对象中管理内存的关键元素，关于更多的OC的内存管理，参见内存管理开发指导。\n#### [3.7.1.1 避免依靠线程存储数据](#5)\n尽管大多是的操作都是在一个线程中执行的，在同步操作对象中，这个线程通常是由操作队列分配给它的，如果一个操作队列将线程分配给操作对象，那么你需要知道这个线程它是属于操作队列的，你不应该和你的操作对象有任何瓜葛，尤其是，你不应该有任何数据相关的在这个线程中，而这些数据并不是你创建和管理的数据，因为线程的生存和死亡是有操作队列或者系统来控制的，因此在线程间数据传递通过线程来传递将是不可靠，也是容易失败的。 在操作队列上，没有任何的理由可以使用线程存储数据，当你初始化一个操作对象，你应该提供给它所有执行任务需要的数据去做这件事，因此，操作对象要提供所有数据，所有来的、去的数据都应该存在操作对象上，知道任务结束或者应用不在需要它。\n\n#### [3.7.1.2 如果需要的话保持操作对象的引用](#5)\n因为操作对象是异步运行的，你不应该认为你可以创建或者忘记他们，它们也只是对象而已，也需要你去管理他们，尤其是你需要在它完成之后获取数据的情况下。 你需要保持对操作对象的引用，主要还有可能你再没有机会获取这个操作对象的引用的机会了，操作对象是执行很快的，在很多情况下，操作任务一旦添加到操作队列中，就会被执行，当你的代码获取到从操作队列中拿到的操作对象的时候，很可能，这个操作对象已经结束了，并从操作队列移除了，释放了。\n\n### [3.7.2 处理错误和异常](#4)\n由于操作对象在你的应用里面是完全独立的实例，因此有必要去处理那些异常和错误，在OSX 10.6及以后，默认的start的函数不在提供捕获异常。你自己的代码需要去直接的捕获和处理异常，如果需要也要检测错误代码并通知给应用程序，如果你替换了start函数，那么你的代码需要在程序离开底层线程之前就去处理这些异常。 你可能处理的错误可能有一下几种情况 检测UNIX errno 类型的错误 检测显式的由代码返回的错误 捕获来自你自己的代码和系统框架带来的异常 当一个操作对象没有准备好，start方法就开始执行的时候 当一个操作已经在执行或者执行完成了，或取消了，start函数被再次调用的。 当添加一个block任务，但是它已经被执行或者完成的。 当你准备从NSInvocationOperation对象获取数据，但是它已经被取消的情况。 如果你自定义的代码遇到异常或者错误，你需要提供操作步骤给你的应用去处理，Operation对象不会显式的把错误代码或者异常传递给你应用的其他地方，因此，如果对于应用程序是比较重要的信息，你需要提供相关必要的代码去处理这些错误。\n\n## [3.8 决定操作对象合适的数量，不要太多，也不要太少](#3)\n虽然可以给一个操作队列中，添加大量的操作对象，但是这么做，往往并不太好，像其他对象一样，创建NSOperation对象也是需要消耗内存，并且他们的执行也是需要开销的。如果你的每个任务都是很小的，而你又创建了成千上万个，你会发现你会消耗更多的时间在分发操作对象上，而不是在执行真正的任务，而如果你的设备已经内存不足时，你会发现成千上万的任务会严重影响程序的性能。 高效的应用操作对象的关键在于，在充分利用设备和执行一定数量的操作任务之间找到平衡点，尝试去找到你的设备执行任务的一个真正的数量值。举个例子，如果你的应用创建了100个操作对象去处理100个不同的值，那么你可以考虑使用10个操作对象，去处理10个值去代替。 同时，你也需要避免一次性的给操作队列中添加大量的任务，也要避免不停的给操作队列以比它处理速度更快的添加更多的任务，相比于一次泛哄式的添加任务，不如批量式的去添加，然后利用完成block回调去执行下一批次的任务。这样可以避免内存过多的消耗。 当然，创建操作对象的数量、以及没个操作对象需要执行的任务量，是由你的程序动态去管理的。你应该是用性能测试工具，例如Instruments去找到性能处理和速度的平衡点，关于Instruments 和其他性能工具的更多信息，参见性能。\n\n## [3.9 操作对象的执行](#3)\n最后，你的应用需要执行这些操作对象以真正的处理任务，在这一小节，你将学到就像你熟练的执行你的操作一样，去执行这些操作。\n\n### [3.9.1 添加操作对象到操作队列中](#4)\n到目前为止，最容易的执行操作的方式是使用操作队列，即NSOperationQueue类的实例，你的应用有责任去创建和维护这些操作队列。一个应用程序可以有任意数量的操作队列，但是实际上在同一时间有多少个操作会被执行还是有限制的，被系统调用的操作队列会根据可利用的CPU和系统的载入量来进行限制单位时间执行的操作对象，因此，创建更多的操作队列并不意味着可以执行更多的操作对象 就想创建其他的对象一样，在你的应用中创建操作队列\n```objc\nNSOperationQueue* aQueue = [[NSOperationQueue alloc] init];\n```\n添加一个操作对象到操作队列中，你可以使用addOperation方法，在OSX 10.6以后，你还可以添加操作对象组，通过\n```objc\naddOperations：waitUntilFinished：\n```\n方法，你也可以直接添加blocl对像到操作队列中（而不需要与一个操作对象关联），通过\n```objc\naddOperationWithBlock：\n```\n方法，上面的这些方法，队列都会入一个操作对象并通知队列去执行他们，在大多数情况下，操作对象将会被很快执行，但是有时候，操作队列也可能延迟执行操作对象，大概有这么几个原因，最普遍的就是，操作对象间可能有依赖关系，还有可能是操作队列自己可能被挂起，或者是操作队列执行操作任务的数量达到了上限。下面的代码展示了最基础的添加操作到操作队列的语法 \n```objc\n[aQueue addOperation:anOp]; // Add a single operation \n[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations \n[aQueue addOperationWithBlock:^{ /* Do something. */\n }];\n```\n 重要 千万不要在一个操作对象进入操作队列之后再去修改它，因为当操作在操作队列中等待执行的时候，它可能在任何时候去执行任务，改变它的依赖和数据，可能会起到坏的作用。如果你想知道一个操作对象的状态，请使用操作对象的属性 去获取。\n\n### [3.9.2 手动执行操作对象](#4)\n尽管操作队列对于运行操作对象已经很方便了，但是还是有一种可能不使用操作队列去执行一个操作对象，如果你选择手动去执行操作对象，那么有一些注意事项，最主要的是，操作对象必须得是ready，而且你需要用start函数去启动它。 一个操作对象如果不是ready状态的话不应该去执行，isReady函数被Operation对象的依赖关系封装到了上层，只有当它的依赖关系都清除的时候，一个操作才能够被执行、 当执行一个操作对象，应该去使用start函数去做。用这个函数而不是用main，是因为start函数会在执行之前执行一个安全检查，尤其是，默认的start函数还会产生KVO通知，以保证依赖关系能够正确进行，这个函数同时也避免当你的操作对象被取消的时候，再去执行，以及当操作对象没有准备好的时候就去调用导致的异常抛出 。 如果你的程序定义了并发的操作对象，你同时需要在启动任务之前考虑isConcurrent。当这个方法返回NO的时候，你就可以考虑是在当前线程中同步的执行还是创建一个新的子线程。然而，这些方法的检测完全取决于你。 下面展示了一个比较简单的，手动开启并发操作对象的一个例子。如果这个函数返回NO，你可以启动一个timer，在之后再去调用它。然后直到它返回YES之后，取消掉Timer。因为这种情况可能在操作对象被取消的时候发生。 \n```objc\n- (BOOL)performOperation:(NSOperation*)anOp { \n\tBOOL ranIt = NO; \n\tif ([anOp isReady] && ![anOp isCancelled]) { \n\t\tif (![anOp isConcurrent]) \n\t\t[anOp start]; \n\t\telse [NSThread detachNewThreadSelector:@selector(start) toTarget:anOp withObject:nil]; \n\t\tranIt = YES; \n\t}else if ([anOp isCancelled]){ \n\t\t// If it was canceled before it was started, // move the operation to the finished state. \n\t \t[self willChangeValueForKey:@\"isFinished\"]; \n\t \t[self willChangeValueForKey:@\"isExecuting\"];\n\t  \texecuting = NO; \n\t  \tfinished = YES; \n\t  \t[self didChangeValueForKey:@\"isExecuting\"]; \n\t  \t[self didChangeValueForKey:@\"isFinished\"]; \n\t  \t// Set ranIt to YES to prevent the operation from \n\t  \t// being passed to this method again in the future. \n\t  \tranIt = YES; \n\t} return ranIt; \n}\n```\n\n### [3.9.3 取消操作对象](#4)\n当将操作对象添加到操作队列里面的时候，一个操作对象的管理就交给了操作队列，也不能被移除了，唯一使操作对象出列的方法就是调用它的cancel函数，你也可以取消所有的操作对象，通过调用操作队列的cancelAllOperations 你可以在确保你不在需要操作对象的时候取消掉它。发出一个cancel命令，会将操作对象的关键路径变为canceled状态，这将阻止任务继续执行，由于canceled的操作对象也认为是完成的，那么依赖它的操作对象就可以移除依赖关系。然而，更多情况下，更常用的是取消所有操作独享，在某些重要的时候，比如应用退出、或者用户发出了取消指令，这比一个个取消要好很多。\n\n### [3.9.4 等待操作对象的完成](#4)\n为了获取最佳的性能，你应该尽可能的让操作对象并发执行，让系统去干更多的事情，在你执行操作对象任务的时候，如果创建一个操作对象的时候，同时希望获得了操作对象的结果，你可以使用waitUntilFinished：方法来阻塞代码继续执行，直到这个操作对象执行完成。通常来讲，这是最好的方式去避免你能帮到它的时候，阻塞当前线程也许是一个比较好的解决方法。但这也带来了更多的同步性，而限制了整体的可并发性。 你绝不允许在主线程中调用这个方法，你最好在子线程或者其他的线程操作中这么做，阻塞主线程将会降低程序的可响应性。 除了等待一个任务完成，你可以等待一个操作队列所有的任务执行完成，通过调用waitUntilAllOperationsAreFinished，当你等待一个操作队列任务完成的时候，避免在别的线程中添加任务给它，以防延长等待时间。\n\n### [3.9.5 挂起和恢复操作队列](#4)\n如果你想中途终止一个操作队列的话，你可以挂起相应的操作队列，使用setSuspended方法，挂起一个操作队列并不会导致正在执行的操作任务终止。它只是会阻止别的操作对象（操作队列中的）不去执行，你可能会在用户想暂停任务的时候挂起所有操作，因为用户还期望在某个时候恢复这些任务。","slug":"[译] ios并发编程指南","published":1,"updated":"2016-12-29T04:06:58.000Z","_id":"cix9ujtg6000e492wv9lummqo","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"#1\">并发编程指南</a></p>\n<a id=\"more\"></a>\n<p><img src=\"http://ock9zbzms.bkt.clouddn.com/translationconcurrency.png\" alt=\"\"></p>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a><a href=\"#1\">并发</a></h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a><a href=\"#2\">1 概述</a></h2><h3 id=\"1-1-并发的概念\"><a href=\"#1-1-并发的概念\" class=\"headerlink\" title=\"1.1 并发的概念\"></a><a href=\"#3\">1.1 并发的概念</a></h3><p>并发其实指的是多项任务在同一时间进行，随着多核CPU的普及以及发现任务只在某一核上不停的增加，软件开发者需要一种方式充分的利用多核系统。虽然诸如IOS、MacOS兼容多项程序同时执行，但是大多数的程序运行在后台，并且执行任务只需要很短的CPU时间。这是因为前台应用同时获取了用户的关注并且是设备处于忙的状态。如果一个程序有很多的任务需要处理，但是又只获得了很少的碎片CPU时间，那些额外的处理资源将被浪费。 在过去，在应用中引入并发要求创建一个或者多个额外的线程，遗憾的是，编写线程代码是一项非常有挑战性的事情，线程是一种‘低级’的工具，并且需要手动去管理，获取多少个线程是最优的，动态取决于当前的系统以及底层硬件的支持。实现一个完美的线程解决方案，变的极其困难或者说不可能实现。另外，采取添加线程的方式实现同步的机制，不仅给软件开发带来了复杂性和风险性，而且也并不能确保提升性能。 OSX和iOS采取了一种比传统的基于线程的系统和程序，更加异步的方式去执行并发任务。并不是直接去创建线程，应用需要做的是定义一些特殊的任务，然后让系统去执行它们，让操作系统去管理线程，程序获得了原生线程更强的伸缩性，而程序开发者也获得了更加简单更加高效的编程模型。 本文档就是描述这项技术和技艺，你应该使用这项技术来实现并发。这项技术同时使用于iOS和OSX。</p>\n<h2 id=\"1-2-文档的组织\"><a href=\"#1-2-文档的组织\" class=\"headerlink\" title=\"1.2 文档的组织\"></a><a href=\"#3\">1.2 文档的组织</a></h2><p>本文档包括以下章节<br>1、并发和程序设计——介绍异步程序设计的一些基本概念和异步的执行自定义任务的技术<br>2、操作队列——展示怎样用OC去组装和执行一个任务<br>3、分发队列——展示怎样在基于C的应用程序中去并发地执行任务<br>4、资源分发——展示如何异步的处理系统事件<br>5、从线程变成用迁移到新的技术——提供一些技术帮助从旧的线程变成迁移到新的变成技术 本文当同时也包括一些相关章节的专业术语的定义</p>\n<h2 id=\"1-3-一些专业名词\"><a href=\"#1-3-一些专业名词\" class=\"headerlink\" title=\"1.3 一些专业名词\"></a><a href=\"#3\">1.3 一些专业名词</a></h2><p>在开始讨论并发之前，非常有必要去定义一些相关的专业名词来避免混淆，一些开发UNIX或者早先开发OSX的程序员，可能会对任务，队列处理、线程有一些新的任务，本文档对这几个概念有如下定义<br>1、在本文中，线程专指一个分离的支线去执行一段代码，而在老的OSX中特指基于POSIX的API 2、在本文中，执行专指可执行的任务正在执行中，可能包裹着多个线程。<br>3、在本文中，任务专指一个需要被执行的抽象工作 关于完整的类似这些概念的定义，参见词汇定义</p>\n<h2 id=\"1-4-其他\"><a href=\"#1-4-其他\" class=\"headerlink\" title=\"1.4 其他\"></a><a href=\"#3\">1.4 其他</a></h2><p>本文档专注于如何在你的程序中实现并发编程，而不包括如何使用线程，如果你需要更多的有关线程开发的只是，请去参考线程编程指导</p>\n<h1 id=\"2-并发及程序设计\"><a href=\"#2-并发及程序设计\" class=\"headerlink\" title=\"2 并发及程序设计\"></a><a href=\"#2\">2 并发及程序设计</a></h1><h2 id=\"2-1-并发编程和程序设计\"><a href=\"#2-1-并发编程和程序设计\" class=\"headerlink\" title=\"2.1 并发编程和程序设计\"></a><a href=\"#3\">2.1 并发编程和程序设计</a></h2><p>在以前的计算机运行的时候，计算机单位时间最大执行数量的任务取决于CPU的时钟速度，但是随着技术的发展和中央处理器设计的更加紧凑，热量和物理因素开始限制中央处理器的最大时钟速度，所以，主板供应商也在寻找其他的方式去提升他们主板的总体性能，他们发现的解决方案是增加主板上的处理器个数，通过增加处理器个数，一个主板可以在单位时间内执行更多的任务，而并不需要去增加CPU的时钟速度，或是改变主板的大小或考虑热量参数，现在剩下的唯一问题就是如何去充分的利用这些多核。 为了利用这些多核，计算机需要程序设计者能够去同时执行多项任务，在当代，多核操作系统，如OSX或者IOS，可能有几百或者更多的程序在同时运行，所以根据时序安排程序在不同的中央处理器上变得成为可能，然而，大多数的时候，这些程序要么是系统守护进程，要么是那些消费很小处理时间的后台应用程序，取而代之的是，真正需要多核开发的是，独立的前台运行的程序更高效的获取更多核心。 传统的使应用获取多核的方式是创建多线程，然而，随着多核的增加，线程方案有一些问题，最大的问题是线程开发的方式对多核系统不具备很好的伸缩性，你不能仅靠创建更多的行程就能确保程序和处理器运行良好，你需要知道的是，如何高效的利用这些中央处理器。对于程序来讲，如何计算它自身是一件有挑战的事情，尽管你可以正确的管理这些线程，程序去管理这些线程也依然是一项挑战，去确保他们高效运行、确保他们不被别的线程干扰。 所以，总结这些问题，程序需要一种方式去充分应用多核，单个程序可伸缩的执行大量工作，而且这个解决方案需要足够简单，去面对单个处理器任务的任务增长，好消息是，苹果已经提供了解决方案对处理所有这些问题，本章节先睹为快，去看看这项技术的组成以及牛逼的设计，你可以使你的代码从中获益。</p>\n<h2 id=\"2-2-从线程开发中走出来\"><a href=\"#2-2-从线程开发中走出来\" class=\"headerlink\" title=\"2.2 从线程开发中走出来\"></a><a href=\"#3\">2.2 从线程开发中走出来</a></h2><p>尽管线程开发已经应用了多年，而且它们在某些地方还将有用武之地，但是它们并没有可伸缩的解决多核场景，如果你使用线程开发，那么创建一个可伸缩的解决方案的麻烦就落在你肩上了，开发者，你需要去动态的根据系统的多核个数去决定创建多少个线程，此外，你的应用将花费很多消耗在创建和管理这些线程本身的消耗上。 取代线程开发，OSX和IOS使用异步设计的方式解决并发问题，异步方法已经在操作系统中提供了很多年，而且一般都是应用在创建很耗时的任务上，如从磁盘读取文件。当调用的时候，一个异步任务开始在后台执行，并立即返回在任务执行完之前。通常，这项任务会调用一个后台线程，开始这项任务在该后台线程上，然后在任务完成的时候发送一个消息给调用者（通常使用回调的方式）。在过去，如果没有一个你需要的异步方法，你需要自己去写一个异步方法还需要创建自己的线程，但是现在，OSX和iOS提供技术，你可以不用自己去管理线程就可以异步执行任务。 一种开启异步任务的技术叫 GCD，一项将过去需要在你程序中自己写管理线程代码移交给系统去管理。所有你需要做的事情仅仅是创建任务，然后将任务提交给合适的系统的GCD队列。GCD去创建和管理这些线程，因为这些线程已经提交给系统去管理，GCD提供全套的任务管理和执行，比传统的线程管理更加高效。 操作队列是非常类似于分发队列的一种OC对象管理方式，你可以定义你想执行的任务，然后把他们扔到操作队列中，当执行这些安排好的任务时，类似于GCD，操作队列为你执行所有的管理。确保在系统长执行的高效且迅速。 下面的段落提供了更多的信息关于操作队列、分发队列、以及一些你可能在异步编程中用到的技术</p>\n<h3 id=\"2-2-1-分发队列\"><a href=\"#2-2-1-分发队列\" class=\"headerlink\" title=\"2.2.1 分发队列\"></a><a href=\"#4\">2.2.1 分发队列</a></h3><p>分发队列是一套C的机制，为可执行自定义任务。分发队列要么是串行的要么是并行的，但是通常都是按照FIFO的方式去调度任务，一个串行的队列，一次只能运行一个任务，只有等前一个任务完成之后，下个任务才能开启。作为对比，并行的队列可以同时开启尽可能多的任务而并不需要前面的任务执行完毕。 分发队列有下面几个好处 </p>\n<pre><code>1、提供了简单的直观的编程接口 \n2、提供了自动的和完全的线程池管理 \n3、任务执行速度提升 \n4、更多的内存方面的优化 \n5、他们不会增加内核的负载 \n6、不会导致队列死锁 \n7、伸缩性强（对多核系统来讲） \n8、串行队列提供了比过去线程同步更为优秀的一种选择 \n</code></pre><p>你提供给分发队列的任务必须是封装好的一个方法或者是一个Block对象，Block是一种具有C语言特性的，开始引进与OSX 10.6,IOS 4.0的一个新特性。但是相比C语言有一些别的好处。不同于在Block的语法区域定义Block对象，你通常在别的方法或者是函数中去定义，这样可以去捕获到别的方法或者函数中的变量，Block同样可以移动到他们的作用区域以外，拷贝到堆上，这通常发生在你将任务添加到一个分发队列上的时候，所有这些语法特性，使得通过添加少量代码就可以获得非常好的实现。 分发队列是GCD技术的一部分，也是C运行时的一部分，要想获取更多的有关分发队列相关的信息，请参见 分发队列，要获取更多关于Block的信息和他们的好处，参见Block 程序编程观点。</p>\n<h3 id=\"2-2-2-分发资源\"><a href=\"#2-2-2-分发资源\" class=\"headerlink\" title=\"2.2.2 分发资源\"></a><a href=\"#4\">2.2.2 分发资源</a></h3><p>分发资源是异步的处理系统分发资源的一种C语言机制，分发资源封装了一个特殊类型的系统事件，并将这个特殊的系统事件提交给一个特殊的Block对象，或者函数，当系统事件发生的时候，你可以使用分发资源去监测如下特殊系统事件 定时器 信号事件 描述符相关事件 进程相关事件 端口匹配相关事件 自定义的事件，并由你来触发 分发资源也是GCD技术的一部分，要获取更多有关分发资源相关的信息，参见分发资源</p>\n<h3 id=\"2-2-3-操作队列\"><a href=\"#2-2-3-操作队列\" class=\"headerlink\" title=\"2.2.3 操作队列\"></a><a href=\"#4\">2.2.3 操作队列</a></h3><p>操作队列是cocoa环境的一种并发队列，由NSOperationQueueClass 实现，操作队列总是按照FIFO的方式去执行任务，操作队列考虑其他因素去影响执行队列的顺序，在这些因素中，优先考虑一个任务的执行是否是依赖于其他任务，你可以给自己的任务设置依赖关系，然后创建一个复杂的执行顺序图。 任务添加到操作队列中的，必须是NSOperation的子类，一个操作对象是一个OC类型的封装了你要执行的数据和任务的对象，由于NSOperation是一个抽象基类，所以你通常需要去自定义子类去执行你的任务，然而，Foundation Framework已经提供了一些相关的子类，你可以使用它们去执行任务。 操作的对象产生KVO通知，这个是非常有用的，当监视你的任务进度的时候，虽然任务执行通常是并发的，但是可以利用依赖是的任务有序。 关于更多操作队列的信息，参见操作队列</p>\n<h2 id=\"2-3-异步编程技术\"><a href=\"#2-3-异步编程技术\" class=\"headerlink\" title=\"2.3 异步编程技术\"></a><a href=\"#3\">2.3 异步编程技术</a></h2><p>在你开始考虑重新用并发编程的方式重新设计程序的时候，你最好先问下自己这么做是否必要，并发可以提高你代码的可响应性，去确保主线程能相应更多的用户事件，它同样可以提高你代码的性能，通过促进多核去执行更多的任务，但是它也同时带来了上层复杂性，从而使你的代码更加难调试。 由于它带来了复杂性，并发并不是一个在你程序开周期中考虑的特性，当把它嫁接到应用中。做对这件事需要你好好考虑你程序执行的任务以及向这些任务提交的数据结构。如果做错的话，你可能发现你的代码运行缓慢，甚至还不如从前，因此，在你开始程序设计的时候，你就应该考虑你要实现的目标和通过何种方式来达到它。 每个应用都包含有不同的要求和不同的任务需要它去执行，这不可能靠一个文档就告诉你，怎么去设计你的程序和管理任务，然而，下面几段可以给你提供一些指导，帮助你去在程序设计的时候做出好的选择。</p>\n<h3 id=\"2-3-1-明确程序期望的表现\"><a href=\"#2-3-1-明确程序期望的表现\" class=\"headerlink\" title=\"2.3.1 明确程序期望的表现\"></a><a href=\"#4\">2.3.1 明确程序期望的表现</a></h3><p>在你决定是否要将并发引导到应用中的时候，你应当开始思考你的应用程序想要达到的一个什么表现。明白了应用要达到的表现之后，会给你是否使用并发提供一个参考。同样的，也会给你一些引入并发之后程序能获取的性能收益方面的启发。 首先、你需要列举应用程序所要执行的任务和数据结构之间的关系。开始，你可能通过点击一个菜单或者一个按钮开启一个任务并执行，这些任务可能是一些离散的任务，并有明确的开始和结束点。你还需要列举出应用程序可能执行的其他类型的任务，而不仅仅是用户行为相关的，比如说基于时间的一些任务 在你有了自己任务列表之后，开始把任务进行更加的分组集合，确保这些任务能够成功执行。在这个层面，你优先考虑的是那些数据或对象修改如何对应用状态进行修改的。你同样需要考虑不同任务之间的相互依赖关系，例如：如果一个任务牵涉到一个数组中所有对象的修改，对于其中一个数据的修改，会对其他数据产生任何影响。如果一个数据的修改，独立于其他的数据，那么这个时候你可以考虑使用并发去做提升性能，创建多个任务去做。</p>\n<h3 id=\"2-3-2-单位工作的可执行因子\"><a href=\"#2-3-2-单位工作的可执行因子\" class=\"headerlink\" title=\"2.3.2 单位工作的可执行因子\"></a><a href=\"#4\">2.3.2 单位工作的可执行因子</a></h3><p>在明白你程序执行的任务类型之后，你应该明白在什么地方去使用并发会有好处了。如果在一个任务中改变一个或者多个的顺序，会影响到执行结果。你应该还是需要考虑到使用串行的方式去执行这些任务，如果改变执行顺序之后，并不会影响到执行结果，你可以考虑将这些任务用并发的方式去做，在这俩种情形下，你定义可执行的单位工作，并让它们执行，这些工作单元，就成为你封装好的Block对象或者操作对象或者分发队列。 对于每个单独的可执行任务，并不需要过多的担心任务执行的数量，在最后，分到线程中总是会有开销，但是分发队列或者操作队列相比传统的线程开发还是有很多优势的，因此，执行一些单元工作使用操作队列还是要比直接操作线程要好很多，当然，你常常应该确保任务执行的性能和你开启的任务恰好如你所需，但是，任务并不是越小就越好。</p>\n<h3 id=\"2-3-3-区分你需要什么队列\"><a href=\"#2-3-3-区分你需要什么队列\" class=\"headerlink\" title=\"2.3.3 区分你需要什么队列\"></a><a href=\"#4\">2.3.3 区分你需要什么队列</a></h3><p>此时，你的任务已经切割为一些可执行的单元，并且封装成了Block对象或者是操作对象，你需要去定义你要执行的队列以执行这些任务。对一个任务来讲，测试这些Block或者是操作任务，能够在队列中执行正确。 如果你使用Block去实现你的任务,你可以添加任务到串行或者并行的队列里，如果对顺序有要求的话，你只能添加到一个串行队列中，如果没有要求，根据你的要求，你可以添加的并行队列中，或者添加到多个队列中去。 如果你是用操作队列去执行任务，那么选择的队列并不对添加到里面的任务的配置感兴趣，如果要串行去执行任务，那么你需要给相关的任务设置依赖关系，依赖会阻止任务开始执行，直到它依赖的任务执行完成。</p>\n<h3 id=\"2-3-4-提升执行效率的贴士\"><a href=\"#2-3-4-提升执行效率的贴士\" class=\"headerlink\" title=\"2.3.4 提升执行效率的贴士\"></a><a href=\"#4\">2.3.4 提升执行效率的贴士</a></h3><p>在把任务分割为更小的任务并将他们添加到队列中后，这里还有一些使用队列提升程序性能的小Tips 如果内存考虑是一个因素的话，那么在任务里面直接计算。如果你的应用已经内存警告了，那么在任务中直接计算会比从内存中加载要快一些。运用在寄存器或者是该核上的内存计算，会比从主内存加载要快一些。当然，你也可以通过测试来选择哪种方案会好一些。 将串行的任务，可能的话改变为并发。如果一个任务由于共享资源必须串行去执行，可以考虑将共享资源移除使得可以并发执行，可以考虑把这些资源给每个客户都拷贝一份。 避免使用锁，操作队列和分发队列的支持在大多数情况下并不需要锁。做为取代，可以使用一个串行的队列或者使用依赖去保证顺序正确。 如果可能的话依赖系统框架，最好的方式去实现并发就是使用系统提供的框架，许多框架使用线程或者其他技术来实现并发，当定义你的任务的时候，看看系统框架中是否已经有方法或者函数能够实现并发，使用系统接口会提升你的效率，而且帮你做到更多的并发可能性。</p>\n<h2 id=\"2-4-性能相关\"><a href=\"#2-4-性能相关\" class=\"headerlink\" title=\"2.4 性能相关\"></a><a href=\"#3\">2.4 性能相关</a></h2><p>操作队列、分发队列、资源分发提供了一种执行并发更加容易的方式。但是这些技术并不保证提升程序的性能和可响应性。具体来讲，根据你的需要同时兼顾性能提升和不要影响到其他资源仍然是你自己需要衡量的一件事。举个例子来讲，尽管你创建了10000个任务并把他们都提交到操作队列中，这么干的话，肯定会导致你的程序分配潜在的大量内存，这个会导致增加调度和减少性能。 引入并发到你的程序中前–是使用队列还是线程，你需要根据程序当前的性能来设置一个参考的标准。在引入并发之后，也同样需要做个列表对性能方面的改变进行比较，来确保程序是真的性能提升了，如果引入并发并不能给性能带来大的提升，你应该考虑其他的性能工具来检测潜在的原因。 关于性能的介绍和可用的性能工具，参见性能概览。</p>\n<h2 id=\"2-5-并发和其他技术\"><a href=\"#2-5-并发和其他技术\" class=\"headerlink\" title=\"2.5 并发和其他技术\"></a><a href=\"#3\">2.5 并发和其他技术</a></h2><p>将你的代码分解为模块任务是一种最好的提升应用并发的方式，但是这种设计方式并不是对每个应用每个情况都很适合，取决于你执行的任务，也可能存在其他的选择来提升程序的整体并发，下面的俩小节提供了其他的并发技术供你参考</p>\n<h3 id=\"2-5-1-OpenGL和并发\"><a href=\"#2-5-1-OpenGL和并发\" class=\"headerlink\" title=\"2.5.1 OpenGL和并发\"></a><a href=\"#4\">2.5.1 OpenGL和并发</a></h3><p>在OSX中，OpenGC技术是图形计算方便最基础和核心的技术，OpenGL是非常棒的计算大数据集合的一种技术，举个例子来讲，你可能使用OpenGL技术来给图片做像素级别的滤镜，或者用它来计算复杂的数学计算。换而言之，OpenGL可以用来计算大量数据集合是并行的。 尽管OpenGL在大量数据并行执行方面有着非常好的性能优势，但是它并不合适执行自定义的计算，在任务提交给GPU处理之前，有大量的准备工做，而且要将数据和其他必要的核心操作转换图形卡片。同样的，要想获取OpenGL的产生结果也需要偶很多其他的努力。因此，所有跟系统交互相关的任务不建议提交给OpenGL去执行，举个例子，你不应该用OpenGL去运算从文件中或者网络流中拿到的数据，取而代之的是，你要用OpenGL执行的任务，必然是自己已经持有的这样相对来讲传递给GPU运算更加独立。 更多关于OpenGL的只是，参见OpenGL开发指导。</p>\n<h3 id=\"2-5-2-何时使用线程\"><a href=\"#2-5-2-何时使用线程\" class=\"headerlink\" title=\"2.5.2 何时使用线程\"></a><a href=\"#4\">2.5.2 何时使用线程</a></h3><p>尽管操作队列和分发队列是执行并发任务的更优选择，但是它们不是万能的，取决于你的应用程序，这里仍然后一些情况是需要创建线程去开发的，如果你创建了自定义的线程，那么你要确保尽量少的开启线程，并且确保这些线程只执行特定的任务，而不去干别的事情。 线程仍然是一种较好的解决方案，当执行实时任务的时候，分发队列会确保尽快的去执行他们的任务，但是并不能实时的去开线程去做。如果你需要可预测的后台代码执行，那么线程仍是一种选择。 作为线程编程，你还是需要去使用线程，当必须和完全必要的时候，关于更多线程方面的知识，参见线程开发指导。</p>\n<h1 id=\"3-操作队列\"><a href=\"#3-操作队列\" class=\"headerlink\" title=\"3 操作队列\"></a><a href=\"#2\">3 操作队列</a></h1><p>cocoa的操作都是原生的对象封装的可执行异步任务。这些操作同时可提交给操作队列去执行，也可以直接自己执行。由于是基于OC的框架，那么操作可应用在IOS和OSX中。本章节将介绍如何去使用和定义操作。</p>\n<h2 id=\"3-1-关于操作对象\"><a href=\"#3-1-关于操作对象\" class=\"headerlink\" title=\"3.1 关于操作对象\"></a><a href=\"#3\">3.1 关于操作对象</a></h2><p>一个操作对象是一个NSOperation类的实例，你可以用它来封装你要执行的任务。NSOperation类本身是一个抽象基类。所以要想执行可用的任务，必须得使用它的子类。尽管是一个抽象类，它还是提供了一些有用的基本操作，而省去了你在自己定义的子类中去做的麻烦。此外，Foundation 框架还提供了俩个具体的子类，可以用它们来执行你的任务，下表列出了这俩个类，还有如何使用它们的介绍。 NSInvocationOperation ：这是一个基于你的类和要执行的Seletor的类，你可以在已经定义过这个任务的地方去调用它，然后执行异步操作。由于它并不要强制你去做继承，所以可以使用该类去实现一个更加动态的风格。 NSBlockOperation：这是一个执行block封装任务的操作类，因为它可以执行多个block。block任务执行任务使用了组的语法，当所有的相关的block执行完之后，这个block操作才被任务是执行完成 NSOperation：这是定义其他操作任务的基类，继承它给你自定义操作类带来了完成的并发控制以及实现。包含可以完全控制任务的执行能力和执行状态。 所有上述的操作对象都包含以下核心的特性 支持建立图形化的任务间相互依赖，这些依赖将会阻止任务开始，直到它依赖的任务完成之后。 支持可选的完成回调block。指的是当所有的执行任务结束之后的回调方法。 支持检测任务执行状态（使用KVO） 支持对操作顺序进行调整，并影响他们的执行顺序。 支持取消语义，也即允许你半路对任务执行终止操作。 操作对象是设计来帮助你提升程序的并发水平，操作也是一种不错的组织和包装你的应用为几个独立的分支的一种手段，作为取代提交一些任务给主线程的开发方式，可以将任务分割为一个或多个不同的操作，然后提交给队列，使相关的工作可以在一个或多个线程中去并发的执行。</p>\n<h2 id=\"3-2-同时VS非同时操作\"><a href=\"#3-2-同时VS非同时操作\" class=\"headerlink\" title=\"3.2 同时VS非同时操作\"></a><a href=\"#3\">3.2 同时VS非同时操作</a></h2><p>尽管，你通常将任务添加到操作队列中，但是做这个并不是必须的。你也可以直接调用它的start方法去开始一个操作。但是执行这个操作，并不能保证你的操作同步的运行在你当前代码所在的线程中。那么NSOperation类的这个isConcurrent方法会告知你，当前运行的操作是同步还是异步的在你调用Start方法的线程中，默认情况下这个方法会返回NO，也就是说这个操作是在当前调用的线程中同步去执行的。 如果你想去实现一个异步执行的操作，也就是调度任务的线程和任务执行的线程是异步的。你需要写额外的代码去异步的开启它。举个例子，你可以创建一个独立的线程，调用一个系统的异步方法，去执行其他的事情以保证start函数的调用时异步去执行。 大多数的开发并不需要去实现一个并发操作对象，如果你总是将你的操作去添加到一个操作队列中，你并不需要实现这些并发操作，当你添加一个操作对象到操作队列中的时候，操作队列自己就会创建一个线程去执行你的操作，因此，将一个并不是异步的任务添加到操作队列中去，结果还是会以异步的方式去执行代码，去定义一个异步任务这种费力不讨好的工作，也只是你就是想创建异步执行任务，而不是将它添加到队列中去的时候才有必要。 关于更多有关异步任务的信息，参见设置任务去异步执行。</p>\n<h2 id=\"3-3-创建一个NSInocationOperation对象\"><a href=\"#3-3-创建一个NSInocationOperation对象\" class=\"headerlink\" title=\"3.3 创建一个NSInocationOperation对象\"></a><a href=\"#3\">3.3 创建一个NSInocationOperation对象</a></h2><p>NSInvocationOperation是NSOperation的具体子类，当它运行的时候，会执行它的selector里面，指派给它的任务。使用该类时，应该避免将大量的自定义的操作给每个任务。尤其是当你需要改变一个已经存在的应用程序和这些对象已经存在任务，还有很多必备要执行的任务时。你可以使用它来改变依赖环境的时候。举个例子，你可以使用一个Invocation对象来执行一个选择器，这个选择器是基于获取用户的输入信息动态的选择。 创建一个Invocation操作的步骤是很简单的，你可以创建并实例化一个该对象，然后传递需要的对象和selector去执行指定的代码，下面提供了俩个方法去举例说明这个操作步骤，taskWithData：方法创建一个操作对象，然后通过另外一个方法去执行任务。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyCustomClass</span> </span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSOperation</span>*)taskWithData:(<span class=\"keyword\">id</span>)data &#123; </div><div class=\"line\">\t<span class=\"built_in\">NSInvocationOperation</span>* theOp = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> </div><div class=\"line\">\tselector:<span class=\"keyword\">@selector</span>(myTaskMethod:) </div><div class=\"line\">\tobject:data]; </div><div class=\"line\"><span class=\"keyword\">return</span> theOp;</div><div class=\"line\"> &#125; <span class=\"comment\">// This is the method that does the actual work of the task. </span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)myTaskMethod:(<span class=\"keyword\">id</span>)data &#123; <span class=\"comment\">// Perform the task. &#125; </span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"3-4-创建一个NSBlockOperation对象\"><a href=\"#3-4-创建一个NSBlockOperation对象\" class=\"headerlink\" title=\"3.4 创建一个NSBlockOperation对象\"></a><a href=\"#3\">3.4 创建一个NSBlockOperation对象</a></h2><p>NSBlockOperation是NSOperation的具体子类，作为一个或者多个Block对象的封装器，这个类提供了对象层面的封装，而且它已经使用了操作分发队列，所以并不需要创建分发队列，但是你也可以使用其他的诸如操作任务的依赖、KVO通知或者其他特性，而这些特性是分发队列所没有的。 当你创建一个block操作的时候，在创建他的时候，你至少已经添加了一个block，你也可以在之后再添加更多的block进去。当执行NSBlockOperation对象的时间来临的时候，该对象会将它的所有block都提交给默认优先级的异步分发队列，然后这个对象等待它的block全部执行完，之后会把自己标记为isfinish。因此，你可以使用一个Block操作去监听一组任务的完成，非常像用一个线程去管理多个线程的结果。而不同之处在于block操作自己运行在一个分离的线程，而你的程序可以干其他的活儿，在这个block等待它的任务执行完成之前。 下面的代码介绍了如何去创建一个BlockOperation，这个Block没带参数且没有返回什么有意义的结果 NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{ NSLog(@”Beginning operation.\\n”); // Do some work. }]; 当创建一个block操作之后，你可以添加更多的block给它，通过 addExecutionBlock：方法，如果你想让添加的任务线性去执行，那么你必须直接将它提交给指定的串行队列中去。</p>\n<h2 id=\"3-5-定义一个自定义的操作\"><a href=\"#3-5-定义一个自定义的操作\" class=\"headerlink\" title=\"3.5 定义一个自定义的操作\"></a><a href=\"#3\">3.5 定义一个自定义的操作</a></h2><p>如果一个Block操作对象或者Invocation操作对象没法完全满足你的需求的时候，你可以考虑自己定义个继承自NSOperation的操作对象，NSOperation对象提供了一系列的继承点给所有的操作对象，这个类已经实现了大量的基础的函数或方法，满足那些依赖或者KVO的操作，然而，还是有一些地方需要你自己的自定义实现确保你的操作对象能够正确的执行，具体的工作量的大小取决于你要自定义的是一个同步操作对象还是异步操作对象。 定义个同步操作对象要比定义一个异步操作对象简单的多，对于一个同步操作对象来讲，所有你要做的工作就是实现main执行函数和响应取消操作事件。父类已经帮你做了所有其他该做的工作，而对于一个异步操作对象来将，你需要替换一些父类已经做过的工作，在你自己定义的操作对象上。下面的俩小节将介绍如何去实现这俩种不同的操作对象。</p>\n<h3 id=\"3-5-1-执行main任务\"><a href=\"#3-5-1-执行main任务\" class=\"headerlink\" title=\"3.5.1 执行main任务\"></a><a href=\"#4\">3.5.1 执行main任务</a></h3><p>至少一个操作对象需要实现下面的函数 一个自定义的初始化函数 main 你需要自定义个初始化函数去初始化一个操作对象，以及一个自定义的main函数去执行任务，你也可以根据需要执行其他的函数，如下所示 自定义函数供你的main函数去调用 属性方法去访问数据 实现NSCoding协议去固化一个操作对象 下面的模板，展示了一个自定义的操作对象，下面的代码并不展示如何去实现取消方法，但是也实现了你通常要实现的方法，具体怎么取消任务，参见取消任务介绍，下面的初始化函数初始化了一个对象，携带一个数据参数并把它存到了类内部方便以后访问，main函数将会显式的去操作这个对象，在你的应用将结果返回给你之前。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyNonConcurrentOperation</span> : <span class=\"title\">NSOperation</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"keyword\">id</span> (<span class=\"keyword\">strong</span>) myData; </div><div class=\"line\">-(<span class=\"keyword\">id</span>)initWithData:(<span class=\"keyword\">id</span>)data;</div><div class=\"line\"><span class=\"keyword\">@end</span> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyNonConcurrentOperation</span> </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithData:(<span class=\"keyword\">id</span>)data &#123; </div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) </div><div class=\"line\">\tmyData = data;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)main &#123; </div><div class=\"line\">\t<span class=\"keyword\">@try</span> &#123;</div><div class=\"line\">\t <span class=\"comment\">// Do some work on myData and report the results. </span></div><div class=\"line\">\t&#125; </div><div class=\"line\">\t<span class=\"keyword\">@catch</span>(...)</div><div class=\"line\">\t &#123;</div><div class=\"line\">\t  <span class=\"comment\">// Do not rethrow exceptions.</span></div><div class=\"line\">\t  &#125; </div><div class=\"line\">\t&#125; </div><div class=\"line\"><span class=\"keyword\">@end</span> 更多的细节参见<span class=\"built_in\">NSOperationSample</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5-2-响应取消事件\"><a href=\"#3-5-2-响应取消事件\" class=\"headerlink\" title=\"3.5.2 响应取消事件\"></a><a href=\"#4\">3.5.2 响应取消事件</a></h3><p>当一个操作开始执行的时候，它将持续执行任务直到结束或者任务被显式的取消掉，取消操作可能发生在任何时候，甚至是操作开始执行的时候，尽管NSOperation对象提供了一个方式供子类去使用，指出取消事件是完全必要的。如果一个操作完全结束了，那么也可以提供一个方式去清理之前分配的资源等等，所以，一个操作对象需要去检测是否已经取消了，然后就可以优雅的结束任务。 操作对象支持取消操作，你应该做的事情就是频繁的去检查是否任务已经被取消了，支持取消是非常重要的，对于你自定义的任务和系统给的那俩个子类操作对象来说，isCancel方法是非常轻量级的，可以频繁去访问而不会造成内存方面的空扰，当设计一个操作对象的时候，你可以在如下几个地方去访问iscancel 1、在你开始执行任务之前 2、在开启一个loop之前，或者是更加频繁的在每个循环之前 3、在你的每个可能导致任务退出的地方 下面的代码介绍了在main函数中如何去调用cancel，在这个例子中，iscancel在每次while loop前都会调用，使得任务可以快速的退出，且获取了一个定期的间隔。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123; </div><div class=\"line\"><span class=\"keyword\">@try</span> &#123; <span class=\"built_in\">BOOL</span> isDone = <span class=\"literal\">NO</span>; </div><div class=\"line\"><span class=\"keyword\">while</span> (![<span class=\"keyword\">self</span> isCancelled] &amp;&amp; !isDone) </div><div class=\"line\">&#123; <span class=\"comment\">// Do some work and set isDone to YES when finished &#125; &#125; </span></div><div class=\"line\"><span class=\"keyword\">@catch</span>(...) &#123; <span class=\"comment\">// Do not rethrow exceptions. &#125; &#125;</span></div></pre></td></tr></table></figure></p>\n<p>尽管上面的代码，并不包含清理数据的工作，但是你自己的代码还是要保证资源被及时的释放。</p>\n<h3 id=\"3-5-3-定义一个可并发执行的操作\"><a href=\"#3-5-3-定义一个可并发执行的操作\" class=\"headerlink\" title=\"3.5.3 定义一个可并发执行的操作\"></a><a href=\"#4\">3.5.3 定义一个可并发执行的操作</a></h3><p>一个操作对象默认情况是按照同步的方式去执行任务，也就是说他们执行任务的线程也就是start调用的线程。因为操作队列会对操作任务提供开启的线程，因此，大多数的任务就会异步运行，然而，如果你计划手动去执行一个任务，而且还希望这个任务异步的去运行，你必须得采取一些手段来保证能够这么干，你需要把你的操作对象定义为一个可并发执行的操作对象。下面列出来的函数就是你需要重写的并发操作。 start：（必须重写）所有的自定义并发操作必须重写这个函数，从而替换之前这个函数的默认实现。要手动的执行一个操作，你就可以调用start函数，因此从，你对该方法的实现就是自定义操作对象的开启任务的节点，也就是你要提交你的任务到线程中去执行的节点，你的实现在任何时候都不应该去调用super start。 main：（可选的）这个函数通常用来实现与操作对象相关的任务。虽然你可以把执行任务的任务放到start中去执行，利用mian方法去执行任务会对你的任务开始和清理工作有好处。 isExecuting：（必须的） isFinish：（必须） 并发操作非常有必要向使用它的客户报告配置环境和执行状态，因此一个并发操作必须得包含执行的状态信息包括何时开始执行任务，何时结束任务，如果要报告状态，那么必须使用这些方法。 当别的线程在同时调用上述方法的时候，你必须得保证这些方法是安全的。同时，你也必须得实现KVO通知，以报告这些状态。 isConcurrent：（必须）区分一个操作是否是并发操作，重写该方法，并返回YES 本小节的剩余部分将展示一个MyOperationClass的例子，这个类列举了实现一个并发操作的基本函数，MyOperation 类将在它自己开启的线程中执行任务，而正在的执行任务将与操作类是不相干的，下面例子将的几点，就是你在定义一个并发操作时需要提供的一些基础函数。 下面的代码显示了部分MyOperation的接口和实现函数，这些实现包括isConcurrent、isExecuting，isFinish，等函数。其中isConcurrent函数非常简单，只需要返回YES去指明本操作是一个并发操作就可以了，isExecuting 和 isFinished 也比较简单，返回在类中存储的成员变量的值就可以了。 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyOperation</span> : <span class=\"title\">NSOperation</span> </span></div><div class=\"line\">&#123; </div><div class=\"line\">\t<span class=\"built_in\">BOOL</span> executing;</div><div class=\"line\">\t<span class=\"built_in\">BOOL</span> finished; </div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)completeOperation;</div><div class=\"line\"><span class=\"keyword\">@end</span> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyOperation</span> </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</div><div class=\"line\"> <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]; </div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">  executing = <span class=\"literal\">NO</span>; </div><div class=\"line\">  finished = <span class=\"literal\">NO</span>;</div><div class=\"line\">   &#125; </div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>; </div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isConcurrent &#123; <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>; &#125; </div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isExecuting &#123; <span class=\"keyword\">return</span> executing; &#125; </div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFinished &#123; <span class=\"keyword\">return</span> finished; &#125; </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>下面的方法展示了MyOperation的 start函数，下面的实现是一个start函数，执行任务至少要实现的内容。在这种情况下，start函数简单的开启一个新的线程，然后让这个线程去调用main函数。这个函数同样要更新executing成员变量，而且要对isExecuting关键路径产生KVO通知，当这些工作完成之后，就会离开函数，并去到新的线程中去执行任务。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123; <span class=\"comment\">// Always check for cancellation before launching the task. </span></div><div class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123; <span class=\"comment\">// Must move the operation to the finished state if it is canceled. [self willChangeValueForKey:@\"isFinished\"]; </span></div><div class=\"line\">finished = <span class=\"literal\">YES</span>; </div><div class=\"line\">[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; <span class=\"keyword\">return</span>; &#125;</div><div class=\"line\"><span class=\"comment\">// If the operation is not canceled, begin executing the task. </span></div><div class=\"line\">[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(main) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>]; executing = <span class=\"literal\">YES</span>; [<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面展示了MyOperation剩下的实现，在上面的代码已经知道 main函数将作为新的线程开启任务的节点，它将执行操作对象带来的任务，并且要执行completeOperation函数来说明任务已经结束，completeoperation函数将对isExecuting和isFinished关键路径发送KVO通知，来反应操作对象的状态已经改变。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123; </div><div class=\"line\">\t<span class=\"keyword\">@try</span> &#123; </div><div class=\"line\">\t\t<span class=\"comment\">// Do the main work of the operation here. </span></div><div class=\"line\">\t\t[<span class=\"keyword\">self</span> completeOperation]; </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t<span class=\"keyword\">@catch</span>(...) &#123; </div><div class=\"line\">\t<span class=\"comment\">// Do not rethrow exceptions.</span></div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125; </div><div class=\"line\">- (<span class=\"keyword\">void</span>)completeOperation &#123; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">\texecuting = <span class=\"literal\">NO</span>; </div><div class=\"line\">\tfinished = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尽管是操作对象被取消掉了，你也应该发送KVO通知，来通知你的任务已经完成，当一个操作对象的执行时依赖其他操作对象的时候，它将检测isFinished状态，只有当它依赖的所有isfinished状态都变为YES的时候，如果无法发送isFinshed通知将会阻止其他依赖他的操作对象的执行。</p>\n<h3 id=\"3-5-4-维护KVO的兼容\"><a href=\"#3-5-4-维护KVO的兼容\" class=\"headerlink\" title=\"3.5.4 维护KVO的兼容\"></a><a href=\"#4\">3.5.4 维护KVO的兼容</a></h3><p>NSOperation类是服从下列关键字的KVO isCanceled isConcurrent isExecuting isFinished isReady dependencies queuePriority completeBlock 如果你重写了start函数，和自定义了一些其他比较重要的函数，而不是单单重写main函数，你必须保证自定义的对象能够响应KVO，当重写start函数，其中你最需要关注的就是isExecuting和isFInished，这里有大量的方法会受到这俩个函数的影响。 如果你想实现支持依赖关系，以对其他一些操作对象的时候，你也可以重写isReady函数，并强制返回NO，直到你自定义的依赖关系满足。（如果你仍然想支持系统提供的依赖关系的时候，请保证调用super的函数）当你操作对象的isReady状态发生变化的时候，请发送KVO通知去报告这个状态，不过幸运的是，除非你去重写addDependency和removeDependency:，你并不需要担心KVO通知的发送。 虽然你可以发送其他关键字的KVO通知，但是通常你并不需要这么做，如果你想取消一个任务，你可以简单的调用cancel函数就好了。同样的，你也不需要去修改队列的优先级在操作对象上，最后，除非你的操作对象支持动态的修改isConcurrent，你也不需要发送KVO通知给isConcurrent关键路径。 如果要知道更多关于KVO的操作，请参见KVO编程指导。</p>\n<h2 id=\"3-6-自定义一个操作对象的执行行为\"><a href=\"#3-6-自定义一个操作对象的执行行为\" class=\"headerlink\" title=\"3.6 自定义一个操作对象的执行行为\"></a><a href=\"#3\">3.6 自定义一个操作对象的执行行为</a></h2><p>在添加一个操作对象到操作队列里面之前，需要将一个操作对象设置好，这些对操作对象设置的信息将会对所有的操作对象有效，不仅是自定义的操作对象，还包括系统定义的那俩个操作对象。</p>\n<h3 id=\"3-6-1-设置依赖关系\"><a href=\"#3-6-1-设置依赖关系\" class=\"headerlink\" title=\"3.6.1 设置依赖关系\"></a><a href=\"#4\">3.6.1 设置依赖关系</a></h3><p>依赖是一种限制操作对象执行顺序的一种手段，一个操作对象的执行，必须得在它依赖的所有对象执行完成之后才能进行。也就是说，你可以创建简单的一对一的或者是负责的依赖关系树。 在俩个操作对象之间创建依赖关系，你可以使用addDependency：方法，这个方法可以在你传的目标对象和自己之间创建一个依赖关系。也就是说在目标对象没有执行完成之前，你的这个对象是不会执行的。依赖还不仅仅限制在一个操作队列中，因为是操作对象管理依赖关系，所以在不同的操作队列之中，依赖也是可以起到作用的。但是有一种情况是不允许的，那就是设置依赖环，这是一种语法错误，会导致任务永远得不到执行。 当操作对象所依赖的所有操作对象都执行完成之后，操作对象就变成ready状态，准备执行。（如果是你自己定义的操作对象 ，并自定义了isReady函数，那么准备状态就和你设置的条件有关系了）如果一个操作对象是在操作队列中，那么isReady状态的操作对象在任何时候都可能被执行，如果你计划手动去执行一个操作对象的话，那么可以调用他的start方法。 重要:你应当在将操作对象提交到操作队列之前就去设置依赖关系，如果在之后去设置依赖，也许将不会阻止该任务的执行。 依赖基于的是操作对象间在任何时候都可能发生变化的KVO通知，如果你自定义了操作对象的话，你需要自己去发送KVO通知，以防出现依赖方面的问题。关于更多KVO的信息，参考维护KVO兼容，关于更多设置依赖的信息，参考NSOperation 类</p>\n<h3 id=\"3-6-2-改变操作对象的执行优先级\"><a href=\"#3-6-2-改变操作对象的执行优先级\" class=\"headerlink\" title=\"3.6.2 改变操作对象的执行优先级\"></a><a href=\"#4\">3.6.2 改变操作对象的执行优先级</a></h3><p>对于添加到队列中的操作对象，是否能够执行，首先是受操作对象的isReady状态控制，其次是他们的优先级，是否准备好执行，是由操作对象的依赖对象是否执行完来限制的，但是这个优先级是操作对象的一个属性值，默认情况下，所有新创建的操作对象都是普通优先级，但是你可以增加或者是减少操作对象的优先级，通过setQueuePriority方法 优先级只对同一个队列中的操作对象起作用，如果你的应用有多个操作队列，不同队列中的操作对象的优先级是相互独立的，也就是说，在不同队列里面，存在低优先级的操作比高优先级的操作先执行。 优先级并不是依赖的替代，优先级决定的是那些在队列中已经是准备状态的操作对象的执行顺序，举个例子，如果一个队列中同时有高优先级和低优先级的操作对象准备好了，那么操作队列先执行高优先级的操作对象，然而，如果高优先级的没有准备好，但是低优先级的准备好了，那么将先执行低优先级的，如果你想阻止一个操作任务在另外一个操作对象执行完之后再执行，你需要使用依赖关系去 做</p>\n<h3 id=\"3-6-3-改变依附线程的优先级\"><a href=\"#3-6-3-改变依附线程的优先级\" class=\"headerlink\" title=\"3.6.3 改变依附线程的优先级\"></a><a href=\"#4\">3.6.3 改变依附线程的优先级</a></h3><p>在OSX 10.6及以后，设置一个操作对象所在的线程的优先级成为可能，系统的线程策略是依靠内核去管理，但是高优先级的线程将获得更高的执行机会，对一个操作对象，你可以显式的指定它的线程优先级，通过设置一个浮点型的数值，0-1.0之前。0是优先级最低、1是优先级最高。如果不显式设置的话，系统默认的线程优先级是0.5. 要设置线程优先级的话，你需要在讲操作对象添加到操作队列之前，调用setThreadPriority函数。当它的执行时间到来的时候，默认的start函数就会设置你之前指定的线程优先级来修改优先级。这个优先级只在你执行的main函数执行过程用有效。所有的其他代码包括你的完成回调，仍然是运行在默认的优先级下的。如果你自定义了一个并发的操作，那么你需要重写start函数，并手动去修改线程的优先级。</p>\n<h3 id=\"3-6-4-设置一个完成后的回调block\"><a href=\"#3-6-4-设置一个完成后的回调block\" class=\"headerlink\" title=\"3.6.4 设置一个完成后的回调block\"></a><a href=\"#4\">3.6.4 设置一个完成后的回调block</a></h3><p>在OSX 10.6及以后，一个操作对象可以在它的所有任务执行完成之后去执行一个完成的block，你可以用这个完成的block执行任何与main函数执行的任务里面不相关的的block。举个例子，你可能需要告诉客户这个操作对象的任务都执行完成了，一个并发的操作对象可能会使用这个block去执行它最后的KVO通知 要设置一个完成block，你可以使用setCompleteBlock：函数，这个函数不需要传任何参数，也没有返回值。</p>\n<h2 id=\"3-7-关于实现一个操作对象的一些Tips\"><a href=\"#3-7-关于实现一个操作对象的一些Tips\" class=\"headerlink\" title=\"3.7 关于实现一个操作对象的一些Tips\"></a><a href=\"#3\">3.7 关于实现一个操作对象的一些Tips</a></h2><p>尽管一个操作对象可能非常容易去实现，但是有一些事情在你自定义的操作对象上还是要注意一下，下面的小段描述了这么几个方面。</p>\n<h3 id=\"3-7-1-管理操作对象的内存\"><a href=\"#3-7-1-管理操作对象的内存\" class=\"headerlink\" title=\"3.7.1 管理操作对象的内存\"></a><a href=\"#4\">3.7.1 管理操作对象的内存</a></h3><p>下面的小段，描述了几个在操作对象中管理内存的关键元素，关于更多的OC的内存管理，参见内存管理开发指导。</p>\n<h4 id=\"3-7-1-1-避免依靠线程存储数据\"><a href=\"#3-7-1-1-避免依靠线程存储数据\" class=\"headerlink\" title=\"3.7.1.1 避免依靠线程存储数据\"></a><a href=\"#5\">3.7.1.1 避免依靠线程存储数据</a></h4><p>尽管大多是的操作都是在一个线程中执行的，在同步操作对象中，这个线程通常是由操作队列分配给它的，如果一个操作队列将线程分配给操作对象，那么你需要知道这个线程它是属于操作队列的，你不应该和你的操作对象有任何瓜葛，尤其是，你不应该有任何数据相关的在这个线程中，而这些数据并不是你创建和管理的数据，因为线程的生存和死亡是有操作队列或者系统来控制的，因此在线程间数据传递通过线程来传递将是不可靠，也是容易失败的。 在操作队列上，没有任何的理由可以使用线程存储数据，当你初始化一个操作对象，你应该提供给它所有执行任务需要的数据去做这件事，因此，操作对象要提供所有数据，所有来的、去的数据都应该存在操作对象上，知道任务结束或者应用不在需要它。</p>\n<h4 id=\"3-7-1-2-如果需要的话保持操作对象的引用\"><a href=\"#3-7-1-2-如果需要的话保持操作对象的引用\" class=\"headerlink\" title=\"3.7.1.2 如果需要的话保持操作对象的引用\"></a><a href=\"#5\">3.7.1.2 如果需要的话保持操作对象的引用</a></h4><p>因为操作对象是异步运行的，你不应该认为你可以创建或者忘记他们，它们也只是对象而已，也需要你去管理他们，尤其是你需要在它完成之后获取数据的情况下。 你需要保持对操作对象的引用，主要还有可能你再没有机会获取这个操作对象的引用的机会了，操作对象是执行很快的，在很多情况下，操作任务一旦添加到操作队列中，就会被执行，当你的代码获取到从操作队列中拿到的操作对象的时候，很可能，这个操作对象已经结束了，并从操作队列移除了，释放了。</p>\n<h3 id=\"3-7-2-处理错误和异常\"><a href=\"#3-7-2-处理错误和异常\" class=\"headerlink\" title=\"3.7.2 处理错误和异常\"></a><a href=\"#4\">3.7.2 处理错误和异常</a></h3><p>由于操作对象在你的应用里面是完全独立的实例，因此有必要去处理那些异常和错误，在OSX 10.6及以后，默认的start的函数不在提供捕获异常。你自己的代码需要去直接的捕获和处理异常，如果需要也要检测错误代码并通知给应用程序，如果你替换了start函数，那么你的代码需要在程序离开底层线程之前就去处理这些异常。 你可能处理的错误可能有一下几种情况 检测UNIX errno 类型的错误 检测显式的由代码返回的错误 捕获来自你自己的代码和系统框架带来的异常 当一个操作对象没有准备好，start方法就开始执行的时候 当一个操作已经在执行或者执行完成了，或取消了，start函数被再次调用的。 当添加一个block任务，但是它已经被执行或者完成的。 当你准备从NSInvocationOperation对象获取数据，但是它已经被取消的情况。 如果你自定义的代码遇到异常或者错误，你需要提供操作步骤给你的应用去处理，Operation对象不会显式的把错误代码或者异常传递给你应用的其他地方，因此，如果对于应用程序是比较重要的信息，你需要提供相关必要的代码去处理这些错误。</p>\n<h2 id=\"3-8-决定操作对象合适的数量，不要太多，也不要太少\"><a href=\"#3-8-决定操作对象合适的数量，不要太多，也不要太少\" class=\"headerlink\" title=\"3.8 决定操作对象合适的数量，不要太多，也不要太少\"></a><a href=\"#3\">3.8 决定操作对象合适的数量，不要太多，也不要太少</a></h2><p>虽然可以给一个操作队列中，添加大量的操作对象，但是这么做，往往并不太好，像其他对象一样，创建NSOperation对象也是需要消耗内存，并且他们的执行也是需要开销的。如果你的每个任务都是很小的，而你又创建了成千上万个，你会发现你会消耗更多的时间在分发操作对象上，而不是在执行真正的任务，而如果你的设备已经内存不足时，你会发现成千上万的任务会严重影响程序的性能。 高效的应用操作对象的关键在于，在充分利用设备和执行一定数量的操作任务之间找到平衡点，尝试去找到你的设备执行任务的一个真正的数量值。举个例子，如果你的应用创建了100个操作对象去处理100个不同的值，那么你可以考虑使用10个操作对象，去处理10个值去代替。 同时，你也需要避免一次性的给操作队列中添加大量的任务，也要避免不停的给操作队列以比它处理速度更快的添加更多的任务，相比于一次泛哄式的添加任务，不如批量式的去添加，然后利用完成block回调去执行下一批次的任务。这样可以避免内存过多的消耗。 当然，创建操作对象的数量、以及没个操作对象需要执行的任务量，是由你的程序动态去管理的。你应该是用性能测试工具，例如Instruments去找到性能处理和速度的平衡点，关于Instruments 和其他性能工具的更多信息，参见性能。</p>\n<h2 id=\"3-9-操作对象的执行\"><a href=\"#3-9-操作对象的执行\" class=\"headerlink\" title=\"3.9 操作对象的执行\"></a><a href=\"#3\">3.9 操作对象的执行</a></h2><p>最后，你的应用需要执行这些操作对象以真正的处理任务，在这一小节，你将学到就像你熟练的执行你的操作一样，去执行这些操作。</p>\n<h3 id=\"3-9-1-添加操作对象到操作队列中\"><a href=\"#3-9-1-添加操作对象到操作队列中\" class=\"headerlink\" title=\"3.9.1 添加操作对象到操作队列中\"></a><a href=\"#4\">3.9.1 添加操作对象到操作队列中</a></h3><p>到目前为止，最容易的执行操作的方式是使用操作队列，即NSOperationQueue类的实例，你的应用有责任去创建和维护这些操作队列。一个应用程序可以有任意数量的操作队列，但是实际上在同一时间有多少个操作会被执行还是有限制的，被系统调用的操作队列会根据可利用的CPU和系统的载入量来进行限制单位时间执行的操作对象，因此，创建更多的操作队列并不意味着可以执行更多的操作对象 就想创建其他的对象一样，在你的应用中创建操作队列<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSOperationQueue</span>* aQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div></pre></td></tr></table></figure></p>\n<p>添加一个操作对象到操作队列中，你可以使用addOperation方法，在OSX 10.6以后，你还可以添加操作对象组，通过<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addOperations：waitUntilFinished：</div></pre></td></tr></table></figure></p>\n<p>方法，你也可以直接添加blocl对像到操作队列中（而不需要与一个操作对象关联），通过<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addOperationWithBlock：</div></pre></td></tr></table></figure></p>\n<p>方法，上面的这些方法，队列都会入一个操作对象并通知队列去执行他们，在大多数情况下，操作对象将会被很快执行，但是有时候，操作队列也可能延迟执行操作对象，大概有这么几个原因，最普遍的就是，操作对象间可能有依赖关系，还有可能是操作队列自己可能被挂起，或者是操作队列执行操作任务的数量达到了上限。下面的代码展示了最基础的添加操作到操作队列的语法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[aQueue addOperation:anOp]; <span class=\"comment\">// Add a single operation </span></div><div class=\"line\">[aQueue addOperations:anArrayOfOps waitUntilFinished:<span class=\"literal\">NO</span>]; <span class=\"comment\">// Add multiple operations </span></div><div class=\"line\">[aQueue addOperationWithBlock:^&#123; <span class=\"comment\">/* Do something. */</span></div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure></p>\n<p> 重要 千万不要在一个操作对象进入操作队列之后再去修改它，因为当操作在操作队列中等待执行的时候，它可能在任何时候去执行任务，改变它的依赖和数据，可能会起到坏的作用。如果你想知道一个操作对象的状态，请使用操作对象的属性 去获取。</p>\n<h3 id=\"3-9-2-手动执行操作对象\"><a href=\"#3-9-2-手动执行操作对象\" class=\"headerlink\" title=\"3.9.2 手动执行操作对象\"></a><a href=\"#4\">3.9.2 手动执行操作对象</a></h3><p>尽管操作队列对于运行操作对象已经很方便了，但是还是有一种可能不使用操作队列去执行一个操作对象，如果你选择手动去执行操作对象，那么有一些注意事项，最主要的是，操作对象必须得是ready，而且你需要用start函数去启动它。 一个操作对象如果不是ready状态的话不应该去执行，isReady函数被Operation对象的依赖关系封装到了上层，只有当它的依赖关系都清除的时候，一个操作才能够被执行、 当执行一个操作对象，应该去使用start函数去做。用这个函数而不是用main，是因为start函数会在执行之前执行一个安全检查，尤其是，默认的start函数还会产生KVO通知，以保证依赖关系能够正确进行，这个函数同时也避免当你的操作对象被取消的时候，再去执行，以及当操作对象没有准备好的时候就去调用导致的异常抛出 。 如果你的程序定义了并发的操作对象，你同时需要在启动任务之前考虑isConcurrent。当这个方法返回NO的时候，你就可以考虑是在当前线程中同步的执行还是创建一个新的子线程。然而，这些方法的检测完全取决于你。 下面展示了一个比较简单的，手动开启并发操作对象的一个例子。如果这个函数返回NO，你可以启动一个timer，在之后再去调用它。然后直到它返回YES之后，取消掉Timer。因为这种情况可能在操作对象被取消的时候发生。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)performOperation:(<span class=\"built_in\">NSOperation</span>*)anOp &#123; </div><div class=\"line\">\t<span class=\"built_in\">BOOL</span> ranIt = <span class=\"literal\">NO</span>; </div><div class=\"line\">\t<span class=\"keyword\">if</span> ([anOp isReady] &amp;&amp; ![anOp isCancelled]) &#123; </div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (![anOp isConcurrent]) </div><div class=\"line\">\t\t[anOp start]; </div><div class=\"line\">\t\t<span class=\"keyword\">else</span> [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(start) toTarget:anOp withObject:<span class=\"literal\">nil</span>]; </div><div class=\"line\">\t\tranIt = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([anOp isCancelled])&#123; </div><div class=\"line\">\t\t<span class=\"comment\">// If it was canceled before it was started, // move the operation to the finished state. </span></div><div class=\"line\">\t \t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">\t \t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>];</div><div class=\"line\">\t  \texecuting = <span class=\"literal\">NO</span>; </div><div class=\"line\">\t  \tfinished = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t  \t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">\t  \t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">\t  \t<span class=\"comment\">// Set ranIt to YES to prevent the operation from </span></div><div class=\"line\">\t  \t<span class=\"comment\">// being passed to this method again in the future. </span></div><div class=\"line\">\t  \tranIt = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t&#125; <span class=\"keyword\">return</span> ranIt; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-9-3-取消操作对象\"><a href=\"#3-9-3-取消操作对象\" class=\"headerlink\" title=\"3.9.3 取消操作对象\"></a><a href=\"#4\">3.9.3 取消操作对象</a></h3><p>当将操作对象添加到操作队列里面的时候，一个操作对象的管理就交给了操作队列，也不能被移除了，唯一使操作对象出列的方法就是调用它的cancel函数，你也可以取消所有的操作对象，通过调用操作队列的cancelAllOperations 你可以在确保你不在需要操作对象的时候取消掉它。发出一个cancel命令，会将操作对象的关键路径变为canceled状态，这将阻止任务继续执行，由于canceled的操作对象也认为是完成的，那么依赖它的操作对象就可以移除依赖关系。然而，更多情况下，更常用的是取消所有操作独享，在某些重要的时候，比如应用退出、或者用户发出了取消指令，这比一个个取消要好很多。</p>\n<h3 id=\"3-9-4-等待操作对象的完成\"><a href=\"#3-9-4-等待操作对象的完成\" class=\"headerlink\" title=\"3.9.4 等待操作对象的完成\"></a><a href=\"#4\">3.9.4 等待操作对象的完成</a></h3><p>为了获取最佳的性能，你应该尽可能的让操作对象并发执行，让系统去干更多的事情，在你执行操作对象任务的时候，如果创建一个操作对象的时候，同时希望获得了操作对象的结果，你可以使用waitUntilFinished：方法来阻塞代码继续执行，直到这个操作对象执行完成。通常来讲，这是最好的方式去避免你能帮到它的时候，阻塞当前线程也许是一个比较好的解决方法。但这也带来了更多的同步性，而限制了整体的可并发性。 你绝不允许在主线程中调用这个方法，你最好在子线程或者其他的线程操作中这么做，阻塞主线程将会降低程序的可响应性。 除了等待一个任务完成，你可以等待一个操作队列所有的任务执行完成，通过调用waitUntilAllOperationsAreFinished，当你等待一个操作队列任务完成的时候，避免在别的线程中添加任务给它，以防延长等待时间。</p>\n<h3 id=\"3-9-5-挂起和恢复操作队列\"><a href=\"#3-9-5-挂起和恢复操作队列\" class=\"headerlink\" title=\"3.9.5 挂起和恢复操作队列\"></a><a href=\"#4\">3.9.5 挂起和恢复操作队列</a></h3><p>如果你想中途终止一个操作队列的话，你可以挂起相应的操作队列，使用setSuspended方法，挂起一个操作队列并不会导致正在执行的操作任务终止。它只是会阻止别的操作对象（操作队列中的）不去执行，你可能会在用户想暂停任务的时候挂起所有操作，因为用户还期望在某个时候恢复这些任务。</p>\n","excerpt":"<p><a href=\"#1\">并发编程指南</a></p>","more":"<p><img src=\"http://ock9zbzms.bkt.clouddn.com/translationconcurrency.png\" alt=\"\"></p>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a><a href=\"#1\">并发</a></h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a><a href=\"#2\">1 概述</a></h2><h3 id=\"1-1-并发的概念\"><a href=\"#1-1-并发的概念\" class=\"headerlink\" title=\"1.1 并发的概念\"></a><a href=\"#3\">1.1 并发的概念</a></h3><p>并发其实指的是多项任务在同一时间进行，随着多核CPU的普及以及发现任务只在某一核上不停的增加，软件开发者需要一种方式充分的利用多核系统。虽然诸如IOS、MacOS兼容多项程序同时执行，但是大多数的程序运行在后台，并且执行任务只需要很短的CPU时间。这是因为前台应用同时获取了用户的关注并且是设备处于忙的状态。如果一个程序有很多的任务需要处理，但是又只获得了很少的碎片CPU时间，那些额外的处理资源将被浪费。 在过去，在应用中引入并发要求创建一个或者多个额外的线程，遗憾的是，编写线程代码是一项非常有挑战性的事情，线程是一种‘低级’的工具，并且需要手动去管理，获取多少个线程是最优的，动态取决于当前的系统以及底层硬件的支持。实现一个完美的线程解决方案，变的极其困难或者说不可能实现。另外，采取添加线程的方式实现同步的机制，不仅给软件开发带来了复杂性和风险性，而且也并不能确保提升性能。 OSX和iOS采取了一种比传统的基于线程的系统和程序，更加异步的方式去执行并发任务。并不是直接去创建线程，应用需要做的是定义一些特殊的任务，然后让系统去执行它们，让操作系统去管理线程，程序获得了原生线程更强的伸缩性，而程序开发者也获得了更加简单更加高效的编程模型。 本文档就是描述这项技术和技艺，你应该使用这项技术来实现并发。这项技术同时使用于iOS和OSX。</p>\n<h2 id=\"1-2-文档的组织\"><a href=\"#1-2-文档的组织\" class=\"headerlink\" title=\"1.2 文档的组织\"></a><a href=\"#3\">1.2 文档的组织</a></h2><p>本文档包括以下章节<br>1、并发和程序设计——介绍异步程序设计的一些基本概念和异步的执行自定义任务的技术<br>2、操作队列——展示怎样用OC去组装和执行一个任务<br>3、分发队列——展示怎样在基于C的应用程序中去并发地执行任务<br>4、资源分发——展示如何异步的处理系统事件<br>5、从线程变成用迁移到新的技术——提供一些技术帮助从旧的线程变成迁移到新的变成技术 本文当同时也包括一些相关章节的专业术语的定义</p>\n<h2 id=\"1-3-一些专业名词\"><a href=\"#1-3-一些专业名词\" class=\"headerlink\" title=\"1.3 一些专业名词\"></a><a href=\"#3\">1.3 一些专业名词</a></h2><p>在开始讨论并发之前，非常有必要去定义一些相关的专业名词来避免混淆，一些开发UNIX或者早先开发OSX的程序员，可能会对任务，队列处理、线程有一些新的任务，本文档对这几个概念有如下定义<br>1、在本文中，线程专指一个分离的支线去执行一段代码，而在老的OSX中特指基于POSIX的API 2、在本文中，执行专指可执行的任务正在执行中，可能包裹着多个线程。<br>3、在本文中，任务专指一个需要被执行的抽象工作 关于完整的类似这些概念的定义，参见词汇定义</p>\n<h2 id=\"1-4-其他\"><a href=\"#1-4-其他\" class=\"headerlink\" title=\"1.4 其他\"></a><a href=\"#3\">1.4 其他</a></h2><p>本文档专注于如何在你的程序中实现并发编程，而不包括如何使用线程，如果你需要更多的有关线程开发的只是，请去参考线程编程指导</p>\n<h1 id=\"2-并发及程序设计\"><a href=\"#2-并发及程序设计\" class=\"headerlink\" title=\"2 并发及程序设计\"></a><a href=\"#2\">2 并发及程序设计</a></h1><h2 id=\"2-1-并发编程和程序设计\"><a href=\"#2-1-并发编程和程序设计\" class=\"headerlink\" title=\"2.1 并发编程和程序设计\"></a><a href=\"#3\">2.1 并发编程和程序设计</a></h2><p>在以前的计算机运行的时候，计算机单位时间最大执行数量的任务取决于CPU的时钟速度，但是随着技术的发展和中央处理器设计的更加紧凑，热量和物理因素开始限制中央处理器的最大时钟速度，所以，主板供应商也在寻找其他的方式去提升他们主板的总体性能，他们发现的解决方案是增加主板上的处理器个数，通过增加处理器个数，一个主板可以在单位时间内执行更多的任务，而并不需要去增加CPU的时钟速度，或是改变主板的大小或考虑热量参数，现在剩下的唯一问题就是如何去充分的利用这些多核。 为了利用这些多核，计算机需要程序设计者能够去同时执行多项任务，在当代，多核操作系统，如OSX或者IOS，可能有几百或者更多的程序在同时运行，所以根据时序安排程序在不同的中央处理器上变得成为可能，然而，大多数的时候，这些程序要么是系统守护进程，要么是那些消费很小处理时间的后台应用程序，取而代之的是，真正需要多核开发的是，独立的前台运行的程序更高效的获取更多核心。 传统的使应用获取多核的方式是创建多线程，然而，随着多核的增加，线程方案有一些问题，最大的问题是线程开发的方式对多核系统不具备很好的伸缩性，你不能仅靠创建更多的行程就能确保程序和处理器运行良好，你需要知道的是，如何高效的利用这些中央处理器。对于程序来讲，如何计算它自身是一件有挑战的事情，尽管你可以正确的管理这些线程，程序去管理这些线程也依然是一项挑战，去确保他们高效运行、确保他们不被别的线程干扰。 所以，总结这些问题，程序需要一种方式去充分应用多核，单个程序可伸缩的执行大量工作，而且这个解决方案需要足够简单，去面对单个处理器任务的任务增长，好消息是，苹果已经提供了解决方案对处理所有这些问题，本章节先睹为快，去看看这项技术的组成以及牛逼的设计，你可以使你的代码从中获益。</p>\n<h2 id=\"2-2-从线程开发中走出来\"><a href=\"#2-2-从线程开发中走出来\" class=\"headerlink\" title=\"2.2 从线程开发中走出来\"></a><a href=\"#3\">2.2 从线程开发中走出来</a></h2><p>尽管线程开发已经应用了多年，而且它们在某些地方还将有用武之地，但是它们并没有可伸缩的解决多核场景，如果你使用线程开发，那么创建一个可伸缩的解决方案的麻烦就落在你肩上了，开发者，你需要去动态的根据系统的多核个数去决定创建多少个线程，此外，你的应用将花费很多消耗在创建和管理这些线程本身的消耗上。 取代线程开发，OSX和IOS使用异步设计的方式解决并发问题，异步方法已经在操作系统中提供了很多年，而且一般都是应用在创建很耗时的任务上，如从磁盘读取文件。当调用的时候，一个异步任务开始在后台执行，并立即返回在任务执行完之前。通常，这项任务会调用一个后台线程，开始这项任务在该后台线程上，然后在任务完成的时候发送一个消息给调用者（通常使用回调的方式）。在过去，如果没有一个你需要的异步方法，你需要自己去写一个异步方法还需要创建自己的线程，但是现在，OSX和iOS提供技术，你可以不用自己去管理线程就可以异步执行任务。 一种开启异步任务的技术叫 GCD，一项将过去需要在你程序中自己写管理线程代码移交给系统去管理。所有你需要做的事情仅仅是创建任务，然后将任务提交给合适的系统的GCD队列。GCD去创建和管理这些线程，因为这些线程已经提交给系统去管理，GCD提供全套的任务管理和执行，比传统的线程管理更加高效。 操作队列是非常类似于分发队列的一种OC对象管理方式，你可以定义你想执行的任务，然后把他们扔到操作队列中，当执行这些安排好的任务时，类似于GCD，操作队列为你执行所有的管理。确保在系统长执行的高效且迅速。 下面的段落提供了更多的信息关于操作队列、分发队列、以及一些你可能在异步编程中用到的技术</p>\n<h3 id=\"2-2-1-分发队列\"><a href=\"#2-2-1-分发队列\" class=\"headerlink\" title=\"2.2.1 分发队列\"></a><a href=\"#4\">2.2.1 分发队列</a></h3><p>分发队列是一套C的机制，为可执行自定义任务。分发队列要么是串行的要么是并行的，但是通常都是按照FIFO的方式去调度任务，一个串行的队列，一次只能运行一个任务，只有等前一个任务完成之后，下个任务才能开启。作为对比，并行的队列可以同时开启尽可能多的任务而并不需要前面的任务执行完毕。 分发队列有下面几个好处 </p>\n<pre><code>1、提供了简单的直观的编程接口 \n2、提供了自动的和完全的线程池管理 \n3、任务执行速度提升 \n4、更多的内存方面的优化 \n5、他们不会增加内核的负载 \n6、不会导致队列死锁 \n7、伸缩性强（对多核系统来讲） \n8、串行队列提供了比过去线程同步更为优秀的一种选择 \n</code></pre><p>你提供给分发队列的任务必须是封装好的一个方法或者是一个Block对象，Block是一种具有C语言特性的，开始引进与OSX 10.6,IOS 4.0的一个新特性。但是相比C语言有一些别的好处。不同于在Block的语法区域定义Block对象，你通常在别的方法或者是函数中去定义，这样可以去捕获到别的方法或者函数中的变量，Block同样可以移动到他们的作用区域以外，拷贝到堆上，这通常发生在你将任务添加到一个分发队列上的时候，所有这些语法特性，使得通过添加少量代码就可以获得非常好的实现。 分发队列是GCD技术的一部分，也是C运行时的一部分，要想获取更多的有关分发队列相关的信息，请参见 分发队列，要获取更多关于Block的信息和他们的好处，参见Block 程序编程观点。</p>\n<h3 id=\"2-2-2-分发资源\"><a href=\"#2-2-2-分发资源\" class=\"headerlink\" title=\"2.2.2 分发资源\"></a><a href=\"#4\">2.2.2 分发资源</a></h3><p>分发资源是异步的处理系统分发资源的一种C语言机制，分发资源封装了一个特殊类型的系统事件，并将这个特殊的系统事件提交给一个特殊的Block对象，或者函数，当系统事件发生的时候，你可以使用分发资源去监测如下特殊系统事件 定时器 信号事件 描述符相关事件 进程相关事件 端口匹配相关事件 自定义的事件，并由你来触发 分发资源也是GCD技术的一部分，要获取更多有关分发资源相关的信息，参见分发资源</p>\n<h3 id=\"2-2-3-操作队列\"><a href=\"#2-2-3-操作队列\" class=\"headerlink\" title=\"2.2.3 操作队列\"></a><a href=\"#4\">2.2.3 操作队列</a></h3><p>操作队列是cocoa环境的一种并发队列，由NSOperationQueueClass 实现，操作队列总是按照FIFO的方式去执行任务，操作队列考虑其他因素去影响执行队列的顺序，在这些因素中，优先考虑一个任务的执行是否是依赖于其他任务，你可以给自己的任务设置依赖关系，然后创建一个复杂的执行顺序图。 任务添加到操作队列中的，必须是NSOperation的子类，一个操作对象是一个OC类型的封装了你要执行的数据和任务的对象，由于NSOperation是一个抽象基类，所以你通常需要去自定义子类去执行你的任务，然而，Foundation Framework已经提供了一些相关的子类，你可以使用它们去执行任务。 操作的对象产生KVO通知，这个是非常有用的，当监视你的任务进度的时候，虽然任务执行通常是并发的，但是可以利用依赖是的任务有序。 关于更多操作队列的信息，参见操作队列</p>\n<h2 id=\"2-3-异步编程技术\"><a href=\"#2-3-异步编程技术\" class=\"headerlink\" title=\"2.3 异步编程技术\"></a><a href=\"#3\">2.3 异步编程技术</a></h2><p>在你开始考虑重新用并发编程的方式重新设计程序的时候，你最好先问下自己这么做是否必要，并发可以提高你代码的可响应性，去确保主线程能相应更多的用户事件，它同样可以提高你代码的性能，通过促进多核去执行更多的任务，但是它也同时带来了上层复杂性，从而使你的代码更加难调试。 由于它带来了复杂性，并发并不是一个在你程序开周期中考虑的特性，当把它嫁接到应用中。做对这件事需要你好好考虑你程序执行的任务以及向这些任务提交的数据结构。如果做错的话，你可能发现你的代码运行缓慢，甚至还不如从前，因此，在你开始程序设计的时候，你就应该考虑你要实现的目标和通过何种方式来达到它。 每个应用都包含有不同的要求和不同的任务需要它去执行，这不可能靠一个文档就告诉你，怎么去设计你的程序和管理任务，然而，下面几段可以给你提供一些指导，帮助你去在程序设计的时候做出好的选择。</p>\n<h3 id=\"2-3-1-明确程序期望的表现\"><a href=\"#2-3-1-明确程序期望的表现\" class=\"headerlink\" title=\"2.3.1 明确程序期望的表现\"></a><a href=\"#4\">2.3.1 明确程序期望的表现</a></h3><p>在你决定是否要将并发引导到应用中的时候，你应当开始思考你的应用程序想要达到的一个什么表现。明白了应用要达到的表现之后，会给你是否使用并发提供一个参考。同样的，也会给你一些引入并发之后程序能获取的性能收益方面的启发。 首先、你需要列举应用程序所要执行的任务和数据结构之间的关系。开始，你可能通过点击一个菜单或者一个按钮开启一个任务并执行，这些任务可能是一些离散的任务，并有明确的开始和结束点。你还需要列举出应用程序可能执行的其他类型的任务，而不仅仅是用户行为相关的，比如说基于时间的一些任务 在你有了自己任务列表之后，开始把任务进行更加的分组集合，确保这些任务能够成功执行。在这个层面，你优先考虑的是那些数据或对象修改如何对应用状态进行修改的。你同样需要考虑不同任务之间的相互依赖关系，例如：如果一个任务牵涉到一个数组中所有对象的修改，对于其中一个数据的修改，会对其他数据产生任何影响。如果一个数据的修改，独立于其他的数据，那么这个时候你可以考虑使用并发去做提升性能，创建多个任务去做。</p>\n<h3 id=\"2-3-2-单位工作的可执行因子\"><a href=\"#2-3-2-单位工作的可执行因子\" class=\"headerlink\" title=\"2.3.2 单位工作的可执行因子\"></a><a href=\"#4\">2.3.2 单位工作的可执行因子</a></h3><p>在明白你程序执行的任务类型之后，你应该明白在什么地方去使用并发会有好处了。如果在一个任务中改变一个或者多个的顺序，会影响到执行结果。你应该还是需要考虑到使用串行的方式去执行这些任务，如果改变执行顺序之后，并不会影响到执行结果，你可以考虑将这些任务用并发的方式去做，在这俩种情形下，你定义可执行的单位工作，并让它们执行，这些工作单元，就成为你封装好的Block对象或者操作对象或者分发队列。 对于每个单独的可执行任务，并不需要过多的担心任务执行的数量，在最后，分到线程中总是会有开销，但是分发队列或者操作队列相比传统的线程开发还是有很多优势的，因此，执行一些单元工作使用操作队列还是要比直接操作线程要好很多，当然，你常常应该确保任务执行的性能和你开启的任务恰好如你所需，但是，任务并不是越小就越好。</p>\n<h3 id=\"2-3-3-区分你需要什么队列\"><a href=\"#2-3-3-区分你需要什么队列\" class=\"headerlink\" title=\"2.3.3 区分你需要什么队列\"></a><a href=\"#4\">2.3.3 区分你需要什么队列</a></h3><p>此时，你的任务已经切割为一些可执行的单元，并且封装成了Block对象或者是操作对象，你需要去定义你要执行的队列以执行这些任务。对一个任务来讲，测试这些Block或者是操作任务，能够在队列中执行正确。 如果你使用Block去实现你的任务,你可以添加任务到串行或者并行的队列里，如果对顺序有要求的话，你只能添加到一个串行队列中，如果没有要求，根据你的要求，你可以添加的并行队列中，或者添加到多个队列中去。 如果你是用操作队列去执行任务，那么选择的队列并不对添加到里面的任务的配置感兴趣，如果要串行去执行任务，那么你需要给相关的任务设置依赖关系，依赖会阻止任务开始执行，直到它依赖的任务执行完成。</p>\n<h3 id=\"2-3-4-提升执行效率的贴士\"><a href=\"#2-3-4-提升执行效率的贴士\" class=\"headerlink\" title=\"2.3.4 提升执行效率的贴士\"></a><a href=\"#4\">2.3.4 提升执行效率的贴士</a></h3><p>在把任务分割为更小的任务并将他们添加到队列中后，这里还有一些使用队列提升程序性能的小Tips 如果内存考虑是一个因素的话，那么在任务里面直接计算。如果你的应用已经内存警告了，那么在任务中直接计算会比从内存中加载要快一些。运用在寄存器或者是该核上的内存计算，会比从主内存加载要快一些。当然，你也可以通过测试来选择哪种方案会好一些。 将串行的任务，可能的话改变为并发。如果一个任务由于共享资源必须串行去执行，可以考虑将共享资源移除使得可以并发执行，可以考虑把这些资源给每个客户都拷贝一份。 避免使用锁，操作队列和分发队列的支持在大多数情况下并不需要锁。做为取代，可以使用一个串行的队列或者使用依赖去保证顺序正确。 如果可能的话依赖系统框架，最好的方式去实现并发就是使用系统提供的框架，许多框架使用线程或者其他技术来实现并发，当定义你的任务的时候，看看系统框架中是否已经有方法或者函数能够实现并发，使用系统接口会提升你的效率，而且帮你做到更多的并发可能性。</p>\n<h2 id=\"2-4-性能相关\"><a href=\"#2-4-性能相关\" class=\"headerlink\" title=\"2.4 性能相关\"></a><a href=\"#3\">2.4 性能相关</a></h2><p>操作队列、分发队列、资源分发提供了一种执行并发更加容易的方式。但是这些技术并不保证提升程序的性能和可响应性。具体来讲，根据你的需要同时兼顾性能提升和不要影响到其他资源仍然是你自己需要衡量的一件事。举个例子来讲，尽管你创建了10000个任务并把他们都提交到操作队列中，这么干的话，肯定会导致你的程序分配潜在的大量内存，这个会导致增加调度和减少性能。 引入并发到你的程序中前–是使用队列还是线程，你需要根据程序当前的性能来设置一个参考的标准。在引入并发之后，也同样需要做个列表对性能方面的改变进行比较，来确保程序是真的性能提升了，如果引入并发并不能给性能带来大的提升，你应该考虑其他的性能工具来检测潜在的原因。 关于性能的介绍和可用的性能工具，参见性能概览。</p>\n<h2 id=\"2-5-并发和其他技术\"><a href=\"#2-5-并发和其他技术\" class=\"headerlink\" title=\"2.5 并发和其他技术\"></a><a href=\"#3\">2.5 并发和其他技术</a></h2><p>将你的代码分解为模块任务是一种最好的提升应用并发的方式，但是这种设计方式并不是对每个应用每个情况都很适合，取决于你执行的任务，也可能存在其他的选择来提升程序的整体并发，下面的俩小节提供了其他的并发技术供你参考</p>\n<h3 id=\"2-5-1-OpenGL和并发\"><a href=\"#2-5-1-OpenGL和并发\" class=\"headerlink\" title=\"2.5.1 OpenGL和并发\"></a><a href=\"#4\">2.5.1 OpenGL和并发</a></h3><p>在OSX中，OpenGC技术是图形计算方便最基础和核心的技术，OpenGL是非常棒的计算大数据集合的一种技术，举个例子来讲，你可能使用OpenGL技术来给图片做像素级别的滤镜，或者用它来计算复杂的数学计算。换而言之，OpenGL可以用来计算大量数据集合是并行的。 尽管OpenGL在大量数据并行执行方面有着非常好的性能优势，但是它并不合适执行自定义的计算，在任务提交给GPU处理之前，有大量的准备工做，而且要将数据和其他必要的核心操作转换图形卡片。同样的，要想获取OpenGL的产生结果也需要偶很多其他的努力。因此，所有跟系统交互相关的任务不建议提交给OpenGL去执行，举个例子，你不应该用OpenGL去运算从文件中或者网络流中拿到的数据，取而代之的是，你要用OpenGL执行的任务，必然是自己已经持有的这样相对来讲传递给GPU运算更加独立。 更多关于OpenGL的只是，参见OpenGL开发指导。</p>\n<h3 id=\"2-5-2-何时使用线程\"><a href=\"#2-5-2-何时使用线程\" class=\"headerlink\" title=\"2.5.2 何时使用线程\"></a><a href=\"#4\">2.5.2 何时使用线程</a></h3><p>尽管操作队列和分发队列是执行并发任务的更优选择，但是它们不是万能的，取决于你的应用程序，这里仍然后一些情况是需要创建线程去开发的，如果你创建了自定义的线程，那么你要确保尽量少的开启线程，并且确保这些线程只执行特定的任务，而不去干别的事情。 线程仍然是一种较好的解决方案，当执行实时任务的时候，分发队列会确保尽快的去执行他们的任务，但是并不能实时的去开线程去做。如果你需要可预测的后台代码执行，那么线程仍是一种选择。 作为线程编程，你还是需要去使用线程，当必须和完全必要的时候，关于更多线程方面的知识，参见线程开发指导。</p>\n<h1 id=\"3-操作队列\"><a href=\"#3-操作队列\" class=\"headerlink\" title=\"3 操作队列\"></a><a href=\"#2\">3 操作队列</a></h1><p>cocoa的操作都是原生的对象封装的可执行异步任务。这些操作同时可提交给操作队列去执行，也可以直接自己执行。由于是基于OC的框架，那么操作可应用在IOS和OSX中。本章节将介绍如何去使用和定义操作。</p>\n<h2 id=\"3-1-关于操作对象\"><a href=\"#3-1-关于操作对象\" class=\"headerlink\" title=\"3.1 关于操作对象\"></a><a href=\"#3\">3.1 关于操作对象</a></h2><p>一个操作对象是一个NSOperation类的实例，你可以用它来封装你要执行的任务。NSOperation类本身是一个抽象基类。所以要想执行可用的任务，必须得使用它的子类。尽管是一个抽象类，它还是提供了一些有用的基本操作，而省去了你在自己定义的子类中去做的麻烦。此外，Foundation 框架还提供了俩个具体的子类，可以用它们来执行你的任务，下表列出了这俩个类，还有如何使用它们的介绍。 NSInvocationOperation ：这是一个基于你的类和要执行的Seletor的类，你可以在已经定义过这个任务的地方去调用它，然后执行异步操作。由于它并不要强制你去做继承，所以可以使用该类去实现一个更加动态的风格。 NSBlockOperation：这是一个执行block封装任务的操作类，因为它可以执行多个block。block任务执行任务使用了组的语法，当所有的相关的block执行完之后，这个block操作才被任务是执行完成 NSOperation：这是定义其他操作任务的基类，继承它给你自定义操作类带来了完成的并发控制以及实现。包含可以完全控制任务的执行能力和执行状态。 所有上述的操作对象都包含以下核心的特性 支持建立图形化的任务间相互依赖，这些依赖将会阻止任务开始，直到它依赖的任务完成之后。 支持可选的完成回调block。指的是当所有的执行任务结束之后的回调方法。 支持检测任务执行状态（使用KVO） 支持对操作顺序进行调整，并影响他们的执行顺序。 支持取消语义，也即允许你半路对任务执行终止操作。 操作对象是设计来帮助你提升程序的并发水平，操作也是一种不错的组织和包装你的应用为几个独立的分支的一种手段，作为取代提交一些任务给主线程的开发方式，可以将任务分割为一个或多个不同的操作，然后提交给队列，使相关的工作可以在一个或多个线程中去并发的执行。</p>\n<h2 id=\"3-2-同时VS非同时操作\"><a href=\"#3-2-同时VS非同时操作\" class=\"headerlink\" title=\"3.2 同时VS非同时操作\"></a><a href=\"#3\">3.2 同时VS非同时操作</a></h2><p>尽管，你通常将任务添加到操作队列中，但是做这个并不是必须的。你也可以直接调用它的start方法去开始一个操作。但是执行这个操作，并不能保证你的操作同步的运行在你当前代码所在的线程中。那么NSOperation类的这个isConcurrent方法会告知你，当前运行的操作是同步还是异步的在你调用Start方法的线程中，默认情况下这个方法会返回NO，也就是说这个操作是在当前调用的线程中同步去执行的。 如果你想去实现一个异步执行的操作，也就是调度任务的线程和任务执行的线程是异步的。你需要写额外的代码去异步的开启它。举个例子，你可以创建一个独立的线程，调用一个系统的异步方法，去执行其他的事情以保证start函数的调用时异步去执行。 大多数的开发并不需要去实现一个并发操作对象，如果你总是将你的操作去添加到一个操作队列中，你并不需要实现这些并发操作，当你添加一个操作对象到操作队列中的时候，操作队列自己就会创建一个线程去执行你的操作，因此，将一个并不是异步的任务添加到操作队列中去，结果还是会以异步的方式去执行代码，去定义一个异步任务这种费力不讨好的工作，也只是你就是想创建异步执行任务，而不是将它添加到队列中去的时候才有必要。 关于更多有关异步任务的信息，参见设置任务去异步执行。</p>\n<h2 id=\"3-3-创建一个NSInocationOperation对象\"><a href=\"#3-3-创建一个NSInocationOperation对象\" class=\"headerlink\" title=\"3.3 创建一个NSInocationOperation对象\"></a><a href=\"#3\">3.3 创建一个NSInocationOperation对象</a></h2><p>NSInvocationOperation是NSOperation的具体子类，当它运行的时候，会执行它的selector里面，指派给它的任务。使用该类时，应该避免将大量的自定义的操作给每个任务。尤其是当你需要改变一个已经存在的应用程序和这些对象已经存在任务，还有很多必备要执行的任务时。你可以使用它来改变依赖环境的时候。举个例子，你可以使用一个Invocation对象来执行一个选择器，这个选择器是基于获取用户的输入信息动态的选择。 创建一个Invocation操作的步骤是很简单的，你可以创建并实例化一个该对象，然后传递需要的对象和selector去执行指定的代码，下面提供了俩个方法去举例说明这个操作步骤，taskWithData：方法创建一个操作对象，然后通过另外一个方法去执行任务。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyCustomClass</span> </span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">NSOperation</span>*)taskWithData:(<span class=\"keyword\">id</span>)data &#123; </div><div class=\"line\">\t<span class=\"built_in\">NSInvocationOperation</span>* theOp = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> </div><div class=\"line\">\tselector:<span class=\"keyword\">@selector</span>(myTaskMethod:) </div><div class=\"line\">\tobject:data]; </div><div class=\"line\"><span class=\"keyword\">return</span> theOp;</div><div class=\"line\"> &#125; <span class=\"comment\">// This is the method that does the actual work of the task. </span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)myTaskMethod:(<span class=\"keyword\">id</span>)data &#123; <span class=\"comment\">// Perform the task. &#125; </span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"3-4-创建一个NSBlockOperation对象\"><a href=\"#3-4-创建一个NSBlockOperation对象\" class=\"headerlink\" title=\"3.4 创建一个NSBlockOperation对象\"></a><a href=\"#3\">3.4 创建一个NSBlockOperation对象</a></h2><p>NSBlockOperation是NSOperation的具体子类，作为一个或者多个Block对象的封装器，这个类提供了对象层面的封装，而且它已经使用了操作分发队列，所以并不需要创建分发队列，但是你也可以使用其他的诸如操作任务的依赖、KVO通知或者其他特性，而这些特性是分发队列所没有的。 当你创建一个block操作的时候，在创建他的时候，你至少已经添加了一个block，你也可以在之后再添加更多的block进去。当执行NSBlockOperation对象的时间来临的时候，该对象会将它的所有block都提交给默认优先级的异步分发队列，然后这个对象等待它的block全部执行完，之后会把自己标记为isfinish。因此，你可以使用一个Block操作去监听一组任务的完成，非常像用一个线程去管理多个线程的结果。而不同之处在于block操作自己运行在一个分离的线程，而你的程序可以干其他的活儿，在这个block等待它的任务执行完成之前。 下面的代码介绍了如何去创建一个BlockOperation，这个Block没带参数且没有返回什么有意义的结果 NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{ NSLog(@”Beginning operation.\\n”); // Do some work. }]; 当创建一个block操作之后，你可以添加更多的block给它，通过 addExecutionBlock：方法，如果你想让添加的任务线性去执行，那么你必须直接将它提交给指定的串行队列中去。</p>\n<h2 id=\"3-5-定义一个自定义的操作\"><a href=\"#3-5-定义一个自定义的操作\" class=\"headerlink\" title=\"3.5 定义一个自定义的操作\"></a><a href=\"#3\">3.5 定义一个自定义的操作</a></h2><p>如果一个Block操作对象或者Invocation操作对象没法完全满足你的需求的时候，你可以考虑自己定义个继承自NSOperation的操作对象，NSOperation对象提供了一系列的继承点给所有的操作对象，这个类已经实现了大量的基础的函数或方法，满足那些依赖或者KVO的操作，然而，还是有一些地方需要你自己的自定义实现确保你的操作对象能够正确的执行，具体的工作量的大小取决于你要自定义的是一个同步操作对象还是异步操作对象。 定义个同步操作对象要比定义一个异步操作对象简单的多，对于一个同步操作对象来讲，所有你要做的工作就是实现main执行函数和响应取消操作事件。父类已经帮你做了所有其他该做的工作，而对于一个异步操作对象来将，你需要替换一些父类已经做过的工作，在你自己定义的操作对象上。下面的俩小节将介绍如何去实现这俩种不同的操作对象。</p>\n<h3 id=\"3-5-1-执行main任务\"><a href=\"#3-5-1-执行main任务\" class=\"headerlink\" title=\"3.5.1 执行main任务\"></a><a href=\"#4\">3.5.1 执行main任务</a></h3><p>至少一个操作对象需要实现下面的函数 一个自定义的初始化函数 main 你需要自定义个初始化函数去初始化一个操作对象，以及一个自定义的main函数去执行任务，你也可以根据需要执行其他的函数，如下所示 自定义函数供你的main函数去调用 属性方法去访问数据 实现NSCoding协议去固化一个操作对象 下面的模板，展示了一个自定义的操作对象，下面的代码并不展示如何去实现取消方法，但是也实现了你通常要实现的方法，具体怎么取消任务，参见取消任务介绍，下面的初始化函数初始化了一个对象，携带一个数据参数并把它存到了类内部方便以后访问，main函数将会显式的去操作这个对象，在你的应用将结果返回给你之前。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyNonConcurrentOperation</span> : <span class=\"title\">NSOperation</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"keyword\">id</span> (<span class=\"keyword\">strong</span>) myData; </div><div class=\"line\">-(<span class=\"keyword\">id</span>)initWithData:(<span class=\"keyword\">id</span>)data;</div><div class=\"line\"><span class=\"keyword\">@end</span> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyNonConcurrentOperation</span> </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithData:(<span class=\"keyword\">id</span>)data &#123; </div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) </div><div class=\"line\">\tmyData = data;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)main &#123; </div><div class=\"line\">\t<span class=\"keyword\">@try</span> &#123;</div><div class=\"line\">\t <span class=\"comment\">// Do some work on myData and report the results. </span></div><div class=\"line\">\t&#125; </div><div class=\"line\">\t<span class=\"keyword\">@catch</span>(...)</div><div class=\"line\">\t &#123;</div><div class=\"line\">\t  <span class=\"comment\">// Do not rethrow exceptions.</span></div><div class=\"line\">\t  &#125; </div><div class=\"line\">\t&#125; </div><div class=\"line\"><span class=\"keyword\">@end</span> 更多的细节参见<span class=\"built_in\">NSOperationSample</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5-2-响应取消事件\"><a href=\"#3-5-2-响应取消事件\" class=\"headerlink\" title=\"3.5.2 响应取消事件\"></a><a href=\"#4\">3.5.2 响应取消事件</a></h3><p>当一个操作开始执行的时候，它将持续执行任务直到结束或者任务被显式的取消掉，取消操作可能发生在任何时候，甚至是操作开始执行的时候，尽管NSOperation对象提供了一个方式供子类去使用，指出取消事件是完全必要的。如果一个操作完全结束了，那么也可以提供一个方式去清理之前分配的资源等等，所以，一个操作对象需要去检测是否已经取消了，然后就可以优雅的结束任务。 操作对象支持取消操作，你应该做的事情就是频繁的去检查是否任务已经被取消了，支持取消是非常重要的，对于你自定义的任务和系统给的那俩个子类操作对象来说，isCancel方法是非常轻量级的，可以频繁去访问而不会造成内存方面的空扰，当设计一个操作对象的时候，你可以在如下几个地方去访问iscancel 1、在你开始执行任务之前 2、在开启一个loop之前，或者是更加频繁的在每个循环之前 3、在你的每个可能导致任务退出的地方 下面的代码介绍了在main函数中如何去调用cancel，在这个例子中，iscancel在每次while loop前都会调用，使得任务可以快速的退出，且获取了一个定期的间隔。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123; </div><div class=\"line\"><span class=\"keyword\">@try</span> &#123; <span class=\"built_in\">BOOL</span> isDone = <span class=\"literal\">NO</span>; </div><div class=\"line\"><span class=\"keyword\">while</span> (![<span class=\"keyword\">self</span> isCancelled] &amp;&amp; !isDone) </div><div class=\"line\">&#123; <span class=\"comment\">// Do some work and set isDone to YES when finished &#125; &#125; </span></div><div class=\"line\"><span class=\"keyword\">@catch</span>(...) &#123; <span class=\"comment\">// Do not rethrow exceptions. &#125; &#125;</span></div></pre></td></tr></table></figure></p>\n<p>尽管上面的代码，并不包含清理数据的工作，但是你自己的代码还是要保证资源被及时的释放。</p>\n<h3 id=\"3-5-3-定义一个可并发执行的操作\"><a href=\"#3-5-3-定义一个可并发执行的操作\" class=\"headerlink\" title=\"3.5.3 定义一个可并发执行的操作\"></a><a href=\"#4\">3.5.3 定义一个可并发执行的操作</a></h3><p>一个操作对象默认情况是按照同步的方式去执行任务，也就是说他们执行任务的线程也就是start调用的线程。因为操作队列会对操作任务提供开启的线程，因此，大多数的任务就会异步运行，然而，如果你计划手动去执行一个任务，而且还希望这个任务异步的去运行，你必须得采取一些手段来保证能够这么干，你需要把你的操作对象定义为一个可并发执行的操作对象。下面列出来的函数就是你需要重写的并发操作。 start：（必须重写）所有的自定义并发操作必须重写这个函数，从而替换之前这个函数的默认实现。要手动的执行一个操作，你就可以调用start函数，因此从，你对该方法的实现就是自定义操作对象的开启任务的节点，也就是你要提交你的任务到线程中去执行的节点，你的实现在任何时候都不应该去调用super start。 main：（可选的）这个函数通常用来实现与操作对象相关的任务。虽然你可以把执行任务的任务放到start中去执行，利用mian方法去执行任务会对你的任务开始和清理工作有好处。 isExecuting：（必须的） isFinish：（必须） 并发操作非常有必要向使用它的客户报告配置环境和执行状态，因此一个并发操作必须得包含执行的状态信息包括何时开始执行任务，何时结束任务，如果要报告状态，那么必须使用这些方法。 当别的线程在同时调用上述方法的时候，你必须得保证这些方法是安全的。同时，你也必须得实现KVO通知，以报告这些状态。 isConcurrent：（必须）区分一个操作是否是并发操作，重写该方法，并返回YES 本小节的剩余部分将展示一个MyOperationClass的例子，这个类列举了实现一个并发操作的基本函数，MyOperation 类将在它自己开启的线程中执行任务，而正在的执行任务将与操作类是不相干的，下面例子将的几点，就是你在定义一个并发操作时需要提供的一些基础函数。 下面的代码显示了部分MyOperation的接口和实现函数，这些实现包括isConcurrent、isExecuting，isFinish，等函数。其中isConcurrent函数非常简单，只需要返回YES去指明本操作是一个并发操作就可以了，isExecuting 和 isFinished 也比较简单，返回在类中存储的成员变量的值就可以了。 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyOperation</span> : <span class=\"title\">NSOperation</span> </span></div><div class=\"line\">&#123; </div><div class=\"line\">\t<span class=\"built_in\">BOOL</span> executing;</div><div class=\"line\">\t<span class=\"built_in\">BOOL</span> finished; </div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)completeOperation;</div><div class=\"line\"><span class=\"keyword\">@end</span> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyOperation</span> </span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</div><div class=\"line\"> <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]; </div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">  executing = <span class=\"literal\">NO</span>; </div><div class=\"line\">  finished = <span class=\"literal\">NO</span>;</div><div class=\"line\">   &#125; </div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>; </div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isConcurrent &#123; <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>; &#125; </div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isExecuting &#123; <span class=\"keyword\">return</span> executing; &#125; </div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFinished &#123; <span class=\"keyword\">return</span> finished; &#125; </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>下面的方法展示了MyOperation的 start函数，下面的实现是一个start函数，执行任务至少要实现的内容。在这种情况下，start函数简单的开启一个新的线程，然后让这个线程去调用main函数。这个函数同样要更新executing成员变量，而且要对isExecuting关键路径产生KVO通知，当这些工作完成之后，就会离开函数，并去到新的线程中去执行任务。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123; <span class=\"comment\">// Always check for cancellation before launching the task. </span></div><div class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123; <span class=\"comment\">// Must move the operation to the finished state if it is canceled. [self willChangeValueForKey:@\"isFinished\"]; </span></div><div class=\"line\">finished = <span class=\"literal\">YES</span>; </div><div class=\"line\">[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; <span class=\"keyword\">return</span>; &#125;</div><div class=\"line\"><span class=\"comment\">// If the operation is not canceled, begin executing the task. </span></div><div class=\"line\">[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(main) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>]; executing = <span class=\"literal\">YES</span>; [<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面展示了MyOperation剩下的实现，在上面的代码已经知道 main函数将作为新的线程开启任务的节点，它将执行操作对象带来的任务，并且要执行completeOperation函数来说明任务已经结束，completeoperation函数将对isExecuting和isFinished关键路径发送KVO通知，来反应操作对象的状态已经改变。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)main &#123; </div><div class=\"line\">\t<span class=\"keyword\">@try</span> &#123; </div><div class=\"line\">\t\t<span class=\"comment\">// Do the main work of the operation here. </span></div><div class=\"line\">\t\t[<span class=\"keyword\">self</span> completeOperation]; </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t<span class=\"keyword\">@catch</span>(...) &#123; </div><div class=\"line\">\t<span class=\"comment\">// Do not rethrow exceptions.</span></div><div class=\"line\">\t &#125;</div><div class=\"line\">&#125; </div><div class=\"line\">- (<span class=\"keyword\">void</span>)completeOperation &#123; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">\texecuting = <span class=\"literal\">NO</span>; </div><div class=\"line\">\tfinished = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">\t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尽管是操作对象被取消掉了，你也应该发送KVO通知，来通知你的任务已经完成，当一个操作对象的执行时依赖其他操作对象的时候，它将检测isFinished状态，只有当它依赖的所有isfinished状态都变为YES的时候，如果无法发送isFinshed通知将会阻止其他依赖他的操作对象的执行。</p>\n<h3 id=\"3-5-4-维护KVO的兼容\"><a href=\"#3-5-4-维护KVO的兼容\" class=\"headerlink\" title=\"3.5.4 维护KVO的兼容\"></a><a href=\"#4\">3.5.4 维护KVO的兼容</a></h3><p>NSOperation类是服从下列关键字的KVO isCanceled isConcurrent isExecuting isFinished isReady dependencies queuePriority completeBlock 如果你重写了start函数，和自定义了一些其他比较重要的函数，而不是单单重写main函数，你必须保证自定义的对象能够响应KVO，当重写start函数，其中你最需要关注的就是isExecuting和isFInished，这里有大量的方法会受到这俩个函数的影响。 如果你想实现支持依赖关系，以对其他一些操作对象的时候，你也可以重写isReady函数，并强制返回NO，直到你自定义的依赖关系满足。（如果你仍然想支持系统提供的依赖关系的时候，请保证调用super的函数）当你操作对象的isReady状态发生变化的时候，请发送KVO通知去报告这个状态，不过幸运的是，除非你去重写addDependency和removeDependency:，你并不需要担心KVO通知的发送。 虽然你可以发送其他关键字的KVO通知，但是通常你并不需要这么做，如果你想取消一个任务，你可以简单的调用cancel函数就好了。同样的，你也不需要去修改队列的优先级在操作对象上，最后，除非你的操作对象支持动态的修改isConcurrent，你也不需要发送KVO通知给isConcurrent关键路径。 如果要知道更多关于KVO的操作，请参见KVO编程指导。</p>\n<h2 id=\"3-6-自定义一个操作对象的执行行为\"><a href=\"#3-6-自定义一个操作对象的执行行为\" class=\"headerlink\" title=\"3.6 自定义一个操作对象的执行行为\"></a><a href=\"#3\">3.6 自定义一个操作对象的执行行为</a></h2><p>在添加一个操作对象到操作队列里面之前，需要将一个操作对象设置好，这些对操作对象设置的信息将会对所有的操作对象有效，不仅是自定义的操作对象，还包括系统定义的那俩个操作对象。</p>\n<h3 id=\"3-6-1-设置依赖关系\"><a href=\"#3-6-1-设置依赖关系\" class=\"headerlink\" title=\"3.6.1 设置依赖关系\"></a><a href=\"#4\">3.6.1 设置依赖关系</a></h3><p>依赖是一种限制操作对象执行顺序的一种手段，一个操作对象的执行，必须得在它依赖的所有对象执行完成之后才能进行。也就是说，你可以创建简单的一对一的或者是负责的依赖关系树。 在俩个操作对象之间创建依赖关系，你可以使用addDependency：方法，这个方法可以在你传的目标对象和自己之间创建一个依赖关系。也就是说在目标对象没有执行完成之前，你的这个对象是不会执行的。依赖还不仅仅限制在一个操作队列中，因为是操作对象管理依赖关系，所以在不同的操作队列之中，依赖也是可以起到作用的。但是有一种情况是不允许的，那就是设置依赖环，这是一种语法错误，会导致任务永远得不到执行。 当操作对象所依赖的所有操作对象都执行完成之后，操作对象就变成ready状态，准备执行。（如果是你自己定义的操作对象 ，并自定义了isReady函数，那么准备状态就和你设置的条件有关系了）如果一个操作对象是在操作队列中，那么isReady状态的操作对象在任何时候都可能被执行，如果你计划手动去执行一个操作对象的话，那么可以调用他的start方法。 重要:你应当在将操作对象提交到操作队列之前就去设置依赖关系，如果在之后去设置依赖，也许将不会阻止该任务的执行。 依赖基于的是操作对象间在任何时候都可能发生变化的KVO通知，如果你自定义了操作对象的话，你需要自己去发送KVO通知，以防出现依赖方面的问题。关于更多KVO的信息，参考维护KVO兼容，关于更多设置依赖的信息，参考NSOperation 类</p>\n<h3 id=\"3-6-2-改变操作对象的执行优先级\"><a href=\"#3-6-2-改变操作对象的执行优先级\" class=\"headerlink\" title=\"3.6.2 改变操作对象的执行优先级\"></a><a href=\"#4\">3.6.2 改变操作对象的执行优先级</a></h3><p>对于添加到队列中的操作对象，是否能够执行，首先是受操作对象的isReady状态控制，其次是他们的优先级，是否准备好执行，是由操作对象的依赖对象是否执行完来限制的，但是这个优先级是操作对象的一个属性值，默认情况下，所有新创建的操作对象都是普通优先级，但是你可以增加或者是减少操作对象的优先级，通过setQueuePriority方法 优先级只对同一个队列中的操作对象起作用，如果你的应用有多个操作队列，不同队列中的操作对象的优先级是相互独立的，也就是说，在不同队列里面，存在低优先级的操作比高优先级的操作先执行。 优先级并不是依赖的替代，优先级决定的是那些在队列中已经是准备状态的操作对象的执行顺序，举个例子，如果一个队列中同时有高优先级和低优先级的操作对象准备好了，那么操作队列先执行高优先级的操作对象，然而，如果高优先级的没有准备好，但是低优先级的准备好了，那么将先执行低优先级的，如果你想阻止一个操作任务在另外一个操作对象执行完之后再执行，你需要使用依赖关系去 做</p>\n<h3 id=\"3-6-3-改变依附线程的优先级\"><a href=\"#3-6-3-改变依附线程的优先级\" class=\"headerlink\" title=\"3.6.3 改变依附线程的优先级\"></a><a href=\"#4\">3.6.3 改变依附线程的优先级</a></h3><p>在OSX 10.6及以后，设置一个操作对象所在的线程的优先级成为可能，系统的线程策略是依靠内核去管理，但是高优先级的线程将获得更高的执行机会，对一个操作对象，你可以显式的指定它的线程优先级，通过设置一个浮点型的数值，0-1.0之前。0是优先级最低、1是优先级最高。如果不显式设置的话，系统默认的线程优先级是0.5. 要设置线程优先级的话，你需要在讲操作对象添加到操作队列之前，调用setThreadPriority函数。当它的执行时间到来的时候，默认的start函数就会设置你之前指定的线程优先级来修改优先级。这个优先级只在你执行的main函数执行过程用有效。所有的其他代码包括你的完成回调，仍然是运行在默认的优先级下的。如果你自定义了一个并发的操作，那么你需要重写start函数，并手动去修改线程的优先级。</p>\n<h3 id=\"3-6-4-设置一个完成后的回调block\"><a href=\"#3-6-4-设置一个完成后的回调block\" class=\"headerlink\" title=\"3.6.4 设置一个完成后的回调block\"></a><a href=\"#4\">3.6.4 设置一个完成后的回调block</a></h3><p>在OSX 10.6及以后，一个操作对象可以在它的所有任务执行完成之后去执行一个完成的block，你可以用这个完成的block执行任何与main函数执行的任务里面不相关的的block。举个例子，你可能需要告诉客户这个操作对象的任务都执行完成了，一个并发的操作对象可能会使用这个block去执行它最后的KVO通知 要设置一个完成block，你可以使用setCompleteBlock：函数，这个函数不需要传任何参数，也没有返回值。</p>\n<h2 id=\"3-7-关于实现一个操作对象的一些Tips\"><a href=\"#3-7-关于实现一个操作对象的一些Tips\" class=\"headerlink\" title=\"3.7 关于实现一个操作对象的一些Tips\"></a><a href=\"#3\">3.7 关于实现一个操作对象的一些Tips</a></h2><p>尽管一个操作对象可能非常容易去实现，但是有一些事情在你自定义的操作对象上还是要注意一下，下面的小段描述了这么几个方面。</p>\n<h3 id=\"3-7-1-管理操作对象的内存\"><a href=\"#3-7-1-管理操作对象的内存\" class=\"headerlink\" title=\"3.7.1 管理操作对象的内存\"></a><a href=\"#4\">3.7.1 管理操作对象的内存</a></h3><p>下面的小段，描述了几个在操作对象中管理内存的关键元素，关于更多的OC的内存管理，参见内存管理开发指导。</p>\n<h4 id=\"3-7-1-1-避免依靠线程存储数据\"><a href=\"#3-7-1-1-避免依靠线程存储数据\" class=\"headerlink\" title=\"3.7.1.1 避免依靠线程存储数据\"></a><a href=\"#5\">3.7.1.1 避免依靠线程存储数据</a></h4><p>尽管大多是的操作都是在一个线程中执行的，在同步操作对象中，这个线程通常是由操作队列分配给它的，如果一个操作队列将线程分配给操作对象，那么你需要知道这个线程它是属于操作队列的，你不应该和你的操作对象有任何瓜葛，尤其是，你不应该有任何数据相关的在这个线程中，而这些数据并不是你创建和管理的数据，因为线程的生存和死亡是有操作队列或者系统来控制的，因此在线程间数据传递通过线程来传递将是不可靠，也是容易失败的。 在操作队列上，没有任何的理由可以使用线程存储数据，当你初始化一个操作对象，你应该提供给它所有执行任务需要的数据去做这件事，因此，操作对象要提供所有数据，所有来的、去的数据都应该存在操作对象上，知道任务结束或者应用不在需要它。</p>\n<h4 id=\"3-7-1-2-如果需要的话保持操作对象的引用\"><a href=\"#3-7-1-2-如果需要的话保持操作对象的引用\" class=\"headerlink\" title=\"3.7.1.2 如果需要的话保持操作对象的引用\"></a><a href=\"#5\">3.7.1.2 如果需要的话保持操作对象的引用</a></h4><p>因为操作对象是异步运行的，你不应该认为你可以创建或者忘记他们，它们也只是对象而已，也需要你去管理他们，尤其是你需要在它完成之后获取数据的情况下。 你需要保持对操作对象的引用，主要还有可能你再没有机会获取这个操作对象的引用的机会了，操作对象是执行很快的，在很多情况下，操作任务一旦添加到操作队列中，就会被执行，当你的代码获取到从操作队列中拿到的操作对象的时候，很可能，这个操作对象已经结束了，并从操作队列移除了，释放了。</p>\n<h3 id=\"3-7-2-处理错误和异常\"><a href=\"#3-7-2-处理错误和异常\" class=\"headerlink\" title=\"3.7.2 处理错误和异常\"></a><a href=\"#4\">3.7.2 处理错误和异常</a></h3><p>由于操作对象在你的应用里面是完全独立的实例，因此有必要去处理那些异常和错误，在OSX 10.6及以后，默认的start的函数不在提供捕获异常。你自己的代码需要去直接的捕获和处理异常，如果需要也要检测错误代码并通知给应用程序，如果你替换了start函数，那么你的代码需要在程序离开底层线程之前就去处理这些异常。 你可能处理的错误可能有一下几种情况 检测UNIX errno 类型的错误 检测显式的由代码返回的错误 捕获来自你自己的代码和系统框架带来的异常 当一个操作对象没有准备好，start方法就开始执行的时候 当一个操作已经在执行或者执行完成了，或取消了，start函数被再次调用的。 当添加一个block任务，但是它已经被执行或者完成的。 当你准备从NSInvocationOperation对象获取数据，但是它已经被取消的情况。 如果你自定义的代码遇到异常或者错误，你需要提供操作步骤给你的应用去处理，Operation对象不会显式的把错误代码或者异常传递给你应用的其他地方，因此，如果对于应用程序是比较重要的信息，你需要提供相关必要的代码去处理这些错误。</p>\n<h2 id=\"3-8-决定操作对象合适的数量，不要太多，也不要太少\"><a href=\"#3-8-决定操作对象合适的数量，不要太多，也不要太少\" class=\"headerlink\" title=\"3.8 决定操作对象合适的数量，不要太多，也不要太少\"></a><a href=\"#3\">3.8 决定操作对象合适的数量，不要太多，也不要太少</a></h2><p>虽然可以给一个操作队列中，添加大量的操作对象，但是这么做，往往并不太好，像其他对象一样，创建NSOperation对象也是需要消耗内存，并且他们的执行也是需要开销的。如果你的每个任务都是很小的，而你又创建了成千上万个，你会发现你会消耗更多的时间在分发操作对象上，而不是在执行真正的任务，而如果你的设备已经内存不足时，你会发现成千上万的任务会严重影响程序的性能。 高效的应用操作对象的关键在于，在充分利用设备和执行一定数量的操作任务之间找到平衡点，尝试去找到你的设备执行任务的一个真正的数量值。举个例子，如果你的应用创建了100个操作对象去处理100个不同的值，那么你可以考虑使用10个操作对象，去处理10个值去代替。 同时，你也需要避免一次性的给操作队列中添加大量的任务，也要避免不停的给操作队列以比它处理速度更快的添加更多的任务，相比于一次泛哄式的添加任务，不如批量式的去添加，然后利用完成block回调去执行下一批次的任务。这样可以避免内存过多的消耗。 当然，创建操作对象的数量、以及没个操作对象需要执行的任务量，是由你的程序动态去管理的。你应该是用性能测试工具，例如Instruments去找到性能处理和速度的平衡点，关于Instruments 和其他性能工具的更多信息，参见性能。</p>\n<h2 id=\"3-9-操作对象的执行\"><a href=\"#3-9-操作对象的执行\" class=\"headerlink\" title=\"3.9 操作对象的执行\"></a><a href=\"#3\">3.9 操作对象的执行</a></h2><p>最后，你的应用需要执行这些操作对象以真正的处理任务，在这一小节，你将学到就像你熟练的执行你的操作一样，去执行这些操作。</p>\n<h3 id=\"3-9-1-添加操作对象到操作队列中\"><a href=\"#3-9-1-添加操作对象到操作队列中\" class=\"headerlink\" title=\"3.9.1 添加操作对象到操作队列中\"></a><a href=\"#4\">3.9.1 添加操作对象到操作队列中</a></h3><p>到目前为止，最容易的执行操作的方式是使用操作队列，即NSOperationQueue类的实例，你的应用有责任去创建和维护这些操作队列。一个应用程序可以有任意数量的操作队列，但是实际上在同一时间有多少个操作会被执行还是有限制的，被系统调用的操作队列会根据可利用的CPU和系统的载入量来进行限制单位时间执行的操作对象，因此，创建更多的操作队列并不意味着可以执行更多的操作对象 就想创建其他的对象一样，在你的应用中创建操作队列<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSOperationQueue</span>* aQueue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</div></pre></td></tr></table></figure></p>\n<p>添加一个操作对象到操作队列中，你可以使用addOperation方法，在OSX 10.6以后，你还可以添加操作对象组，通过<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addOperations：waitUntilFinished：</div></pre></td></tr></table></figure></p>\n<p>方法，你也可以直接添加blocl对像到操作队列中（而不需要与一个操作对象关联），通过<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addOperationWithBlock：</div></pre></td></tr></table></figure></p>\n<p>方法，上面的这些方法，队列都会入一个操作对象并通知队列去执行他们，在大多数情况下，操作对象将会被很快执行，但是有时候，操作队列也可能延迟执行操作对象，大概有这么几个原因，最普遍的就是，操作对象间可能有依赖关系，还有可能是操作队列自己可能被挂起，或者是操作队列执行操作任务的数量达到了上限。下面的代码展示了最基础的添加操作到操作队列的语法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[aQueue addOperation:anOp]; <span class=\"comment\">// Add a single operation </span></div><div class=\"line\">[aQueue addOperations:anArrayOfOps waitUntilFinished:<span class=\"literal\">NO</span>]; <span class=\"comment\">// Add multiple operations </span></div><div class=\"line\">[aQueue addOperationWithBlock:^&#123; <span class=\"comment\">/* Do something. */</span></div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure></p>\n<p> 重要 千万不要在一个操作对象进入操作队列之后再去修改它，因为当操作在操作队列中等待执行的时候，它可能在任何时候去执行任务，改变它的依赖和数据，可能会起到坏的作用。如果你想知道一个操作对象的状态，请使用操作对象的属性 去获取。</p>\n<h3 id=\"3-9-2-手动执行操作对象\"><a href=\"#3-9-2-手动执行操作对象\" class=\"headerlink\" title=\"3.9.2 手动执行操作对象\"></a><a href=\"#4\">3.9.2 手动执行操作对象</a></h3><p>尽管操作队列对于运行操作对象已经很方便了，但是还是有一种可能不使用操作队列去执行一个操作对象，如果你选择手动去执行操作对象，那么有一些注意事项，最主要的是，操作对象必须得是ready，而且你需要用start函数去启动它。 一个操作对象如果不是ready状态的话不应该去执行，isReady函数被Operation对象的依赖关系封装到了上层，只有当它的依赖关系都清除的时候，一个操作才能够被执行、 当执行一个操作对象，应该去使用start函数去做。用这个函数而不是用main，是因为start函数会在执行之前执行一个安全检查，尤其是，默认的start函数还会产生KVO通知，以保证依赖关系能够正确进行，这个函数同时也避免当你的操作对象被取消的时候，再去执行，以及当操作对象没有准备好的时候就去调用导致的异常抛出 。 如果你的程序定义了并发的操作对象，你同时需要在启动任务之前考虑isConcurrent。当这个方法返回NO的时候，你就可以考虑是在当前线程中同步的执行还是创建一个新的子线程。然而，这些方法的检测完全取决于你。 下面展示了一个比较简单的，手动开启并发操作对象的一个例子。如果这个函数返回NO，你可以启动一个timer，在之后再去调用它。然后直到它返回YES之后，取消掉Timer。因为这种情况可能在操作对象被取消的时候发生。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)performOperation:(<span class=\"built_in\">NSOperation</span>*)anOp &#123; </div><div class=\"line\">\t<span class=\"built_in\">BOOL</span> ranIt = <span class=\"literal\">NO</span>; </div><div class=\"line\">\t<span class=\"keyword\">if</span> ([anOp isReady] &amp;&amp; ![anOp isCancelled]) &#123; </div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (![anOp isConcurrent]) </div><div class=\"line\">\t\t[anOp start]; </div><div class=\"line\">\t\t<span class=\"keyword\">else</span> [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(start) toTarget:anOp withObject:<span class=\"literal\">nil</span>]; </div><div class=\"line\">\t\tranIt = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([anOp isCancelled])&#123; </div><div class=\"line\">\t\t<span class=\"comment\">// If it was canceled before it was started, // move the operation to the finished state. </span></div><div class=\"line\">\t \t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">\t \t[<span class=\"keyword\">self</span> willChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>];</div><div class=\"line\">\t  \texecuting = <span class=\"literal\">NO</span>; </div><div class=\"line\">\t  \tfinished = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t  \t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isExecuting\"</span>]; </div><div class=\"line\">\t  \t[<span class=\"keyword\">self</span> didChangeValueForKey:<span class=\"string\">@\"isFinished\"</span>]; </div><div class=\"line\">\t  \t<span class=\"comment\">// Set ranIt to YES to prevent the operation from </span></div><div class=\"line\">\t  \t<span class=\"comment\">// being passed to this method again in the future. </span></div><div class=\"line\">\t  \tranIt = <span class=\"literal\">YES</span>; </div><div class=\"line\">\t&#125; <span class=\"keyword\">return</span> ranIt; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-9-3-取消操作对象\"><a href=\"#3-9-3-取消操作对象\" class=\"headerlink\" title=\"3.9.3 取消操作对象\"></a><a href=\"#4\">3.9.3 取消操作对象</a></h3><p>当将操作对象添加到操作队列里面的时候，一个操作对象的管理就交给了操作队列，也不能被移除了，唯一使操作对象出列的方法就是调用它的cancel函数，你也可以取消所有的操作对象，通过调用操作队列的cancelAllOperations 你可以在确保你不在需要操作对象的时候取消掉它。发出一个cancel命令，会将操作对象的关键路径变为canceled状态，这将阻止任务继续执行，由于canceled的操作对象也认为是完成的，那么依赖它的操作对象就可以移除依赖关系。然而，更多情况下，更常用的是取消所有操作独享，在某些重要的时候，比如应用退出、或者用户发出了取消指令，这比一个个取消要好很多。</p>\n<h3 id=\"3-9-4-等待操作对象的完成\"><a href=\"#3-9-4-等待操作对象的完成\" class=\"headerlink\" title=\"3.9.4 等待操作对象的完成\"></a><a href=\"#4\">3.9.4 等待操作对象的完成</a></h3><p>为了获取最佳的性能，你应该尽可能的让操作对象并发执行，让系统去干更多的事情，在你执行操作对象任务的时候，如果创建一个操作对象的时候，同时希望获得了操作对象的结果，你可以使用waitUntilFinished：方法来阻塞代码继续执行，直到这个操作对象执行完成。通常来讲，这是最好的方式去避免你能帮到它的时候，阻塞当前线程也许是一个比较好的解决方法。但这也带来了更多的同步性，而限制了整体的可并发性。 你绝不允许在主线程中调用这个方法，你最好在子线程或者其他的线程操作中这么做，阻塞主线程将会降低程序的可响应性。 除了等待一个任务完成，你可以等待一个操作队列所有的任务执行完成，通过调用waitUntilAllOperationsAreFinished，当你等待一个操作队列任务完成的时候，避免在别的线程中添加任务给它，以防延长等待时间。</p>\n<h3 id=\"3-9-5-挂起和恢复操作队列\"><a href=\"#3-9-5-挂起和恢复操作队列\" class=\"headerlink\" title=\"3.9.5 挂起和恢复操作队列\"></a><a href=\"#4\">3.9.5 挂起和恢复操作队列</a></h3><p>如果你想中途终止一个操作队列的话，你可以挂起相应的操作队列，使用setSuspended方法，挂起一个操作队列并不会导致正在执行的操作任务终止。它只是会阻止别的操作对象（操作队列中的）不去执行，你可能会在用户想暂停任务的时候挂起所有操作，因为用户还期望在某个时候恢复这些任务。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cix9ujtfl0000492wg1drvkjb","tag_id":"cix9ujtfr0002492wdq4ipjhx","_id":"cix9ujtg00007492wqqjhupg1"},{"post_id":"cix9ujtg00008492wevmqsl8m","tag_id":"cix9ujtfr0002492wdq4ipjhx","_id":"cix9ujtg3000b492wbhx31zkl"},{"post_id":"cix9ujtfp0001492w0cmotz39","tag_id":"cix9ujtfz0005492w79pznuh3","_id":"cix9ujtg5000d492wfxrzae8e"},{"post_id":"cix9ujtg10009492wgifyiiok","tag_id":"cix9ujtfz0005492w79pznuh3","_id":"cix9ujtg7000g492w4wx50gk1"},{"post_id":"cix9ujtg3000c492wv5vbikni","tag_id":"cix9ujtfz0005492w79pznuh3","_id":"cix9ujtg8000h492w37obnzli"},{"post_id":"cix9ujtfu0003492wwapnd9ol","tag_id":"cix9ujtfz0005492w79pznuh3","_id":"cix9ujtg8000j492wc4wai8t8"},{"post_id":"cix9ujtfu0004492wmqg3tyx2","tag_id":"cix9ujtfz0005492w79pznuh3","_id":"cix9ujtg8000k492wycgk3fig"},{"post_id":"cix9ujtfz0006492wr4c1bbyb","tag_id":"cix9ujtfz0005492w79pznuh3","_id":"cix9ujtg9000m492w60dakb1y"},{"post_id":"cix9ujtg6000e492wv9lummqo","tag_id":"cix9ujtg9000l492wqr2ncmvg","_id":"cix9ujtg9000n492w6yqw1jgv"}],"Tag":[{"name":"coredata学习","_id":"cix9ujtfr0002492wdq4ipjhx"},{"name":"点点滴滴","_id":"cix9ujtfz0005492w79pznuh3"},{"name":"翻译","_id":"cix9ujtg9000l492wqr2ncmvg"}]}}